

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zs">
  <meta name="keywords" content="">
  
    <meta name="description" content="课程网站：https:&#x2F;&#x2F;cs61c.org&#x2F;su20&#x2F; B 站 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1fC4y147iZ&#x2F;?vd_source&#x3D;518199b8942410d3723d3db827513479 https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list&#x3D;PLDoI-XvXO0aqgoMQvogzmf7CKiSMSUS3M https">
<meta property="og:type" content="article">
<meta property="og:title" content="cs16c">
<meta property="og:url" content="http://shuaizhang1998.github.io/2023/11/19/CS61C_%20Great%20Ideas%20in%20Computer%20Architecture/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="课程网站：https:&#x2F;&#x2F;cs61c.org&#x2F;su20&#x2F; B 站 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1fC4y147iZ&#x2F;?vd_source&#x3D;518199b8942410d3723d3db827513479 https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list&#x3D;PLDoI-XvXO0aqgoMQvogzmf7CKiSMSUS3M https">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-19T15:08:27.480Z">
<meta property="article:modified_time" content="2023-11-19T15:11:00.371Z">
<meta property="article:author" content="Zs">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>cs16c - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shuaizhang1998.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="cs16c"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-19 23:08" pubdate>
          2023年11月19日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          51k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          423 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">cs16c</h1>
            
            
              <div class="markdown-body">
                
                <ul>
<li>课程网站：<a
target="_blank" rel="noopener" href="https://cs61c.org/su20/">https://cs61c.org/su20/</a></li>
<li>B 站 <a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fC4y147iZ/?vd_source=518199b8942410d3723d3db827513479">https://www.bilibili.com/video/BV1fC4y147iZ/?vd_source=518199b8942410d3723d3db827513479</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLDoI-XvXO0aqgoMQvogzmf7CKiSMSUS3M">https://www.youtube.com/playlist?list=PLDoI-XvXO0aqgoMQvogzmf7CKiSMSUS3M</a></li>
<li><a
target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/CS61C-summer20/tree/master/slides">https://github.com/PKUFlyingPig/CS61C-summer20/tree/master/slides</a></li>
</ul>
<h1 id="lecture-1-number-representation">Lecture 1 Number
Representation</h1>
<ul>
<li><p>numbers representate everything</p>
<p>数字可以表示任何东西，只需要对其赋予意义，例如对于1-10来说</p>
<ul>
<li>可以代表10个正数</li>
<li>可以代表10个不同的东西</li>
<li>....</li>
</ul></li>
<li><p>为什么使用二进制</p>
<ul>
<li>涉及到电气的特性，2进制信号可以简单的用高低电平来表示，这提供了更大的容错率，在一定的电压区间中，进制越高，错误率越高。</li>
<li><span class="math inline">\(C_{10} = a[n-1] \cdot r^{n-1} + a[n-2]
\cdot r^{n-2} + \ldots + a[0] \cdot r^0\)</span> <span
class="math inline">\(r\)</span>代表<span
class="math inline">\(r\)</span>进制</li>
<li><span class="math inline">\(1011 = 1*2^0+1*2^1+0+1*2^3\)</span></li>
</ul></li>
<li><p>怎么表示有符号数</p>
<ul>
<li>Sign and Magnitude （符号-幅度 原码）
<ul>
<li>最高位代表符号位，其余位代表数值，缺点是（同时存在两种0：<code>100</code>
= <code>000</code>)</li>
</ul></li>
<li>Biased Notation （偏置法）
<ul>
<li>思想就是定义域的移动，选取某个正区间中的某个数作为<code>0</code><br />
</li>
</ul></li>
<li>One‘s Complement （1补数 反码）
<ul>
<li>同样使得最高位代表符号位，最大正数为<code>0111...111</code>,最小负数为<code>100...000</code>,同样存在两个<code>0</code>（<code>000 = 111</code>），有溢出问题(循环移位）</li>
</ul></li>
<li>Two‘s Complement <strong>（2补数 补码）</strong>
<ul>
<li>现在都在用的，处理溢出问题比较简单（<code>++ -&gt; -</code>
<code>-- -&gt; +</code> <code>+(-)- -&gt; -</code>
<code>-(-)+ -&gt;+</code>，现代处理器检查溢出标志位</li>
<li><code>111...111</code>不在代表<code>0</code>而是代表<code>1</code></li>
</ul></li>
</ul></li>
<li><p>有符号数的处理</p>
<ul>
<li>Sign Extension 很多操作需要，例如不同位宽数据的运算
<ul>
<li>正数添加前导0即可，负数则需要先复制符号位，然后再复制其余位。符号位复制多少次取决于新的位宽，例如从8位到16位，则需要把符号位复制8次。</li>
</ul></li>
</ul></li>
<li><p>转换规则推荐</p>
<ul>
<li><code>Ki=1024</code> ，而<code>K=1000</code>
。<code>B</code>是字节（Byte） ，而<code>b</code>是二进制位</li>
</ul></li>
<li><p>原码，反码，补码 用补码运算，用原码看结果</p>
<ul>
<li>0三码都为0</li>
<li>正数三码相等</li>
<li>负数反码是原码符号位以外全部取反，补码在反码基础上加1</li>
</ul></li>
</ul>
<h1 id="lecture-2-intro-with-c">Lecture 2 Intro with c</h1>
<ul>
<li>学完<code>Introductory C Programming Specialization</code>即可</li>
</ul>
<h1 id="lecture-3-intro-with-array">Lecture 3 Intro with array</h1>
<ul>
<li><p>学完<code>Introductory C Programming Specialization</code>即可 #
Lecture 4 Memory Management and Usage</p></li>
<li><p>学完<code>Introductory C Programming Specialization</code>即可</p></li>
</ul>
<h1 id="lecture-5-floating-representation">Lecture 5 floating
representation</h1>
<ul>
<li>十进制or二进制<code>**点分法**</code>理论上可以表示无穷的精度
<ul>
<li>例如<span class="math inline">\(\frac{1}{3} =
0.333.....\)</span></li>
<li>例如<span class="math inline">\(\frac{1}{10} =
0.0001100011...\)</span></li>
<li>为什么会出现无限循环小数</li>
</ul></li>
</ul>
<hr />
<p><strong>定理</strong>：考虑一个分数<span
class="math inline">\(\frac{a}{b} （其中b \neq 0 )\)</span>，若其在<span
class="math inline">\(N\)</span>进制下表示为有限小数，则分母<span
class="math inline">\(b\)</span>的所有质因子必须是进制数<span
class="math inline">\(N\)</span>的质因子。</p>
<p><strong>证明</strong>：</p>
<ol type="1">
<li>设<span class="math inline">\(N\)</span>的质因子分解为：<span
class="math inline">\(N = p_1^{k_1} p_2^{k_2} \dots
p_m^{k_m}\)</span>，其中，<span class="math inline">\(p_1, p_2, \dots,
p_m\)</span>是质数，且<span class="math inline">\(k_1, k_2, \dots,
k_m\)</span>是正整数。</li>
<li>若<span class="math inline">\(\frac{a}{b}\)</span>在<span
class="math inline">\(N\)</span>进制下是有限小数，则存在某个正整数<span
class="math inline">\(s\)</span>使得<span class="math inline">\(b \times
N^s\)</span>是一个整数。这意味着：</li>
</ol>
<p><span class="math inline">\(b \times N^s = b \times p_1^{k_1 s}
p_2^{k_2 s} \dots p_m^{k_m s}\)</span>是一个整数。</p>
<ol start="3" type="1">
<li>现在考虑<span class="math inline">\(b\)</span>的质因子分解。若<span
class="math inline">\(b\)</span>有一个质因子<span
class="math inline">\(q\)</span>不是<span
class="math inline">\(N\)</span>的质因子（ 即<span
class="math inline">\(q\)</span>不等于任何的<span
class="math inline">\(p_i\)</span>），则对于任何正整数<span
class="math inline">\(s\)</span>，乘积<span class="math inline">\(b
\times N^s\)</span>都不可能是整数，因为无法消除这个“外部”质因子<span
class="math inline">\(q\)</span>。</li>
</ol>
<hr />
<ul>
<li>二进制点分法中的点的位置不确定(多少位表示整数，多少位表示小数)，所以引入<code>二进制科学计数法</code>
<ul>
<li>优点
<ul>
<li>相对于二进制点分法
表示的范围能够很轻松的通过调整指数和尾数来<strong>扩大或减小数的范围</strong></li>
</ul></li>
<li>缺点
<ul>
<li>实际计算的舍入误差 （尾数位有限导致）</li>
<li>不精确的表示 （尾数位有限导致）</li>
</ul></li>
</ul></li>
</ul>
<hr />
<p>给定一个非零实数 <span
class="math inline">\(x\)</span>，在二进制科学计数法中，<span
class="math inline">\(x\)</span> 可以表示为： <span
class="math inline">\(x = (-1)^s \times 1.f_1 f_2 f_3 \ldots \times
2^e\)</span> 其中：</p>
<ol type="1">
<li><span class="math inline">\(s\)</span> 是符号位，当 <span
class="math inline">\(x\)</span> 为正数时 <span class="math inline">\(s
= 0\)</span>，当 <span class="math inline">\(x\)</span> 为负数时 <span
class="math inline">\(s = 1\)</span>。</li>
<li><span class="math inline">\(1.f_1 f_2 f_3 \ldots\)</span>
是一个二进制小数（<code>尾数</code>），其中 <span
class="math inline">\(f_i\)</span> 是位于小数点后的第 <span
class="math inline">\(i\)</span> 位的数字，每个 <span
class="math inline">\(f_i\)</span> 要么为 <span
class="math inline">\(0\)</span> 要么为 <span
class="math inline">\(1\)</span>。注意，我们默认小数点前有一个<span
class="math inline">\(1\)</span>，这是因为在二进制科学计数法的规范化表示中，非零数的最高有效位<strong>总是1。</strong></li>
<li><span class="math inline">\(e\)</span>
是一个整数（<code>指数</code>），代表二进制指数。</li>
</ol>
<p>例如，数字 <span class="math inline">\(13\)</span> 在二进制中表示为
<span class="math inline">\(1101\)</span>，其二进制科学计数法表示为
<span class="math inline">\(1.101 \times 2^3\)</span>。 在计算机的IEEE
754浮点数表示法中，因为最高有效位总是1，所以通常会省略它以节省存储空间。这是所谓的"隐藏位"技术。</p>
<hr />
<ul>
<li>IEEE754是目前常用的标准</li>
</ul>
<p><code>符号位（1位）``指数位（阶码 8位无符号数）``尾数位（小数位 23位）</code>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">annotated_ieee754_conversion</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Convert a floating-point number to its IEEE 754 single-precision representation.</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Parameters:</span><br><span class="hljs-string">    - num: Floating-point number to be converted</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">    - Tuple containing (sign_bit, exponent_binary, fraction_bits)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    <span class="hljs-comment"># Step 1: Determine the sign bit</span><br>    <span class="hljs-comment"># If the number is positive or zero, sign bit is 0. Otherwise, it&#x27;s 1.</span><br>    sign_bit = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> num &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># Convert the number to positive for further processing.</span><br>    num = <span class="hljs-built_in">abs</span>(num)<br><br>    <span class="hljs-comment"># Step 2: Convert the number to binary representation.</span><br>    <span class="hljs-comment"># Convert the integer part of the number to binary.</span><br>    int_part = <span class="hljs-built_in">int</span>(num)<br>    int_binary = <span class="hljs-built_in">bin</span>(int_part)[<span class="hljs-number">2</span>:]<br>    <br>    <span class="hljs-comment"># Convert the fractional part of the number to binary.</span><br>    frac_num = num - int_part<br>    frac_binary = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(frac_binary) &lt; <span class="hljs-number">40</span> <span class="hljs-keyword">and</span> frac_num != <span class="hljs-number">0</span>:  <span class="hljs-comment"># Limit to 40 bits for precision.</span><br>        frac_num *= <span class="hljs-number">2</span><br>        frac_bit = <span class="hljs-built_in">int</span>(frac_num)<br>        frac_binary += <span class="hljs-built_in">str</span>(frac_bit)<br>        frac_num -= frac_bit<br><br>    <span class="hljs-comment"># Combine the integer and fractional parts.</span><br>    combined_binary = int_binary + frac_binary<br>    <br>    <span class="hljs-comment"># Step 3: Normalize the binary representation.</span><br>    normalized_position = combined_binary.index(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    <br>    <span class="hljs-comment"># Calculate the number of shifts required to normalize the number.</span><br>    shift = <span class="hljs-built_in">len</span>(int_binary) - <span class="hljs-number">1</span> - normalized_position <br>    <br>    <span class="hljs-comment"># Step 4: Calculate the biased exponent.</span><br>    <span class="hljs-comment"># IEEE 754 single-precision format uses a bias of 127.</span><br>    exponent_with_bias = shift + <span class="hljs-number">127</span><br>    exponent_binary = <span class="hljs-built_in">bin</span>(exponent_with_bias)[<span class="hljs-number">2</span>:].rjust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>    <br>    <span class="hljs-comment"># Step 5: Determine the fraction part with rounding.</span><br>    fraction_24_bits = combined_binary[normalized_position+<span class="hljs-number">1</span>:normalized_position+<span class="hljs-number">25</span>].ljust(<span class="hljs-number">24</span>, <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment"># Ensure length</span><br><br>    <span class="hljs-comment"># Implement the &quot;round to nearest, ties to even&quot; strategy.</span><br>    <span class="hljs-keyword">if</span> fraction_24_bits[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">in</span> fraction_24_bits[<span class="hljs-number">1</span>:] <span class="hljs-keyword">or</span> fraction_24_bits[-<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>            fraction_bits = <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(fraction_24_bits[:-<span class="hljs-number">1</span>], <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>)[<span class="hljs-number">2</span>:].rjust(<span class="hljs-number">23</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            fraction_bits = fraction_24_bits[:-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">else</span>:<br>        fraction_bits = fraction_24_bits[:-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">return</span> (sign_bit, exponent_binary, fraction_bits)<br><br><span class="hljs-comment"># The testing part remains the same as before.</span><br>consistent = <span class="hljs-literal">True</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>    random_num = random.uniform(-<span class="hljs-number">1e6</span>, <span class="hljs-number">1e6</span>)<br>    single_precision_num = <span class="hljs-built_in">float</span>(random_num)<br>    manual_ieee754 = annotated_ieee754_conversion(single_precision_num)<br>    <br>    binary_representation = <span class="hljs-built_in">format</span>(struct.unpack(<span class="hljs-string">&#x27;!I&#x27;</span>, struct.pack(<span class="hljs-string">&#x27;!f&#x27;</span>, single_precision_num))[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;032b&#x27;</span>)<br>    builtin_sign_bit = <span class="hljs-built_in">int</span>(binary_representation[<span class="hljs-number">0</span>])<br>    builtin_exponent = binary_representation[<span class="hljs-number">1</span>:<span class="hljs-number">9</span>]<br>    builtin_fraction = binary_representation[<span class="hljs-number">9</span>:]<br>    builtin_ieee754 = (builtin_sign_bit, builtin_exponent, builtin_fraction)<br>    <br>    <span class="hljs-keyword">if</span> manual_ieee754 != builtin_ieee754:<br>        consistent = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">break</span><br><br>consistent<br><br></code></pre></td></tr></table></figure></p>
<ul>
<li>浮点数存在精度问题</li>
</ul>
<p><strong>基本概念</strong>: IEEE 754
浮点数使用固定数量的位来表示实数。由于实数范围是无限的，而我们的表示位数是有限的，所以必然会有精度损失。
<strong>具体问题</strong>：</p>
<ol type="1">
<li><strong>非规范化数与规范化数</strong>:
当数值非常接近于0，我们使用非规范化数来表示。这意味着我们放弃了一个隐含的前导1，以获得更多的小数点后的位数，但这降低了精度。</li>
<li>考虑一个非常小的数，如 <span class="math inline">\(1.0 \times
10^{-45}\)</span> 在 IEEE 754
单精度格式中，这个数是一个非规范化数，因为它太小了，无法用规范化数表示。</li>
<li><strong>舍入错误</strong>:
由于表示位数的限制，当我们尝试表示某些数值时，可能需要进行舍入。这导致了所谓的舍入错误。</li>
<li>考虑数字 <span
class="math inline">\(0.1\)</span>。在二进制中，它是一个无限重复的小数。因此，当我们尝试将其表示为
IEEE 754 浮点数时，它必须被舍入，导致精度损失。</li>
<li><strong>计算中的累积误差</strong>:
在进行浮点运算时（如加法、乘法等），误差可能会累积，特别是在迭代计算中。</li>
<li>考虑一个简单的操作：将 <span class="math inline">\(0.1\)</span> 加上
<span class="math inline">\(0.2\)</span>。理论上，结果应该是 <span
class="math inline">\(0.3\)</span>，但由于舍入误差，实际的浮点计算结果可能会略有不同。</li>
<li><strong>浮点数相等性</strong>:
由于精度问题，直接比较两个浮点数是否相等通常是不安全的。例如，计算的结果(0.3
+ 0.3 + 0.3)可能不等于(0.9)，尽管差异很小。</li>
<li>假设我们有一个程序，它计算 <span class="math inline">\(0.3 - 0.2 -
0.1\)</span>。理论上，结果应该是 <span
class="math inline">\(0\)</span>，但由于舍入误差，实际的浮点结果可能非常接近于零，但不完全是零。</li>
<li><strong>消失的尾数位</strong>:
当差异很大的两个数相加时，小的数可能在结果中"消失"，因为它对最终结果的贡献太小，不能在有限的尾数位中表示。</li>
<li>考虑两个数：<span class="math inline">\(10^9 + 1\)</span> 和 <span
class="math inline">\(10^9\)</span>。当它们相减时，理论上的结果是 <span
class="math inline">\(1\)</span>，但在浮点计算中，结果可能是 <span
class="math inline">\(0\)</span>，因为小的数在差异很大的数的计算中可能会“消失”。</li>
</ol>
<ul>
<li>浮点数等间隔中能表示的数的数量，随着数的大小的增加而减少</li>
</ul>
<p><strong>基本概念</strong>:
浮点数由符号、指数和尾数三部分组成。指数部分决定了数的范围或大小，而尾数部分决定了数的精度。</p>
<ol type="1">
<li><strong>固定宽度的尾数</strong>：尾数的宽度是固定的，例如，对于 IEEE
754
单精度，尾数有23位。这意味着，在给定的指数值下，我们可以表示的数的数量是固定的。</li>
<li>考虑数字 <span
class="math inline">\(1.23456789\)</span>。尽管这个数字在十进制中很简单，但在固定宽度的二进制浮点表示中，我们可能无法准确地表示它。</li>
<li><strong>等间隔表示</strong>:
对于给定的指数值，尾数的每一个位的增加都表示了一个等间隔的增量。但是，当指数值增加时，这个间隔会变得更大。因此，对于较大的数，我们可以表示的数之间的间隔会变得更大。</li>
<li>考虑两个相邻的 IEEE 754
单精度浮点数，其中一个具有最大的正指数和全零的尾数，而另一个具有最大的正指数但尾数增加了最小的量（即尾数的最后一位是1）。这两个数之间的差异将是巨大的。</li>
<li><strong>表示范围与间隔的权衡</strong>:
由于尾数宽度的限制，当我们表示更大的数时，我们可以表示的数的间隔必然增加。这意味着，尽管我们仍然可以表示大范围内的数，但这些数之间的间隔会变得更大，从而导致精度损失。</li>
<li>考虑数字 <span class="math inline">\(10^{30}\)</span> 和 <span
class="math inline">\(10^{30} +
10^{15}\)</span>。在单精度浮点数中，这两个数字可能会映射到相同的值，因为尾数的宽度限制了我们能够区分的数的数量。这显示了随着数的增大，我们失去了区分相对较小差异的能力。</li>
</ol>
<h1 id="lecture-6-assembly">Lecture 6 Assembly</h1>
<h2 id="lec06.pdfx86"><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698299457180-6a6c42fb-f3b9-40bb-9384-5f41bd85ecce.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698299457180-6a6c42fb-f3b9-40bb-9384-5f41bd85ecce.pdf%22%2C%22name%22%3A%22lec06.pdf%22%2C%22size%22%3A8497764%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22uf1db4eaf-271c-485e-a482-07a2dc2187d%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u6c61a067%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec06.pdf</a>x86</h2>
<ul>
<li><strong>Designer</strong>: Intel, AMD</li>
<li><strong>Bits</strong>: 16-bit, 32-bit and 64-bit</li>
<li><strong>Introduced</strong>:
<ul>
<li>1978 (16-bit)</li>
<li>1985 (32-bit)</li>
<li>2003 (64-bit)</li>
</ul></li>
<li><strong>Design</strong>: CISC</li>
<li><strong>Type</strong>: Register-memory</li>
<li><strong>Encoding</strong>: Variable (1 to 15 bytes)</li>
<li><strong>Endianness</strong>: Little</li>
<li><strong>Usage</strong>: Macbooks &amp; PCs (Core i3, i5, i7, M)</li>
</ul>
<hr />
<h2 id="arm-architectures">ARM architectures</h2>
<ul>
<li><strong>Designer</strong>: ARM Holdings</li>
<li><strong>Bits</strong>: 32-bit, 64-bit</li>
<li><strong>Introduced</strong>: 1985; 31 years ago</li>
<li><strong>Design</strong>: RISC</li>
<li><strong>Type</strong>: Register-Register</li>
<li><strong>Encoding</strong>:
<ul>
<li>AArch64/A64 and AArch32/A32 use 32-bit instructions</li>
<li>T32 (Thumb-2) uses mixed 16- and 32-bit instructions. ARMv7
user-space compatibility</li>
</ul></li>
<li><strong>Endianness</strong>: Bi (little as default)</li>
<li><strong>Usage</strong>: Smartphone-like devices (iPhone, Android),
Raspberry Pi, Embedded systems</li>
</ul>
<hr />
<h2 id="risc-v">RISC-V</h2>
<ul>
<li><p><strong>Designer</strong>: University of California,
Berkeley</p></li>
<li><p><strong>Bits</strong>: 32, 64, 128</p></li>
<li><p><strong>Introduced</strong>: 2010</p></li>
<li><p><strong>Version</strong>: 2.2</p></li>
<li><p><strong>Design</strong>: RISC</p></li>
<li><p><strong>Type</strong>: Load-store</p></li>
<li><p><strong>Encoding</strong>: Variable</p></li>
<li><p><strong>Branching</strong>: Compare-and-branch</p></li>
<li><p><strong>Endianness</strong>: Little</p></li>
<li><p><strong>Usage</strong>: Versatile and open-source. Relatively
new, designed for cloud computing, embedded systems, academic
use</p></li>
<li><p>早期指令集设计方向</p>
<ul>
<li>复杂指令集（不断细化指令） -&gt;
(难学，但是编译器可以做更少的事，比较慢，因为主要是设计更多的指令）
x86是典型 <code>CISC</code></li>
<li>精简指令集 -&gt;（好学，复杂的指令通过简单指令的组合来实现 快）
<code>RISC</code></li>
</ul></li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698299998791-135851ce-b583-4d5c-b382-7bf7e3c71a5c.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698299998791-135851ce-b583-4d5c-b382-7bf7e3c71a5c.pdf%22%2C%22name%22%3A%22RISV-2016-1.pdf%22%2C%22size%22%3A959927%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22uf7cc602f-2fe1-4ca7-af70-0e13efc8ca0%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22udd5c5e7a%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">RISV-2016-1.pdf</a></p>
<h2 id="registers">Registers</h2>
<ul>
<li><p>汇编没有变量的概念，只有寄存器</p></li>
<li><p>不同的硬件可能寄存器数量/位数不同</p></li>
<li><p>可以读，写；耗电量相较于Memory很少；性能快</p></li>
<li><p>寄存器是在CPU上的直接结构</p></li>
<li><p>既然寄存器这么快，为什么不直接用寄存器替代内存，外存等</p>
<ul>
<li>💰</li>
<li>针对存储设计的分层体系架构，越底层的存储介质容量越大，速度越慢</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698300667917-230a25d1-8909-4a9b-a9fe-3ec458dc0922.png#averageHue=%23acbea0&amp;clientId=u9c815c94-2149-4&amp;from=paste&amp;height=484&amp;id=u26fd0244&amp;originHeight=968&amp;originWidth=1608&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=581561&amp;status=done&amp;style=none&amp;taskId=uadde4365-8879-4a17-8b20-c3ed30b9fd9&amp;title=&amp;width=804" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ol type="1">
<li><strong>寄存器表示</strong>：在RISC-V中，寄存器可以用‘x’加上一个数字（如x0、x1...x31）来表示，或者用特定的名字来表示。
(RISCV一共有32个寄存器，寄存器并不是越多越好，需要在存储量以及读取速度做权衡)</li>
<li><strong>寄存器种类</strong>：</li>
</ol>
<ul>
<li><strong>程序员变量寄存器</strong>：这类寄存器用于保存程序中的变量。
<ul>
<li>s0-s1 对应 x8-x9</li>
<li>s2-s11 对应 x18-x27</li>
</ul></li>
<li><strong>临时变量寄存器</strong>：这类寄存器用于暂时保存数据。
<ul>
<li>t0-t2 对应 x5-x7</li>
<li>t3-t6 对应 x28-x31</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li><strong>寄存器类型</strong>：RISC-V中的寄存器没有类型（与C语言的概念相反）。执行的操作决定了如何处理寄存器的内容。</li>
</ol>
<p>在RISC-V架构中，x0-x7的寄存器有特定的用途和命名：</p>
<ul>
<li><strong>x0</strong>:
常被称为<code>zero</code>寄存器。它是一个硬编码的寄存器，总是返回0。无论你尝试写入什么值，它都会保持为0。</li>
<li><strong>x1</strong>:
通常被称为<code>ra</code>，即返回地址寄存器。它用于保存函数返回地址。</li>
<li><strong>x2</strong>:
被称为<code>sp</code>，即堆栈指针寄存器。它指向当前堆栈的顶部。</li>
<li><strong>x3</strong>:
被称为<code>gp</code>，即全局指针寄存器。它通常用于指向全局变量。</li>
<li><strong>x4</strong>:
被称为<code>tp</code>，即线程指针寄存器。它用于指向线程相关的数据。</li>
<li><strong>x5-x7</strong>:
这些是<code>t0-t2</code>临时寄存器，主要用于编译器的中间操作。</li>
</ul>
<h2 id="assembly-code">Assembly code</h2>
<ul>
<li><code>opt</code> <code>dst</code>, <code>src1</code>,
<code>src2</code></li>
<li>c中的单行代码可能在<code>RSIC-V</code>中分解为多个不同的指令</li>
</ul>
<h3 id="basic-arithmetic-instructions">Basic Arithmetic
Instructions</h3>
<ul>
<li><p>例如c语言中的 <code>a = b + c</code> | <code>a = b - c</code> |
<code>a =  (b+c)  - (d+e)</code></p></li>
<li><p><code>add s1, s2, s3</code> | <code>sub s1, s2, s3</code> |
<code>add t1, s2, s3</code> <code>add t2, s4, s5</code>
<code>sub s1, t1, t2</code></p></li>
<li><p>有时候改变指令的顺序有助于提高执行效率，但某些指令是不可以随便交换的</p></li>
<li><p>立即数操作（思考为什么没有subi操作）</p>
<ul>
<li><code>addi s1,s2,2</code> | <code>a = b + 2</code>;</li>
<li><code>addi s3,s3,1</code> | <code>c++</code>;</li>
<li>立即数减法可以通过组合立即数加法和负的立即数，这减少了指令集的复杂性</li>
</ul></li>
<li><p>从内存中存或者读数据</p>
<ul>
<li><code>memop reg, off(bAddr)</code> （内存操作符
<code>目标寄存器/操作寄存器</code>
off是一个以<code>Byte</code>为单位的偏移量，<code>bAddr</code>一个存储内存基地址的寄存器</li>
<li><strong>A register holds a word of raw data (no type)</strong>:
寄存器存储的是原始数据，没有数据类型的区分。换句话说，不像高级编程语言中的变量，它们可能有一个指定的数据类型（如整数、浮点数或字符），寄存器仅仅存储一串二进制数据，而不关心这些数据代表什么类型。</li>
<li><strong>Make sure to use a register (and offset) that point to a
valid memory address</strong>:
当你使用寄存器来表示一个内存地址时（例如在数据传输指令中），你需要确保该寄存器中的值（以及与之相关的任何偏移量）确实指向一个有效的内存位置。这是为了防止尝试访问无效或受保护的内存区域，这样可能会导致程序崩溃或其他不可预测的行为。</li>
<li>从off的使用方法可以看到，汇编不提供类似c语言<code>p++</code>自动偏移对应类型的操作，数据的大小需要自己考虑。</li>
<li>a[10] = a[3] + b -&gt; <code>lw t1,12(s1)</code>
<code>addi t1,t1,s2</code> <code>sw t1, 40(s1)</code></li>
</ul></li>
<li><p>怎么在内存中用汇编初始化值 （造了一个数组）
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.data<br>    <span class="hljs-comment">// 这里创建了三个32位的整数，然而我们不知道它的实际地址</span><br>source:<br>    	.word <span class="hljs-number">3</span><br>        .word <span class="hljs-number">1</span><br>        .word <span class="hljs-number">4</span><br>.text<br>main:<br>    	la t1,source  <span class="hljs-comment">// 所以先把source的地址拿到 t1寄存器</span><br>        lw t2,<span class="hljs-number">0</span>(t1)   <span class="hljs-comment">// 然后把值（a[0]）加载到t2寄存器里</span><br>        lw t3,<span class="hljs-number">4</span>(t1)   <span class="hljs-comment">// 然后把值 (a[1]) 加载到t3寄存器里</span><br></code></pre></td></tr></table></figure></p></li>
<li><p>字（32位），字节（8位），半字（16位），我们讨论往往用<code>1Byte</code>来讨论内存</p></li>
<li><p>RISC-V的位拓展有0填充以及高位符号位填充，有些指令可能理论上进行了位拓展，例如<code>lui</code>指令是"Load
Upper
Immediate"的缩写，它用于将一个20位的立即数值加载到一个寄存器的上20位，同时将其下12位清零，这个指令前后操作数实质发生了位拓展，但是因为没有多余的位进行拓展，所以实际没有进行位拓展。而<code>auipc</code>是把一个20bit位的数加载到<code>pc</code>中，至于具体的位数要看<code>RISC-V</code>的变种</p></li>
<li><p><code>lb/sb</code> <code>一切内容都以二进制的形式表示</code></p>
<ul>
<li><code>lb s1, 1(s0)</code> 从s0中拿第二个字节
，通过<code>符号</code>位拓展存储到s1中</li>
<li><code>sb s1, 2(s0)</code> 把s1的最低位存到s0中的第三个字节</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698395799047-57baf1ee-1977-4862-be2e-4263d47c3c69.png#averageHue=%23f1eeee&amp;clientId=u1a327c33-0944-4&amp;from=paste&amp;height=388&amp;id=u327c85d5&amp;originHeight=776&amp;originWidth=1350&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=118053&amp;status=done&amp;style=none&amp;taskId=uf80c0b39-8361-429f-b294-b86a5c65e41&amp;title=&amp;width=675" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><code>lh/sh</code> 和
<code>lb</code>以及<code>sb</code>一样，不过操作的是半字也就是16位比特位</li>
<li><code>lhu</code>和<code>lbu</code>用于无符号数的读取，但是它们只执行0拓展</li>
</ul>
<h3 id="control-flow">control flow</h3>
<ul>
<li>c有代码块的概念，但RISC-V没有，但是具有label的概念，例如<code>main:</code></li>
<li>label是可跳转的</li>
<li><code>beq reg1, reg2, label</code> Branch If Equal
，如果<code>reg1 == reg2</code> [寄存器内的值相等]
那么跳转到label，否则执行下一条指令</li>
<li><code>bne reg1, reg2, label</code> Branch If Not Equal ， 如果
<code>reg1 != reg2</code> [寄存器内的值相同]
那么跳转到label，否则执行下一条指令</li>
<li><code>j label</code> 无条件跳转到下一条指令</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698470317227-651aab49-0064-40aa-b642-c0109394e8c7.png#averageHue=%23f6f5f5&amp;clientId=u533c3b9a-904a-4&amp;from=paste&amp;height=368&amp;id=u70be6998&amp;originHeight=736&amp;originWidth=1108&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=109764&amp;status=done&amp;style=none&amp;taskId=uf0b096de-8037-43a9-b084-78ae0fdffd5&amp;title=&amp;width=554" srcset="/img/loading.gif" lazyload
alt="截屏2023-10-28 13.16.37.png" />
<figcaption aria-hidden="true">截屏2023-10-28 13.16.37.png</figcaption>
</figure>
<ul>
<li><code>blt reg1,reg2, label</code> Branch Less Than, means &lt;, if
the value in reg1 is less than reg2, then go to label</li>
<li><code>bge reg1,reg2, label</code> Branch Greater Than or Equal &gt;=
<ul>
<li>为什么不设计一个&gt; 或者 &lt;= 呢？
这完全可以通过交换参数来实现。</li>
</ul></li>
<li>loop in RISC-V 有许多实现方法，关键就是分支控制</li>
<li>PC
<ol type="1">
<li><strong>Program Counter (PC)</strong>: PC 是一个寄存器，它存储着 CPU
下一步要执行的指令的地址。在顺序执行的程序中，每执行一条指令，PC
通常会自动加上该指令的长度，从而指向下一条指令。</li>
<li><strong>Branches</strong>: Branches
是指控制流指令，如条件分支和无条件跳转。当满足某个条件时，它们会修改 PC
的值，使其跳转到程序的另一个位置，而不是顺序地执行下一条指令。</li>
</ol>
<ul>
<li>当 CPU
执行到一个分支指令时，它会根据该指令和给定的条件来决定是否修改 PC
的值。如果决定跳转，则 PC
会被设置为目标地址，这导致程序从新的地址继续执行。如果不跳转，PC
将按常规递增，继续顺序执行。</li>
<li>无条件跳转（如 <code>jmp</code> 或 <code>j</code>
在某些汇编语言中）总是会修改 PC 的值。</li>
<li>条件分支（如 <code>beq</code>、<code>bne</code>
等）则会根据条件判断是否修改 PC。 ### Shifting Instructions <img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698472153887-0b23af7a-a14a-4f74-ba15-fd84fb87e11b.png#averageHue=%23d2d8e3&amp;clientId=u533c3b9a-904a-4&amp;from=paste&amp;height=332&amp;id=uee06501a&amp;originHeight=664&amp;originWidth=1084&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=111011&amp;status=done&amp;style=none&amp;taskId=ueb1154a8-bbfb-43ae-b819-0fe60dd7924&amp;title=&amp;width=542" srcset="/img/loading.gif" lazyload
alt="image.png" /></li>
</ul></li>
<li>没有算数左移是因为算数左移和逻辑左移是一样的，低位都会被填充为0</li>
<li>对于立即数而言，值只能在0-31之间（32位指令）</li>
<li>对于寄存器中的值而言，只有低5位的值会被读取</li>
</ul>
<h3 id="other-instructions">other Instructions</h3>
<ul>
<li><code>mul dst, src1,src2</code> 计算<code>src1</code> *
<code>src2</code> ,把<code>低32位</code>存到<code>dst</code>中</li>
<li><code>mulh dst, src1, src2</code> 把<code>高32位</code>
存储到<code>dst</code>中</li>
<li><code>div dst, src1, src2</code> 计算<code>src1 / src2</code>
,把商存到<code>dst</code>中</li>
<li><code>rem dst, src1, src2</code> 计算<code>src1 / src2</code> ,
把余树存储到 <code>dst</code>中</li>
<li><code>and dst, src1, src2</code>
计算<code>src1 &amp; src2</code>，把结果存到<code>dst</code>中</li>
<li><code>andi dst, src1, imm</code>
计算<code>src1 &amp; imm</code>，把结果存到<code>dst</code>中</li>
<li><code>or dst, src1, src2</code>
计算<code>src1 | src2</code>，把结果存到<code>dst</code>中</li>
<li><code>ori dst, src1, imm</code>
计算<code>src1 | imm</code>，把结果存到<code>dst</code>中</li>
<li><code>xor dst, src1, src2</code>
计算<code>src1 ^ src2</code>，把结果存到<code>dst</code>中</li>
<li><code>xori dst, src1, imm</code>
计算<code>src1 ^ imm</code>，把结果存到<code>dst</code>中</li>
<li><code>slt dst, reg1,reg2</code> 如果<code>reg1&lt;reg2</code>,
则<code>dst</code>为<code>1</code>否则为<code>0</code></li>
<li><code>slti dst, reg1, imm</code> 如果<code>reg1&lt;imm</code>,
则<code>dst</code>为<code>1</code>否则为<code>0</code></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698475390305-83c88822-345c-4a21-99f5-ff9f06d8484d.png#averageHue=%23f5f5f5&amp;clientId=u533c3b9a-904a-4&amp;from=paste&amp;height=375&amp;id=u808b6a42&amp;originHeight=750&amp;originWidth=932&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=93615&amp;status=done&amp;style=none&amp;taskId=u7080248c-11da-4ee1-b570-8adb083d8e9&amp;title=&amp;width=466" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="interact-with-os">Interact with os</h3>
<ul>
<li>基于<code>a0</code>寄存器与<code>os</code>交互</li>
<li><a
target="_blank" rel="noopener" href="https://github.com/ThaumicMekanism/venus/wiki/Environmental-Calls">https://github.com/ThaumicMekanism/venus/wiki/Environmental-Calls</a></li>
</ul>
<h1 id="lecture-7-more-about-assembly">Lecture 7 More about
assembly</h1>
<h2 id="pseudo-instructions">Pseudo-Instructions</h2>
<ul>
<li>不同于高级语言例如c，汇编语言一定是针对于具体硬件而运行的</li>
<li>我们有时候使用的指令并不是“真正的指令”，而是为了方便记忆而做了一层抽象
<ul>
<li><code>mv dst, reg1</code> -&gt; <code>addi dst, reg1, 0</code>
移动寄存器中的一个值到另一个寄存器中</li>
<li><code>li dst, imm</code> -&gt; <code>addi, lui</code>
加载一个立即数到寄存器</li>
<li><code>la dst, label</code> -&gt; <code>auipc dst</code>
将指定标签的地址加载到寄存器</li>
<li><code>nop</code> -&gt; <code>addi x0, x0, 0</code>
不执行任何操作</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698562073854-35aa28fd-0d1c-43e1-ad41-03a525287c45.png#averageHue=%23f7f4f3&amp;clientId=u533c3b9a-904a-4&amp;from=paste&amp;height=170&amp;id=ub0b4d761&amp;originHeight=340&amp;originWidth=1570&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=58311&amp;status=done&amp;style=none&amp;taskId=u31e1c49f-e200-41e4-b6c0-6311b4185ef&amp;title=&amp;width=785" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>如何将这段代码转化为汇编语言呢？
<ul>
<li>明确写下每一步</li>
<li>一步一步的进行翻译</li>
<li>进行指令优化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//   define *p, define *q       --&gt;  p-&gt;  s0,  q -&gt; s1    </span><br><span class="hljs-comment">//   loop                       --&gt;  Loop:</span><br><span class="hljs-comment">//   take *p                    --&gt;  lb t0,0(s0)</span><br><span class="hljs-comment">//   set to *q                  --&gt;  sb t0,0(s1)</span><br><span class="hljs-comment">//   p++                        --&gt;  addi s0,s0,1</span><br><span class="hljs-comment">//   q++                        --&gt;  addi s1,s1,1</span><br><span class="hljs-comment">//   if *q == &#x27;\0&#x27; else to loop --&gt;  beq s0,x0,next</span><br><span class="hljs-comment">//								--&gt;  j Loop</span><br><span class="hljs-comment">//   go to next 				--&gt;  next:</span><br></code></pre></td></tr></table></figure></li>
</ul></li>
<li>我们的next出现了冗余，可以用更少的指令来描述</li>
</ul>
<h2 id="function-calling">function calling</h2>
<ul>
<li>函数调用通用流程
<ul>
<li>将被调用函数需要的变量存储到可以被访问到的地方（寄存器，内存）</li>
<li>将控制权转移给被调用的函数</li>
<li>被调用函数读取一些需要的资源</li>
<li>被调用函数执行自己的任务</li>
<li>被调用函数返回值，然后清空资源</li>
<li>控制元返回到调用者身上</li>
</ul></li>
<li>传入的参数存在哪里，返回值存在哪里
<ul>
<li>优先使用寄存器 <code>a0-a7</code> (传参)
，<code>a0-a1</code>(返回值）</li>
<li>如果空间不够用，那么用栈空间</li>
</ul></li>
<li>函数之间的控制权是如何转移的
<ul>
<li><code>Jump (j)</code>：无条件跳转到标签处。这是一个伪指令，实际上是
<code>jal x0 label</code> ,<code>x0</code>不会被修改
<ul>
<li>示例：<code>j label1</code></li>
</ul></li>
<li><code>Jump and Link (jal)</code>：用于调用函数。它将当前指令的地址保存到返回地址寄存器，并跳转到指定标签。
<ul>
<li>示例：<code>jal dst label</code></li>
</ul></li>
<li><code>Jump and Link Register (jalr)</code>：与<code>jal</code>相似，但允许更灵活的跳转地址，地址是从寄存器和立即数计算得到的。
<ul>
<li>示例：<code>jalr dst src imm</code>
将下一条指令的地址存到<code>dst</code>中（通常是<code>ra</code>），跳转到<code>src + imm</code>的地址</li>
</ul></li>
<li><code>Jump Register (jr)</code>：无条件跳转到源寄存器指定的地址。通常用于从函数返回。
<ul>
<li>示例：<code>jr src</code>
也是一个伪指令，<code>jalr x0, rs1, 0</code></li>
</ul></li>
<li><code>ra</code>：返回地址寄存器。用于保存从哪个地址调用了函数，以便后续可以返回。</li>
<li><code>sp</code>：一个指向栈顶的指针</li>
</ul></li>
<li>函数调用者与被调用者该怎么保证寄存器的安全使用 -&gt; 基于简单的约定
<ul>
<li>Saved Registers (Callee Saved)
<ul>
<li><code>s0-s11</code></li>
<li><code>sp</code></li>
<li>这些寄存器在被调用者返回前（callee），必须把Saved
Registers恢复到调用之前</li>
</ul></li>
<li>Volatile Registers （if needed Caller Saved）
<ul>
<li><code>t0-t6</code> 局部变量用</li>
<li><code>a0-a7</code> 返回值及传入参数用</li>
<li><code>ra</code> 返回地址寄存器</li>
<li><figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698652070050-839f29d4-7f2e-4351-bcff-c448fcee9faf.png#averageHue=%23dfdedb&amp;clientId=u6d5171cb-c4b2-4&amp;from=paste&amp;height=379&amp;id=u7cec9d43&amp;originHeight=758&amp;originWidth=1170&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=272076&amp;status=done&amp;style=none&amp;taskId=u41a4dc45-89eb-4ffa-88ac-c86c0ec6837&amp;title=&amp;width=585" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
</ul></li>
</ul></li>
<li>例子</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698653639109-8f96d7bc-01fc-4d91-935a-b72e87da92f6.png#averageHue=%23f3f2f2&amp;clientId=u6d5171cb-c4b2-4&amp;from=paste&amp;height=380&amp;id=ud4fefbb2&amp;originHeight=760&amp;originWidth=1334&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=138085&amp;status=done&amp;style=none&amp;taskId=ua9b22fd0-90b4-4c91-bb09-16ba4c8a39f&amp;title=&amp;width=667" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h1 id="lecture-8-risc-v-format">Lecture 8 RISC-V format</h1>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698730134374-89704955-8d29-44c5-b9b9-af80d35e802f.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698730134374-89704955-8d29-44c5-b9b9-af80d35e802f.pdf%22%2C%22name%22%3A%22lec08.pdf%22%2C%22size%22%3A14352933%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u47969a60-abb8-4c09-983b-8b4e6ad5dec%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u6001ded4%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec08.pdf</a></p>
<ul>
<li>最开始的ENIAC能够在2ms内计算两个十位数的乘法，但是需要两到三天设置程序</li>
<li>为什么不用bit来表示指令呢？所有要执行的指令全部加载到内存中，这是现代计算的核心思想。
<ul>
<li>c语言的指针指向的是内存中的数据</li>
<li>PC指向的是内存中的代码、指令</li>
</ul></li>
<li>随着硬件的发展，我们既不想抛弃以前的指令集，又加入了新的指令集，这导致了指令集的膨胀
<ul>
<li>典型的例子就是x86</li>
<li>汇编器替我们把汇编代码转译为机器语言</li>
</ul></li>
<li>我们有6种不同的划分方法，将一个32位的指令划分为不同指令格式，这是对<code>硬件简化设计</code>以及<code>复杂指令设计</code>的妥协
<ul>
<li><code>R-Format</code>
实现所有需要三个寄存器的算数与逻辑操作指令</li>
<li><code>I-Format</code> 实现带有立即数的运算指令和加载指令</li>
<li><code>S-Format</code> 实现将寄存器的值写入到内存中</li>
<li><code>U-Format</code>
和<code>I-Format</code>类似，但是立即数是高20位</li>
<li><code>SB-Format</code> 分支指令设计</li>
<li><code>Uj-Format</code> 直接更改程序执行地址</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698731496105-324b1ae0-ac9b-4431-92ab-58e5fdc5149d.png#averageHue=%23e0e0e0&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=304&amp;id=u8d0bdc22&amp;originHeight=608&amp;originWidth=1662&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=223957&amp;status=done&amp;style=none&amp;taskId=u43ea0b8b-98e2-44df-8c8a-5deee5a169f&amp;title=&amp;width=831" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><code>funct7</code>，<code>funct3</code>
组合起来用于指定具体的操作</li>
<li><code>rs1</code>，<code>rs2</code>
则存储了操作数，<code>rd</code>则标注了写入结果的寄存器</li>
<li><code>imm</code>是立即数，可以看到排布规则还是很奇怪的，甚至还有缩位，一切都是为了硬件</li>
<li><code>opcode</code>则告诉我们某条指令到底属于哪一类</li>
</ul>
<h2 id="r-format">R-Format</h2>
<ul>
<li>不同的filed长度不同，但都是<del>无符号数</del>，似乎并不是，imm是以补码的形式存储的</li>
<li>我们有<span class="math inline">\(2^3 * 2^7 =
2^{10}\)</span>个不同的<code>R-Format</code>指令</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698732005283-36654ee8-af2b-4dca-ac25-26ec9e133289.png#averageHue=%23dcdcdc&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=198&amp;id=u9af2c0d4&amp;originHeight=396&amp;originWidth=1476&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=47188&amp;status=done&amp;style=none&amp;taskId=u5844de16-cfd4-4335-bf57-32f5ecbed75&amp;title=&amp;width=738" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>所有<code>R-Format</code>指令的操作码都是一致的</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698732488592-4ca0a33f-95e1-482c-b8ce-01b0a5110a11.png#averageHue=%23f1f0f0&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=336&amp;id=ucb8f55c2&amp;originHeight=672&amp;originWidth=1666&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=true&amp;size=589761&amp;status=done&amp;style=none&amp;taskId=u9e20d5ac-e26e-4053-9279-6c52d2d34f8&amp;title=funct7%EF%BC%8Crs2%EF%BC%8Crs1%EF%BC%8Cfunct3%EF%BC%8Crd%EF%BC%8Copcode&amp;width=833" srcset="/img/loading.gif" lazyload
title="funct7，rs2，rs1，funct3，rd，opcode"
alt="funct7，rs2，rs1，funct3，rd，opcode" />
<figcaption
aria-hidden="true">funct7，rs2，rs1，funct3，rd，opcode</figcaption>
</figure>
<h2 id="i-format">I-Format</h2>
<ul>
<li>当存在立即数时，意味着我们的指令中必须包含一个立即数，而不是寄存器的地址，而对于我们已经知道的<code>R-Format</code>来说，用5位来表示一个立即数可用的范围太小了</li>
<li>RISC-V的设计理念希望我们只有一条指令，但现在我们需要违背这个理念，需要一个不同的格式</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698733022692-72c619ae-3c35-4672-ad82-e183d5ddf3a8.png#averageHue=%23e2e2e2&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=214&amp;id=u67d24560&amp;originHeight=428&amp;originWidth=1516&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=45700&amp;status=done&amp;style=none&amp;taskId=ua0ad3885-7c58-4c5d-9293-864777a2c92&amp;title=&amp;width=758" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><code>func7</code>和<code>rs2</code>被用于表示一个立即数，其他的filed和<code>R-Format</code>保持一致</li>
<li><code>imm</code>每次在进行算数运算时都会由12位数拓展为32位</li>
<li><code>imm</code>的范围是<span class="math inline">\([-2^{11},
+2^{11}-1]\)</span></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698733625798-ad9befea-32f4-4ad5-a7dc-2db803658933.png#averageHue=%23f2f1f1&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=528&amp;id=u031f7904&amp;originHeight=1056&amp;originWidth=1664&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=624028&amp;status=done&amp;style=none&amp;taskId=uda12b564-9fbf-4d9e-a498-6ca7519452b&amp;title=&amp;width=832" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><p>对于特殊的移位操作，只使用低五位代表移动的位数</p></li>
<li><p>用<code>1</code>和<code>0</code>区别算数右移和逻辑右移</p></li>
<li><p>Load - Instructions 也是I-Format类型的指令</p></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698734235888-8b73801b-94d0-4615-baa7-a7110a786b39.png#averageHue=%23d5d5d5&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=149&amp;id=u7ef3c8ae&amp;originHeight=298&amp;originWidth=1494&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=42074&amp;status=done&amp;style=none&amp;taskId=u19c25f25-a669-407d-bb85-94d83e2fc2b&amp;title=&amp;width=747" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>从<code>rs1</code>中取出内存中的基地址，与偏移量相加后取出值放到<code>dst</code>中</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698734461932-9e1df626-6bc4-4a8f-b0e6-03030d5d4d7c.png#averageHue=%23e7e7e7&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=434&amp;id=ub17b1893&amp;originHeight=868&amp;originWidth=1620&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=455246&amp;status=done&amp;style=none&amp;taskId=u1d2c4b1c-81cf-4512-bd9e-51a8029ad75&amp;title=&amp;width=810" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>jalr也是I类型的指令</li>
<li>需要注意的就是，这里的偏移量单位就是字节，不需要乘以2字节进行对齐，跳转粒度是字节为单位的</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698905507228-1dd5033b-7ad5-49fc-ba88-3654f8f68112.png#averageHue=%23ecebeb&amp;clientId=u9d81647c-e583-4&amp;from=paste&amp;height=495&amp;id=ud4019649&amp;originHeight=990&amp;originWidth=1680&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=399286&amp;status=done&amp;style=none&amp;taskId=ue0df2649-9404-4870-abef-b07a039122d&amp;title=&amp;width=840" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="s-format">S-Format</h2>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698734963547-61540699-83e3-45e7-ac81-b4316d19d0ac.png#averageHue=%23d3d3d3&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=80&amp;id=u24667f88&amp;originHeight=160&amp;originWidth=1484&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=25763&amp;status=done&amp;style=none&amp;taskId=u8174b156-b78a-432c-8f28-8871296d283&amp;title=&amp;width=742" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>去掉目标寄存器，更改为立即数的低5位</li>
<li>功能就是在<code>rs1</code>地址加上偏移量的位置写入<code>rs2</code>的内容</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698735048416-6dbfa85e-9751-4b88-9c88-fefd83b041fe.png#averageHue=%23f0efef&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=102&amp;id=uaca08fc5&amp;originHeight=204&amp;originWidth=1598&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=216220&amp;status=done&amp;style=none&amp;taskId=uceb46ecf-b39f-42a6-b083-37444fdfed8&amp;title=&amp;width=799" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="sb-format">SB-Format</h2>
<ul>
<li>一般用于循环或者流程控制，循环一般会小于50条指令</li>
<li>分支距离 从当前分支指令到目标位置的距离 一般用字节或者指令描述
<ul>
<li>这个大小收到代码段大小的限制（代码段本身的大小，不可以跳到代码段之外的位置）</li>
<li><code>PC</code>存储了当前指令的地址，具体跳转的位置由当前<code>PC</code>内的地址在<span
class="math inline">\([-2^{11},+2^{11]}\)</span>对齐的位置进行跳转（不对齐会引发性能问题），并且跳转的距离必须是4Byte的整数倍
<ul>
<li>RISC-V使用32位地址：这意味着它使用32位来表示内存地址。</li>
<li>内存是按字节寻址的：即每个地址对应一个字节。</li>
<li>32位指令是“word-aligned”：这意味着每个32位指令的地址都是4的倍数（因为一个字是4个字节）。例如，0x1000,
0x1004, 0x1008 等都是有效的指令地址，而0x1001, 0x1002, 0x1003
等则不是。</li>
<li>程序计数器（PC）始终指向一个指令：这是计算机硬件设计的基本原则，确保程序能够顺序地执行指令。</li>
<li>RISC-V的压缩指令：如果系统支持RISC-V的压缩指令（这些指令只有16位长），那么所有指令都是“half
word-aligned”，即指令的地址是2的倍数。</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698740799992-a3592756-99f0-4154-b14f-7d8c63dbeab4.png#averageHue=%23edebeb&amp;clientId=ude36ddce-19a5-4&amp;from=paste&amp;height=205&amp;id=uf622e6ec&amp;originHeight=410&amp;originWidth=1110&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=53332&amp;status=done&amp;style=none&amp;taskId=u4a2fed25-25d7-4f0e-995b-5c9d598479f&amp;title=&amp;width=555" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>ISA 指令集的抽象体系结构
为同一ISA编写的程序可以在不同的ISA的实现平台上运行</li>
<li>拓展的RISC-V支持16位的压缩指令，为了对齐兼容，因此分支指令的偏移量以半字为单位，无论你有没有用到16位压缩指令</li>
<li>从当前指令最大只能实现<span
class="math inline">\(2^{10}\)</span>条32位指令的跳转，偏移量的单位是半字（16位bit，2Byte）
<ul>
<li>为什么不用一个字呢？ （兼容16位，以及可以缩减所占用空间的大小）</li>
<li>Imm实际表示的是13位的偏移，实际的偏移量既imm所表示的立即数<em>2（或者向最低位补一个零）</em>2Byte
<ul>
<li>为什么可以这样？因为我们的偏移量的最后一位总会是零（RISC-V是4字节或2字节对齐的指令）</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698901080971-3f51d5a7-2dd2-4cd0-af44-284844389697.png#averageHue=%23dcdcdc&amp;clientId=u9d81647c-e583-4&amp;from=paste&amp;height=89&amp;id=uc98eb373&amp;originHeight=178&amp;originWidth=1318&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=27094&amp;status=done&amp;style=none&amp;taskId=u5565e66d-3a5d-4ad2-967d-7a7bdfcde31&amp;title=&amp;width=659" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><code>filed1</code>的最高位存储偏移量的第12位，剩余的位存第10-5位</li>
<li><code>filed5</code>的前4位存储偏移量的1-4位，最后一位存第11位</li>
<li>这十分地别扭，但一切都是基于硬件的考量</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698901518070-46951d19-2687-4301-984c-4db668bd251b.png#averageHue=%23d6d3cd&amp;clientId=u9d81647c-e583-4&amp;from=paste&amp;height=140&amp;id=udef4f31f&amp;originHeight=280&amp;originWidth=1366&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=352410&amp;status=done&amp;style=none&amp;taskId=u5f94b002-4d7a-407c-a937-75b8ac2cc9d&amp;title=&amp;width=683" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>SB指令实现跳转是基于PC寄存器的相对寻址方式
<ul>
<li>整个代码区的移动不会导致立即数的改变（部分代码会）</li>
<li>当我们要跳转的指令范围大于了<span
class="math inline">\(2^{10}\)</span>条32位的指令，那么将会使用J指令进行跳转，J指令具有更大的跳转范围</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698902363917-1af982b9-78e5-46de-b14a-335449573e91.png#averageHue=%23f3f3f3&amp;clientId=u9d81647c-e583-4&amp;from=paste&amp;height=86&amp;id=ua396d7e2&amp;originHeight=172&amp;originWidth=1406&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=58600&amp;status=done&amp;style=none&amp;taskId=ua2a8f81c-222f-424b-9765-1e0da6f8a9a&amp;title=&amp;width=703" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="u-format">U-Format</h2>
<ul>
<li>I-Format指令只给了我们12位的立即数，假如我们需要用到更大的立即数，那么就需要使用到U-Format指令</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698902740750-9e6e9c8a-5af0-4f38-ad6e-3e5dff5f44d3.png#averageHue=%23e7e7e7&amp;clientId=u9d81647c-e583-4&amp;from=paste&amp;height=142&amp;id=u9b8db4e0&amp;originHeight=284&amp;originWidth=1278&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=34144&amp;status=done&amp;style=none&amp;taskId=u7584e02f-42c2-4c7f-830d-4cefaae10bc&amp;title=&amp;width=639" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>加载32位立即数的高20位到程序寄存器/PC中，剩余的位置补0</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698903497326-de0e6f46-193d-4a96-98cd-abd78eb3bef4.png#averageHue=%23e9e9e9&amp;clientId=u9d81647c-e583-4&amp;from=paste&amp;height=138&amp;id=u87fa6781&amp;originHeight=276&amp;originWidth=1242&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=43792&amp;status=done&amp;style=none&amp;taskId=ub900998c-4a63-4c55-9a6e-75a7bb327b9&amp;title=&amp;width=621" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>加载这个32位的立即数出现了问题，原因是<code>addi</code>对要加载的立即数进行了符号拓展，这导致实际上我们计算的是<code>0xDEADB000</code>+<code>0xFFFFFEEF</code></li>
<li>我们只需要在处理需要符号拓展的<code>addi</code>对<code>0xDEADB</code>偏移一次就好，即得到<code>0xDEADC</code>
+ <code>0xFFFFFEEF</code> = <code>0xDEADBEEF</code></li>
<li>AUIPC是把立即数的高位和PC相加并存到dst寄存器中</li>
</ul>
<h2 id="uj-format">UJ-Format</h2>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698904542497-62389d48-4669-41f4-991b-78926f2d1f6b.png#averageHue=%23e6e6e6&amp;clientId=u9d81647c-e583-4&amp;from=paste&amp;height=173&amp;id=uad26ebff&amp;originHeight=346&amp;originWidth=1596&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=93781&amp;status=done&amp;style=none&amp;taskId=u6970e327-4523-4b8d-98e9-0e2ec5cda50&amp;title=&amp;width=798" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>把PC+4 存到dst里</li>
<li>令PC = PC + offset</li>
<li>最大可跳过<span class="math inline">\(2^{19}\)</span>个
16位指令，即<span class="math inline">\(2^{18}\)</span>个32位的指令</li>
<li><code>J</code>是伪指令，还是基于<code>JAL</code>，利用了<code>x0</code>寄存器不会被修改的特点</li>
<li>imm的编码还是十分混乱，再次强调，这是为了降低硬件成本</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698905695577-a7bae46e-7124-4c45-ab9e-7f01f8e189f0.png#averageHue=%23f1f1f1&amp;clientId=u9d81647c-e583-4&amp;from=paste&amp;height=305&amp;id=ub6080920&amp;originHeight=610&amp;originWidth=1802&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=332071&amp;status=done&amp;style=none&amp;taskId=u872acf9c-a42d-4809-9256-9ae00804e4b&amp;title=&amp;width=901" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>看起来就很硬件友好，例如opcode的位置，rd，rs的位置都是对齐的</p>
<h1 id="lecture-9-call">Lecture 9 CALL</h1>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698909449654-f25c0253-547f-4ac1-884a-7f85cc0bc54e.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698909449654-f25c0253-547f-4ac1-884a-7f85cc0bc54e.pdf%22%2C%22name%22%3A%22lec09-2.pdf%22%2C%22size%22%3A8406067%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ucedb2fc9-46d6-493a-935e-c969e717e2e%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22ub5a4e767%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec09-2.pdf</a></p>
<ul>
<li>Compiler</li>
<li>Assembler</li>
<li>Linker</li>
<li>Loader</li>
</ul>
<h2 id="translation">Translation</h2>
<ul>
<li>当我们编写程序后，有两种方法运行我们编写的运行程序
<ul>
<li>解释 ：边解释边运行 例如python<br />
</li>
<li>翻译： 转换为另一种等价语言来运行 例如c</li>
<li>当具有性能的考量的时候，用translate</li>
<li>解释语言往往性能慢一些 10x，但是代码少 2x</li>
</ul></li>
</ul>
<h2 id="compiler">Compiler</h2>
<ul>
<li>将.c源文件输出为.s汇编文件（可能包含伪指令）
<ul>
<li>预处理，例如宏替换，头文件包含</li>
<li>确定运算符的优先级 a = 3+ 4*2</li>
<li>...非常复杂</li>
<li><a
target="_blank" rel="noopener" href="https://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days">https://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days</a></li>
</ul></li>
</ul>
<h2 id="assembler">Assembler</h2>
<ul>
<li>将.s的汇编文件输出为.o二进制文件
<ul>
<li>读和使用Directives （区分代码段, 文本段，指令等）
<ul>
<li>Directives并不会被转换为机器代码</li>
<li>text:
该指令后的项目被放置在用户文本段中。通常，这是程序的机器代码部分，即实际的指令。</li>
<li>.data:
该指令后的项目被放置在用户数据段中。这是程序中的静态数据，如变量和常量。它存储源文件中数据的二进制表示。</li>
<li>.globl sym:
这声明了一个全局符号，这意味着该符号可以在其他文件中被引用。例如，这可以是一个在一个文件中定义但在其他文件中使用的函数或变量。</li>
<li>.asciiz str:
这将字符串str存储在内存中，并在其后添加一个null终止符。这是一个常用的方法，用于在C语言中表示字符串，因为C语言的字符串是以null字符（值为0的字符）终止的。</li>
<li>.word w1...wn: 这将连续的n个32位的数值存储在连续的内存单元中。</li>
</ul></li>
<li>替换伪指令</li>
<li>转换为机器语言（输出为目标文件）
<ul>
<li>在链接以前，需要解决一个符号引用的问题，例如label的跳转，从实际的内存中加载数据，这些需要精确的32位内存，而我们在汇编阶段是不可能确定的。这也叫做前向引用问题，这个问题可以通过维护一个<code>符号表</code>
和一个<code>重定位表</code>，运行多次<code>Assembler</code>来解决。</li>
<li>目标文件在<code>unix</code>和<code>Linux</code>
平台往往是<code>ELF</code>格式的</li>
<li>对象文件头 (object file
header)：这是目标文件的元信息部分，它提供了文件中其他部分的大小和位置。此头部标识了文件的类型（例如，是否是一个可执行文件，一个目标文件，还是一个共享库）以及其他关于文件的基本属性。</li>
<li>文本段 (text
segment)：这部分包含程序的实际机器代码。当程序运行时，这部分代码会被加载到内存并执行。</li>
<li>数据段 (data
segment)：此部分包含程序的静态数据和全局变量。在程序运行时，它们会被加载到内存中，供程序访问和修改。</li>
<li>重定位表 (relocation
table)：如前所述，重定位表列出了所有需要在连接时或运行时被“处理”或“修复”的代码位置。这是因为在编译时，编译器可能不知道所有外部引用的确切内存地址。</li>
<li>符号表 (symbol
table)：此表包含文件中定义和引用的所有符号（例如函数名和变量名）的列表。它帮助链接器解析外部和内部符号引用，以确保正确的链接。</li>
<li>调试信息 (debugging
information)：对于那些编译时带有调试信息的文件，这部分包含了源代码级别的信息，如变量名、行号等。这使得调试工具（如
gdb）可以在运行时映射机器代码回到其原始的源代码位置。</li>
<li><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698912220821-c1ba5ab6-6c27-41b3-b951-1b0486ecafbe.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698912220821-c1ba5ab6-6c27-41b3-b951-1b0486ecafbe.pdf%22%2C%22name%22%3A%22ELF_Format.pdf%22%2C%22size%22%3A152347%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u19c8bb18-bc03-42de-ae26-29a20f2ad29%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22ue7897fdb%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">ELF_Format.pdf</a></li>
</ul></li>
</ul></li>
</ul>
<h2 id="linker">Linker</h2>
<ul>
<li>把多个汇编产生的二进制文件组合到一个可执行文件里
<ul>
<li>多个有什么好处呢？某个部分改变了，那我们不需要重新编译整个工程</li>
<li>Link
Editor的旧名叫Link，因为它过去大部分的任务就是处理跳转带来的引用被正确的解析为内存地址，以及填充所有绝对地址</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698913540288-a72856d1-7fcc-4e54-8888-f7613b1d1abf.png#averageHue=%23f7f2f2&amp;clientId=u9d81647c-e583-4&amp;from=paste&amp;height=370&amp;id=u1c90ffa1&amp;originHeight=740&amp;originWidth=1072&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=92379&amp;status=done&amp;style=none&amp;taskId=u8bb0c39b-5acd-4cf1-bd73-5b88c02ef25&amp;title=&amp;width=536" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>有三种不同的地址（Adress）</li>
</ul>
<ol type="1">
<li><strong>PC-Relative Addressing (beq, bne, jal)</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：与程序计数器（PC）相关的地址方式。这意味着跳转的目标地址是基于当前指令的地址加上或减去一个偏移量来确定的。</li>
<li><strong>应用场景</strong>：常用于条件分支指令，如<code>beq</code>（等于则跳转）和<code>bne</code>（不等于则跳转），以及无条件跳转<code>jal</code>。</li>
<li><strong>补充</strong>：这种地址方式不会重新定位。这是因为它们的目标地址是动态计算的，不需要预先知道绝对地址。</li>
</ul>
<ol start="2" type="1">
<li><strong>External Function Reference (usually jal)</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：用于引用外部函数。这些函数的确切地址直到链接时才能确定。</li>
<li><strong>应用场景</strong>：在调用库函数或其他模块中的函数时经常使用。</li>
<li><strong>补充</strong>：这种引用在链接时总是需要重新定位，因为在编译时不知道函数的确切地址。</li>
</ul>
<ol start="3" type="1">
<li><strong>Static Data Reference (often auipc and addi)</strong></li>
</ol>
<ul>
<li><p><strong>特点</strong>：用于引用静态数据，如全局变量或常量。</p></li>
<li><p><strong>应用场景</strong>：当程序需要访问静态数据时使用。</p></li>
<li><p><strong>补充</strong>：在RISC-V中，通常使用<code>auipc</code>（将PC值与一个20位的立即数相加并存储结果）和<code>addi</code>（将寄存器值与一个12位的立即数相加）指令组合来构造完整的32位地址。与使用<code>lui</code>（加载上位立即数到寄存器）不同，使用<code>auipc</code>可以确保大块数据可以在链接时重新定位，只要它相对于PC是固定的。</p></li>
<li><p>解决重引用问题</p>
<ul>
<li>Linker假设可执行文件的第一个<code>word</code>以及第一个<code>text</code>段的启始地址为0x10000
(针对RISC-V）
<ul>
<li>Linker知道<code>text</code>段以及<code>word</code>顺序及其各自的大小</li>
<li>Linker可以根据这些计算出每一个<code>label</code>以及每一块<code>data</code>的绝对地址
<ul>
<li>在符号表内寻找符号，找不到就去<code>library file</code></li>
<li>绝对地址只要被确定，那么就转换为机器代码</li>
<li>输出包含<code>text</code>和<code>data</code>以及<code>header</code>的可执行文件</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="loader">Loader</h2>
<ul>
<li>接受可执行文件，并执行
<ul>
<li>从硬盘中读取可执行文件，加载到内存中，然后运行</li>
<li>这是由操作系统提供的功能</li>
</ul></li>
<li>大致有6步
<ul>
<li><strong>文件读取</strong>：加载器首先读取可执行文件的头部，以确定文本和数据段的大小。</li>
<li><strong>地址空间的创建</strong>：为包含文本和数据段的程序创建新的地址空间，此空间还包含一个堆栈段。</li>
<li><strong>指令与数据的复制</strong>：将来自可执行文件的指令和数据复制到新创建的地址空间中。</li>
<li><strong>参数复制</strong>：将传递给程序的参数复制到堆栈上。</li>
<li><strong>机器寄存器的初始化</strong>：
<ul>
<li>清除大多数寄存器。</li>
<li>初始化堆栈指针，使其指向堆栈的第一个可用位置。</li>
</ul></li>
<li><strong>启动程序</strong>：
<ul>
<li>跳转到启动例程，该例程从堆栈复制程序的参数到寄存器，并设置程序计数器（PC）。</li>
<li>如果主程序返回，启动例程将使用退出系统调用来终止程序。</li>
</ul></li>
</ul></li>
<li>Example</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698920541766-702d6ca3-7aaa-4263-a3ad-805b68920eb1.png#averageHue=%23f8f7f6&amp;clientId=u57717f54-4720-4&amp;from=paste&amp;height=350&amp;id=ub1f9f805&amp;originHeight=700&amp;originWidth=1186&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=496702&amp;status=done&amp;style=none&amp;taskId=ud70553cf-2720-4017-ae8e-7777cf294d0&amp;title=&amp;width=593" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>Auipc消失了
<ul>
<li>实际上是被优化为了立即数寻址</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698920766229-63dcbb82-5a0e-4cd4-bfe2-b0881f4065c5.png#averageHue=%23f7f6f5&amp;clientId=u57717f54-4720-4&amp;from=paste&amp;height=752&amp;id=u404e7d3c&amp;originHeight=1504&amp;originWidth=1142&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=700372&amp;status=done&amp;style=none&amp;taskId=uefb4ac3a-4047-4cb5-ad94-cd9768f5e85&amp;title=&amp;width=571" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h1 id="lecture-10-combinational-logic">Lecture 10 Combinational
Logic</h1>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698920964742-d9ac9225-2738-4c1d-b9b2-83b6abd9729e.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698920964742-d9ac9225-2738-4c1d-b9b2-83b6abd9729e.pdf%22%2C%22name%22%3A%22lec10.pdf%22%2C%22size%22%3A8535908%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ub71ff804-0638-40a4-b174-0f77b69acaa%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u7bfa9027%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec10.pdf</a></p>
<ul>
<li>CMOS
一种半导体技术，可以制作与门，非门，或门，寄存器或者更高级的逻辑电路在
CMOS（互补金属氧化物半导体）技术中，N通道和P通道指的是两种不同类型的MOSFET（金属氧化物半导体场效应晶体管）。</li>
</ul>
<ol type="1">
<li><strong>N通道 MOSFET</strong>：</li>
</ol>
<ul>
<li>这种类型的晶体管使用多数载流子（电子）来进行导电。</li>
<li>它是由富含电子的N型半导体材料构成。</li>
<li>在N通道MOSFET中，当在栅极和源极之间施加正向电压时，电子会被吸引到栅极下方形成的“通道”区域，从而允许电流从源极流向漏极。</li>
<li>N通道晶体管的<strong>开启电压通常是正值</strong>，而且它们比P通道MOSFET具有更高的电子迁移率，这意味着它们可以在相同的尺寸下提供更高的电流和速度。</li>
</ul>
<ol start="2" type="1">
<li><strong>P通道 MOSFET</strong>：</li>
</ol>
<ul>
<li>这种类型的晶体管使用少数载流子（空穴）来进行导电。</li>
<li>它是由富含空穴的P型半导体材料构成。</li>
<li>在P通道MOSFET中，当在栅极和源极之间施加负向电压时，空穴会被推动到栅极下方形成的“通道”区域，允许电流从源极流向漏极。</li>
<li>P通道晶体管的<strong>开启电压通常是负值</strong>，它们的电子迁移率低于N通道MOSFET，因此在相同的尺寸下其导电能力稍弱。</li>
</ul>
<p>在 CMOS 电路中，N通道和P通道 MOSFET
通常是成对使用的。这种互补配置允许电路在开关状态切换时消耗非常少的功率，因为只有一个晶体管在导通，而另一个则是截止的。这种设计也允许电路在不同的输入电压水平下有效工作，同时保持低功耗和高速度的特性。</p>
<ul>
<li>非门的实现</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/jpeg/22918222/1699163119731-e3a4cbff-52d8-41ee-8696-ab0d89f30858.jpeg#averageHue=%23f8f6f5&amp;clientId=u33a69565-ba28-4&amp;from=drop&amp;id=u15d3aee2&amp;originHeight=600&amp;originWidth=974&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=173006&amp;status=done&amp;style=none&amp;taskId=u1ca22217-33b2-4ade-bb17-eb8937cfe4b&amp;title=" srcset="/img/loading.gif" lazyload
alt="快捷键.jpeg" />
<figcaption aria-hidden="true">快捷键.jpeg</figcaption>
</figure>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/jpeg/22918222/1699163217132-5c9f2d07-1ee7-4bc8-aaa8-86172dfbbbb4.jpeg#averageHue=%23f7f5f5&amp;clientId=u33a69565-ba28-4&amp;from=drop&amp;id=uc93db546&amp;originHeight=555&amp;originWidth=965&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=174467&amp;status=done&amp;style=none&amp;taskId=u5769ef30-d7e4-4c8c-8584-a94806b6be2&amp;title=" srcset="/img/loading.gif" lazyload
alt="快捷键 2.jpeg" />
<figcaption aria-hidden="true">快捷键 2.jpeg</figcaption>
</figure>
<ul>
<li>NAND 可以构造出AND，OR，NOT</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/jpeg/22918222/1699163952108-d3afbb4d-f6d7-4757-84c3-120e2407897e.jpeg#averageHue=%23f5f5f5&amp;clientId=u33a69565-ba28-4&amp;from=drop&amp;id=u6424fa6f&amp;originHeight=907&amp;originWidth=1111&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=170287&amp;status=done&amp;style=none&amp;taskId=u76780bb4-0a44-43d8-98ab-b035181832e&amp;title=" srcset="/img/loading.gif" lazyload
alt="快捷键.jpeg" />
<figcaption aria-hidden="true">快捷键.jpeg</figcaption>
</figure>
<h2 id="combinational-logical-cl">Combinational Logical （CL）</h2>
<ul>
<li>组合逻辑电路，输出仅仅是输入的函数，不依赖于过去的状态</li>
<li>常见的六种门</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/jpeg/22918222/1699164504062-eb02f838-e52e-4cad-9f64-083e01e6b79e.jpeg#averageHue=%23eeeeee&amp;clientId=u33a69565-ba28-4&amp;from=drop&amp;id=u71d0c3c5&amp;originHeight=913&amp;originWidth=779&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=170098&amp;status=done&amp;style=none&amp;taskId=u334cedb6-bdc1-4493-9ec8-d101d6c6a9a&amp;title=" srcset="/img/loading.gif" lazyload
alt="快捷键.jpeg" />
<figcaption aria-hidden="true">快捷键.jpeg</figcaption>
</figure>
<ul>
<li>我们有四种方法表示逻辑电路</li>
</ul>
<ol type="1">
<li><strong>文本描述（Text
Description）</strong>：用文字描述电路的功能，例如“当输入A和B都为1时，输出为0”。</li>
<li><strong>电路图（Circuit
Diagram）</strong>：通过图形表示法显示如何用晶体管和导线（或逻辑门）来实现电路功能。</li>
<li><strong>真值表（Truth
Table）</strong>：一个表格，列出了输入变量的所有可能组合及其相应的输出结果。</li>
<li><strong>布尔表达式（Boolean
Expression）</strong>：使用布尔代数（例如AND、OR、NOT运算符）描述电路功能的数学表达式。</li>
</ol>
<ul>
<li>我们在面对较多的输入信号时，真值表会非常长，因此我们可以进行一定程度的简化，例如考虑:<span
class="math inline">\((A,B,C,D) \to F \ \to X \ |\ Y\ |\ Z\)</span>
我们可以分别绘制每一个输出针对输入的真值表</li>
</ul>
<h2 id="boolean-algebra">Boolean Algebra</h2>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699165138671-e7d38cda-e6aa-484d-92f9-372548d2be5b.png#averageHue=%23f4f4f4&amp;clientId=u33a69565-ba28-4&amp;from=paste&amp;height=313&amp;id=ud18ab6cc&amp;originHeight=626&amp;originWidth=1496&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=215508&amp;status=done&amp;style=none&amp;taskId=u93b0914a-d8c1-457c-880e-364f1987070&amp;title=&amp;width=748" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>布尔代数的存在允许我们简化电路的设计
<ul>
<li>首先写出真值表</li>
<li>然后转换为布尔代数</li>
<li>化简</li>
<li>设计电路</li>
<li>有必要的话看一下lec10最终的优化方案</li>
</ul></li>
</ul>
<h2 id="sequential-logic-sl">Sequential Logic （SL）</h2>
<ul>
<li>顺序逻辑电路，它们的输出不仅取决于当前的输入，还取决于过去的输入或状态。</li>
</ul>
<ol type="1">
<li><strong>触发器（Flip-Flops）</strong>：基本的存储单元，能够存储单个位（0或1）。触发器的类型有多种，包括D触发器、JK触发器、T触发器等，它们在时钟信号的控制下改变和保持状态。</li>
<li><strong>寄存器（Registers）</strong>：寄存器是由多个触发器组成的，用于存储一个多位的字。寄存器可以按字、字节或其他数据宽度来存储信息，并且通常在时钟边沿同步更新它们的状态。</li>
<li><strong>计数器（Counters）</strong>：一种特殊类型的寄存器，用于顺序计数。计数器可以是二进制的、十进制的或者是其他更复杂的计数格式，通常用于计时、计数和状态机中的状态转换。</li>
<li><strong>存储器（Memory）</strong>：存储器也可以看作是由许多寄存器组成，用于存储大量数据。在更高的层面上，存储器可以是随机存取存储器（RAM）、只读存储器（ROM）或其他类型的存储器。</li>
<li><strong>状态机（State
Machines）</strong>：状态机用于控制电路的行为，可以是有限状态机（FSM），包括Moore型和Mealy型。状态机根据输入和当前状态决定输出以及下一个状态。</li>
</ol>
<h1 id="lecture-11-sequential-digital-logic">Lecture 11 Sequential
Digital Logic</h1>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1699352802656-83cc70fa-bbdf-4118-8bcc-0527882f0e01.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1699352802656-83cc70fa-bbdf-4118-8bcc-0527882f0e01.pdf%22%2C%22name%22%3A%22lec11.pdf%22%2C%22size%22%3A3869042%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u2b7aa1b9-ad28-4a17-bb3b-d71161cbb40%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u730b3dc8%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec11.pdf</a>
## Multiplexer <img
src="https://cdn.nlark.com/yuque/0/2023/jpeg/22918222/1699169473283-2e29fde4-dab0-4a45-8c1f-28dafe045858.jpeg#averageHue=%23f8f8f8&amp;clientId=u33a69565-ba28-4&amp;from=drop&amp;height=250&amp;id=u80661a2b&amp;originHeight=500&amp;originWidth=733&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=39360&amp;status=done&amp;style=none&amp;taskId=u03e38df4-d094-4994-b244-ef3ed70793d&amp;title=&amp;width=367" srcset="/img/loading.gif" lazyload
alt="快捷键 2.jpeg" /></p>
<ul>
<li>多路复用器，实现对N位（通常是固定的）信号的选择输出</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699169660399-b68597c9-73ee-4e3f-9fed-a0a3b708218a.png#averageHue=%23f3f2f2&amp;clientId=u33a69565-ba28-4&amp;from=paste&amp;height=234&amp;id=t5qID&amp;originHeight=936&amp;originWidth=1798&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=270096&amp;status=done&amp;style=none&amp;taskId=u4127b47f-9068-4d84-ad9e-b294f7f7751&amp;title=&amp;width=450" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="sequential-logical-timing">Sequential Logical Timing</h2>
<ul>
<li>累加器
<ul>
<li>寄存器结合RST控制位可以将进行计算之前的垃圾信号清空为零</li>
<li>寄存器结合时钟信号可以控制累加的完成</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/jpeg/22918222/1699170971720-20225754-f564-4f3b-8d62-d19d6bcb4da3.jpeg#averageHue=%23f8f8f8&amp;clientId=u33a69565-ba28-4&amp;from=drop&amp;height=164&amp;id=u3d0abfd7&amp;originHeight=655&amp;originWidth=1326&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=83757&amp;status=done&amp;style=none&amp;taskId=u28aca7e3-fe0a-4821-be70-193a569a8df&amp;title=&amp;width=332" srcset="/img/loading.gif" lazyload
alt="快捷键.jpeg" />
<figcaption aria-hidden="true">快捷键.jpeg</figcaption>
</figure>
<ul>
<li>寄存器</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699171178507-f0c447f4-5413-47df-a0f4-a09fb12f6da9.png#averageHue=%23f6f5f5&amp;clientId=u33a69565-ba28-4&amp;from=paste&amp;height=270&amp;id=uf50c6e42&amp;originHeight=1078&amp;originWidth=1976&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=174510&amp;status=done&amp;style=none&amp;taskId=u20383bc3-c199-4fdd-a24e-ee42170da1b&amp;title=&amp;width=494" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><strong>数据输入</strong>：寄存器可以接收不同位宽的数据输入。位宽是指可以传输的数据的位数。</li>
<li><strong>写使能（Write
Enable）</strong>：这是一个控制信号，当激活时允许数据被写入寄存器。如果没有写使能信号，寄存器的内容将不会改变。</li>
<li><strong>时钟输入（Clock
input）</strong>：这个输入是寄存器的一个同步信号，数据的写入只会在时钟信号的激活边缘（通常是上升沿或下降沿）发生。</li>
<li><strong>复位（Reset）</strong>：复位信号用来将寄存器的内容设置为零。通常在系统初始化或特定条件下需要重置寄存器时使用。</li>
<li><strong>数据输出</strong>：寄存器可以提供不同位宽的数据输出，数据输出将是寄存器内部存储的数据。</li>
</ul>
<h2 id="clock">Clock</h2>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699172850480-827c102c-55ad-4d55-a37d-3b838d0d3120.png#averageHue=%23f4f1f1&amp;clientId=u33a69565-ba28-4&amp;from=paste&amp;height=539&amp;id=u24c6aadd&amp;originHeight=1078&amp;originWidth=1572&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=246049&amp;status=done&amp;style=none&amp;taskId=u9f512aea-29ae-4d39-9276-27b127e5f87&amp;title=&amp;width=786" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>时钟信号：数字电路中非常重要的一个概念，特别是在同步电路设计中，它决定了数据何时被读取和写入。
<ul>
<li>时钟信号往往只和顺序逻辑元素SL相联，CL根据传入的信号即使计算，不依赖于过于的状态。</li>
</ul></li>
<li>时钟周期（Clock
period）：也称为CPU周期时间，是时钟信号的一个完整周期所需要的时间。这通常用来表示一个系统的操作速度，CPU的一个操作周期内可以完成一个基本的操作命令。</li>
<li>上升沿和下降沿（Rising Edge and Falling
Edge）：这些术语描述的是时钟波形从低电平跳变到高电平（上升沿）和从高电平跳变到低电平（下降沿）的瞬间。在数字电路中，很多操作如数据的读取和存储常在上升沿或下降沿触发。</li>
<li>信号的传输（Signal
transmission）：指信号是如何在电线中连续传输的。这句话下面的“Transmission
is effectively
instantaneous”意味着信号的传播速度非常快，以至于可以被认为是瞬时的。</li>
<li>线上的信号值（Wire signal value）：这里提到的“any wire only contains
one value at any given
time”意味着在任何特定的时间点，一个导线上只有一个电压值，这可以是逻辑高（1）或逻辑低（0）。</li>
<li>公式 <span class="math inline">\(T =
\frac{1}{f{\text{req}}}\)</span><em>：这是计算时钟周期的公式，其中</em><span
class="math inline">\(T\)</span><em>是时钟周期时间，</em><span
class="math inline">\(f{\text{req}}\)</span>是频率。如果频率是单位时间内的周期数，那么周期时间就是频率的倒数。右边的大约等于1纳秒（1ns）表明，如果时钟频率是1GHz<span
class="math inline">\((10^9)Hz\)</span>，则一个周期大约为1纳秒。</li>
</ul>
<h2 id="group">Group</h2>
<ul>
<li>我们常说多少位的寄存器，多少位的cpu，这涉及到一个总线（bus）的概念</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699173167234-a1a05b3d-29c0-4a16-927d-e78f6580ef12.png#averageHue=%23f9f9f9&amp;clientId=u33a69565-ba28-4&amp;from=paste&amp;height=506&amp;id=ub3a03a1b&amp;originHeight=1012&amp;originWidth=1878&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=332364&amp;status=done&amp;style=none&amp;taskId=uda4cb5ce-3b3d-4b90-9506-9b77c53c39e&amp;title=&amp;width=939" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>最顶部的波形代表时钟信号<span
class="math inline">\(CLK\)</span>，它用来同步数据的传输。</li>
<li>下面的四行分别代表四根导线，标记为 <span class="math inline">\(X_3,
X_2, X_1, X_0\)</span>。这些线一起传输一个四位的二进制数字，即一个bit
field。不同时间点上，这些线上的电平高低组合代表不同的二进制数。</li>
<li><span class="math inline">\(X_3\)</span> 为最高位（Most Significant
Bit - MSB），<span class="math inline">\(X_0\)</span> 为最低位（Least
Significant Bit - LSB）。</li>
<li>底部的X列显示了在不同的时间点，这四根导线上的信号组合所代表的二进制数对应的十进制值。例如，当
<span class="math inline">\(X_3X_2X_1X_0\)</span> 为<span
class="math inline">\(0101\)</span>时，对应的十进制值为<span
class="math inline">\(5\)</span>。</li>
<li>当这组导线被用来代表一个位字段时，它们就构成了一个“总线”（bus）。总线是一种通信系统，允许多个数据和信号通过一组导线同时传输，这在计算机硬件中是常见的一种设计。</li>
<li>图中还展示了圆圈标记的“采样点”，这通常表示在时钟信号的特定阶段（通常是上升沿或下降沿）读取数据的时刻。在这些采样点上，<span
class="math inline">\(X_3X_2X_1X_0\)</span>的组合被确定并用于下一步的计算或处理。</li>
</ul>
<h2 id="register">Register</h2>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699173658153-4249ea0e-33ca-4d3c-a717-46ef52d3d50f.png#averageHue=%23f4f3f3&amp;clientId=u33a69565-ba28-4&amp;from=paste&amp;height=554&amp;id=u68d8ae28&amp;originHeight=1108&amp;originWidth=1766&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=236758&amp;status=done&amp;style=none&amp;taskId=u0052b809-6e43-45d8-9e91-2efc2ed042c&amp;title=&amp;width=883" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>图中展示了一个寄存器的简化符号和它的实际构成。一个寄存器由多个触发器（Flip-Flop）组成，这些触发器串联在一起，每个触发器存储一位（bit）的信息。</li>
<li>寄存器的输入端是 D（Data Input），输出端是 Q，图示展示了一个 n
位的寄存器，其中 n 表示触发器的数量。</li>
<li>图中等式的右侧是寄存器内部的详细表示，显示了 n
个D型触发器（Flip-Flop）的链，标有 <span
class="math inline">\(d_{n-1}\)</span>_ 到 <em><span
class="math inline">\(d_0\)</span></em> 和 _<span
class="math inline">\(q_{n-1}\)</span> 到 <span
class="math inline">\(q_0\)</span>。这表示每个触发器分别接收一位数据输入，并在时钟信号（CLK）的控制下输出一位数据。</li>
<li>D型触发器（D-type
Flip-Flop）是一种基础的存储设备，在正边沿或负边沿时钟触发的时候，会根据D输入更新其输出Q。
<ul>
<li>实际上，每个D型触发器有两个输出：<span
class="math inline">\(Q\)</span>和<span
class="math inline">\(\overline{Q}\)</span>。</li>
<li><span
class="math inline">\(Q\)</span>：这是主输出端，通常用于表示触发器存储的实际值。</li>
<li><span
class="math inline">\(\overline{Q}\)</span>：这是Q输出的反相，也就是<span
class="math inline">\(Q\)</span>的逻辑非。如果<span
class="math inline">\(Q\)</span>是<span
class="math inline">\(1\)</span>，那么<span
class="math inline">\(\overline{Q}\)</span>就是<span
class="math inline">\(0\)</span>；如果<span
class="math inline">\(Q\)</span>是<span
class="math inline">\(0\)</span>，那么<span
class="math inline">\(\overline{Q}\)</span>就是<span
class="math inline">\(1\)</span>。</li>
<li>在某些电路设计中，可能同时需要<span
class="math inline">\(Q\)</span>和<span
class="math inline">\(\overline{Q}\)</span>输出。 ### Edge-tiggered
D-type flip-flop <img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699174377406-3f269222-f466-4d96-9fb4-94c7a4e30b47.png#averageHue=%23f4f3f3&amp;clientId=u33a69565-ba28-4&amp;from=paste&amp;height=535&amp;id=u85a4b1dd&amp;originHeight=1070&amp;originWidth=1976&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=290392&amp;status=done&amp;style=none&amp;taskId=u1e459901-9c96-4e65-ab18-ba9cce3e4fb&amp;title=&amp;width=988" srcset="/img/loading.gif" lazyload
alt="image.png" /></li>
</ul></li>
</ul>
<ol type="1">
<li><strong>边沿触发D型触发器</strong>：这里提到的D型触发器是在时钟信号的<strong>上升沿</strong>触发的，意味着数据的<strong>捕获和传递</strong>是在时钟信号从<strong>低电平跳变到高电平</strong>的瞬间发生的。</li>
<li><strong>上升沿采样行为</strong>：当时钟信号<span
class="math inline">\(CLK\)</span>的上升沿到来时，<span
class="math inline">\(D\)</span>输入的数据会被采样并传输到输出<span
class="math inline">\(Q\)</span>。在其他时间，输入<span
class="math inline">\(D\)</span>被忽略，触发器保持先前采样的值。</li>
<li><strong>示例波形</strong>：</li>
</ol>
<ul>
<li><p><span
class="math inline">\(CLK\)</span>波形显示了时钟信号，它的上升沿用红色虚线标记。</p></li>
<li><p><span class="math inline">\(d\)</span>波形表示<span
class="math inline">\(D\)</span>型触发器的数据输入。</p></li>
<li><p><span class="math inline">\(q\)</span>波形显示输出<span
class="math inline">\(q\)</span>，展示了数据如何在CLK的每个上升沿被捕获并保持至下一个上升沿。</p></li>
<li><p>为了能够正确的读取并输出数据（避免时序错误），FF电路设计存在一些设计规范</p>
<ul>
<li><strong>Setup Time（建立时间）</strong>:
输入信号必须稳定保持一定的时间长度，在时钟信号触发之前，以确保输入能被正确读取。如果输入在时钟信号到来之前改变，那么翻转-复位可能不会正确地捕获输入信号的当前状态。</li>
<li><strong>Hold Time（保持时间）</strong>:
一旦时钟信号触发并且输入被读取，输入信号需要保持稳定一定的时间长度，即使在时钟信号触发之后。这是为了确保数据在被锁存之后不会由于任何噪声或者其他干扰而被错误地读取。</li>
<li><strong>Clock-to-Q Delay（时钟到Q的延迟）</strong>:
这是指从时钟信号触发到输出信号<span
class="math inline">\(Q\)</span>改变所需的时间。这个延迟是翻转-复位响应输入变化的速度的一个度量。</li>
</ul></li>
</ul>
<h3 id="accumulator-last">Accumulator Last</h3>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699175321266-6cce20d1-13b5-4b40-b063-5a6a3420743b.png#averageHue=%23f2f0f0&amp;clientId=u33a69565-ba28-4&amp;from=paste&amp;height=569&amp;id=ua3f30ff5&amp;originHeight=1138&amp;originWidth=1910&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=584832&amp;status=done&amp;style=none&amp;taskId=u606e7a31-3e0d-433e-b4b3-8b0693c3908&amp;title=&amp;width=955" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>累加器是一种常见的数字电路，它将一个数值加到另一个数值上，并将结果存储在寄存器中。在连续的时钟周期中，累加器可以对序列中的数值进行累积求和。
<ul>
<li><strong>Reset Signal</strong>:
这个信号用来初始化或清零累加器寄存器<span
class="math inline">\(Reg.\)</span>。这是一个控制信号，通常用来在计算开始前将累加器的值设定为一个已知的状态，如<span
class="math inline">\(0\)</span>。</li>
<li><strong>Signal Timing</strong>:
信号的定时对于累加器的正确运行至关重要。这包括确保输入信号 <span
class="math inline">\(X_i\)</span> 和之前的累积值 <span
class="math inline">\(S_{i-1}\)</span>
能正确同步。如果这些信号没有正确同步，累加器的输出 <span
class="math inline">\(S_i\)</span> 将会是错误的。</li>
</ul></li>
<li><strong>Temporary Wrong Values</strong>:
在累加器的操作过程中可能会暂时出现错误的值。然而，如果电路设计良好，寄存器最终会捕获并存储正确的累积值。</li>
<li><strong>Good Circuit Design</strong>:
在良好设计的电路中，不稳定的现象（比如信号抖动或错误的暂态值）不会在时钟的上升沿附近发生。电路设计应该确保在时钟的关键时刻（通常是上升沿或下降沿），所有的信号都稳定且同步，以避免数据错误。</li>
<li><strong>Undefined (Unknown) Signal</strong>:
在波形图的标记中，有一些信号状态被标记为“Undefined”（未定义），这表明在某些时刻信号的确切状态未知或不确定。</li>
</ul>
<h2 id="maximum-clock-frequency">Maximum Clock Frequency</h2>
<ul>
<li>我们希望Clock的周期能够很短（频率很高），完成这一步的前提是信号可以正确的被寄存器存取
<ul>
<li>设置时间（setup
time）是指输入信号需要在时钟信号的触发边沿到来之前保持稳定的时间长度。这是为了确保输入信号能够被寄存器正确地采集和锁存。</li>
<li>保持时间（hold
time）是指输入信号在时钟信号的触发边沿之后需要保持稳定的最短时间。即使时钟边沿到来后，输入信号也需要保持一段时间，以确保数据被正确地锁存。</li>
<li>因此这部分时间的减少要非常的小心</li>
</ul></li>
<li>除此之外，CPU的最快主频是由耗时最长的Critical
Path来定义的，如果主频过高，意味着寄存器会读到垃圾信号。</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699255628547-bd88658b-435b-4d11-876b-85080590a1cb.png#averageHue=%23f2eeee&amp;clientId=uf274c9d7-596b-4&amp;from=paste&amp;height=493&amp;id=uc53e51ed&amp;originHeight=986&amp;originWidth=1712&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=157275&amp;status=done&amp;style=none&amp;taskId=ua315a402-7559-403c-bfe0-8303c47a420&amp;title=&amp;width=856" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>关键路径的计算通常包括以下部分：
<ul>
<li>CLK-to-Q
Delay（时钟到输出的延迟）：寄存器从接收到时钟信号到输出数据所需的时间。</li>
<li>CL
Delay（组合逻辑延迟）：数据在寄存器之间传输过程中经过的所有组合逻辑单元产生的延迟。</li>
<li>Adder
Delay（加法器延迟）：如果路径中有加法器，其处理时间也会被包括在内。</li>
<li>Setup
Time（建立时间）：下一个寄存器在接收到时钟信号之前需要数据稳定的时间。</li>
</ul></li>
</ul>
<p>在<strong>设计</strong>时钟驱动的数字系统时，<strong>确保时钟周期长于关键路径上的总延迟是至关重要的</strong>。这可以确保每个数据点在下一个时钟信号到来之前都已经稳定并<strong>准备好传递</strong>，从而保持数据的完整性和同步。如果时钟周期太短，可能会导致数据错误或电路功能不稳定。图中红色的线条显示了电路中的关键路径，通过计算这条路径上所有延迟的和，设计者可以确定系统的最大时钟频率。这个概念是数字系统设计中的一个基本原则，特别是在设计高速和高性能的电路时至关重要。</p>
<h2 id="limited-frequency-by-circuit">Limited Frequency by circuit</h2>
<ul>
<li>状态的等待限制了CPU的最大主频</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699256055714-1d5a198d-f6a8-4608-a2a2-1f336f7e6fbe.png#averageHue=%23eae7e7&amp;clientId=uf274c9d7-596b-4&amp;from=paste&amp;height=353&amp;id=u9d050cc5&amp;originHeight=706&amp;originWidth=1494&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=207940&amp;status=done&amp;style=none&amp;taskId=u6078ed6c-d72b-412e-b6f1-97a2d34648e&amp;title=&amp;width=747" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>最大时钟频率是指数字电路能够正常工作的最高时钟速率。为了保证电路的稳定性和性能，时钟频率不能超过这个值。</li>
<li><strong>最大时钟频率</strong>受制于寄存器需要多少时间来正确获取到下一个状态，这个时间受到建立时间<span
class="math inline">\(( t_{setup} )\)</span>的约束。</li>
<li>设计假设最大延迟（Max Delay）要大于保持时间（Hold
Time），以确保数据的完整性。、
<ul>
<li>如果最大延迟小于保持时间，意味着单位保持时间内，信号变化可能会有多次，这会使得我们丢失信号</li>
</ul></li>
<li>最大延迟由以下部分组成：
<ul>
<li><strong>CLK-to-Q
Delay</strong>：时钟信号传播到寄存器输出的时间。</li>
<li><strong>CL Delay</strong>：组合逻辑产生的延迟。</li>
<li><strong>Setup
Time</strong>：寄存器捕获输入信号之前所需数据稳定的时间。</li>
</ul></li>
<li>最小周期（Min
Period）等于最大延迟，它定义了时钟信号间隔的最短时间。</li>
<li>最大频率（Max Freq）是最小周期的倒数，即 <span
class="math inline">\(\frac{1}{Min Period}\)</span>。</li>
</ul>
<p>电路图简化了电路的工作流程，显示了输入通过组合逻辑传递给寄存器，然后寄存器输出到下一个状态，同时也记录当前状态。这个过程是时序逻辑的基本工作模式，其中时钟信号协调数据在各个部分之间的传递。</p>
<h2 id="pipelining">Pipelining</h2>
<ul>
<li>为了正确的转移寄存器的状态，我们规定了最大时延要大于保持时延</li>
<li>而最大时延会CL的增加而增加，我们可以在CL中插寄存器来减少周期</li>
<li>关于流水线有一个很好的类比，假如救火的两种方式，一种是一个人每次拎一桶水从A到B然后救火；一种是一排人以一定间隔排列，然后把水桶从水源传递给下一个人一直到火场
<ul>
<li>流水线也存在启动延迟，而且不能简单的用前边的各种延迟来解释，涉及到指令填充的问题</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699258857116-ac9fd024-600d-4321-9778-114c73cd8567.png#averageHue=%23f5f4f4&amp;clientId=uf274c9d7-596b-4&amp;from=paste&amp;height=484&amp;id=u64bc9321&amp;originHeight=968&amp;originWidth=1048&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=291181&amp;status=done&amp;style=none&amp;taskId=uc5240625-f809-4bce-994d-cf463809927&amp;title=&amp;width=524" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>怎么判断某种电路能不能在某个主频的计算机上运行
<ul>
<li>核心就是关键电路的时延小于CPU主频的周期</li>
<li>1GHZ = 1ns = 1000ps</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699261304551-5b8b8638-d28c-4719-bc88-e4d80524b838.png#averageHue=%23ede8e8&amp;clientId=uf274c9d7-596b-4&amp;from=paste&amp;height=234&amp;id=uf5b1a59c&amp;originHeight=936&amp;originWidth=1388&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=170122&amp;status=done&amp;style=none&amp;taskId=ubae0ea72-c9b1-47a3-b96e-f8da8355db0&amp;title=&amp;width=347" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="finite-state-machines">Finite State Machines</h2>
<ul>
<li>通过有限状态自动机来建立顺序逻辑
<ul>
<li>FSM可以方便的概念化随时间的计算过程</li>
<li>FSM通过圆圈表示状态，通过箭头表示状态的转移</li>
<li>任何有限状态机都可以通过寄存器和逻辑电路在硬件中实现</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699352416543-b946c8b0-fd76-4f3c-b6ce-231b5e52a5a6.png#averageHue=%23f5f2f2&amp;clientId=uf274c9d7-596b-4&amp;from=paste&amp;height=232&amp;id=uc2cddb2e&amp;originHeight=928&amp;originWidth=1516&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=280151&amp;status=done&amp;style=none&amp;taskId=u82a251f3-72c9-4052-b1e4-defd8f6a56e&amp;title=&amp;width=379" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>此状态机用于检测连续的三个1，FSM还有很多应用。</li>
</ul>
<ol type="1">
<li><strong>计算机程序</strong>：在软件开发中，FSM被用来设计具有一定数目状态的程序，比如文本编辑器、网络协议和游戏的状态控制。</li>
<li><strong>协议设计</strong>：在网络通信中，如TCP/IP协议，FSM用来管理连接的建立、数据传输和连接的终止。</li>
<li><strong>用户界面</strong>：许多用户界面依赖于FSM来处理用户的输入，比如按钮按下、菜单选择和触摸屏手势。</li>
<li><strong>硬件设计</strong>：在数字电路设计，如微处理器的控制单元，FSM用来管理信号和操作的流程。</li>
<li><strong>语言解析</strong>：在编译器和解释器的开发中，FSM用于实现词法分析器，将用户输入的代码转换为可识别的令牌。</li>
<li><strong>游戏开发</strong>：在游戏开发中，FSM用于管理角色状态，如行走、跑动、跳跃或其他动作。</li>
<li><strong>自动控制</strong>：在自动化和机器人技术中，FSM被用于控制机器的状态转换，比如生产线上的机械手臂。</li>
<li><strong>信号处理</strong>：在数字信号处理中，FSM可以管理和决定如何处理进入的信号序列。</li>
<li><strong>交通控制</strong>：在交通灯系统和铁路信号系统中，FSM用来控制交通流程和信号灯的变化。</li>
<li><strong>电子游戏</strong>：在电子游戏控制中，FSM用来决定角色的行为，敌人的AI逻辑等。</li>
<li><strong>模式识别</strong>：在模式识别和序列检测中，FSM用于识别输入数据中的特定模式，例如条形码读取器。</li>
<li><strong>文本处理</strong>：FSM可以用来设计文本搜索算法，例如正则表达式引擎。</li>
</ol>
<ul>
<li>状态机的电路设计往往离不开寄存器和组合逻辑</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699353102559-7770f6b0-3d64-4696-abc0-56e6e0d3ba07.png#averageHue=%23f0efef&amp;clientId=uf274c9d7-596b-4&amp;from=paste&amp;height=421&amp;id=u543ec40b&amp;originHeight=842&amp;originWidth=1928&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=265182&amp;status=done&amp;style=none&amp;taskId=u9935861b-83ae-4ce5-92b7-ba0c7b64d79&amp;title=&amp;width=964" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ol type="1">
<li><strong>寄存器用于持有状态机状态的表示</strong>：</li>
</ol>
<ul>
<li>每个状态都有一个唯一的比特模式。</li>
<li>寄存器的输出是当前的状态（PS/CS，Present State/Current
State）。</li>
<li>寄存器的输入是下一个状态（NS，Next State）。</li>
</ul>
<p><em>拓展</em>：在硬件实现中，通常使用触发器（如D触发器）来存储状态机的当前状态。每个状态都被编码为一个唯一的二进制值，当状态变化时，这个值会在时钟信号（CLK）的控制下被更新。</p>
<ol start="2" type="1">
<li><strong>组合逻辑实现转换函数</strong>（状态转换 + 输出）：</li>
</ol>
<ul>
<li>组合逻辑负责根据当前状态和输入确定下一个状态以及相应的输出。</li>
</ul>
<p><em>拓展</em>：组合逻辑不存储任何状态信息，它是由逻辑门（如AND、OR、NOT等）组成的电路。它用来实现状态转移函数和输出函数，这些函数定义了在给定的当前状态和输入情况下，状态机应该转移到哪个状态，以及应该产生什么输出。</p>
<ol start="3" type="1">
<li><strong>整个系统的工作流程</strong>：</li>
</ol>
<ul>
<li>当时钟信号来临时，当前状态被用作组合逻辑的输入，组合逻辑根据当前状态和外部输入计算出下一个状态和输出。</li>
<li>计算出的下一个状态在下一个时钟周期变成当前状态，如此循环。</li>
</ul>
<p><em>拓展</em>：在硬件中实现FSM意味着我们可以设计出反应快速且确定的系统，这些系统在嵌入式系统、网络设备、消费电子产品等领域非常有用。通过硬件实现FSM，可以获得更好的性能，因为硬件可以在纳秒级的时间内响应状态变化，这比软件实现要快得多。</p>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699353533112-325d7966-08b2-4fdb-b2e0-606f5965574e.png#averageHue=%23edeaea&amp;clientId=uf274c9d7-596b-4&amp;from=paste&amp;height=167&amp;id=uf4eb7389&amp;originHeight=334&amp;originWidth=1062&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=104759&amp;status=done&amp;style=none&amp;taskId=u783860c5-2895-4eaf-ab0f-5adb2083f93&amp;title=&amp;width=531" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>CS代表当前的状态，我们可以表示的状态数要大于等于实际的状态数
<ul>
<li>如果出现了冗余，那么我们可以对XX随意设置以简化逻辑进而简化硬件（实际上我们自简化布尔逻辑完全不会考虑红色的部分）</li>
<li>这个电路允许我们识别连续的三个1
<ul>
<li>首先我们知道，对于FSM来说，我们需要弄清楚它的下一个状态，以及它的输出。</li>
<li>我们的状态使用了两位比特位来表示，我们需要把它拆出来，<span
class="math inline">\(NS_1\)</span>代表的是状态的高位，<span
class="math inline">\(NS_0\)</span>代表的是状态表示的低位
<ul>
<li>因此我们电路的输出有三个部分：状态高位，状态低位，输出位（根据当前状态计算出的值）</li>
<li>随后确认每一位的最简表示，例如除了状态低位，状态高位以及输出只需要两个比特就可以推出来</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699355884181-31b097d1-c6b5-4a85-8f5c-d0cd8933fb2b.png#averageHue=%23f2f2f2&amp;clientId=uf274c9d7-596b-4&amp;from=paste&amp;height=259&amp;id=u6a07156d&amp;originHeight=1036&amp;originWidth=1662&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=173580&amp;status=done&amp;style=none&amp;taskId=ud661ed06-9070-42b7-a9d2-2b95b0f3874&amp;title=&amp;width=416" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="arithmetic-logic-unitalu">Arithmetic Logic Unit（ALU）</h2>
<ul>
<li>计算机存在许多不同的Functional units</li>
<li>除去ALU还有浮点运算单元，算数逻辑单元等</li>
<li>做Lab时再仔细理解ALU</li>
</ul>
<h1 id="lecture-12-risc-v-cpu">Lecture 12 RISC-V CPU</h1>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1699512402694-fb43be65-5d69-4cf9-a6e4-ef3c61bcc85a.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1699512402694-fb43be65-5d69-4cf9-a6e4-ef3c61bcc85a.pdf%22%2C%22name%22%3A%22lec12.pdf%22%2C%22size%22%3A3723800%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u5fc03d61-3d26-4b3e-8704-fad11653f8a%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u03eebc14%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec12.pdf</a></p>
<ul>
<li>CPU可以划分为两个部分，Datapath &amp; Control</li>
<li>Datapath的作用是执行指令集定义的操作，例如算数操作，例如数据的传输，逻辑操作等
<ul>
<li>Datapath包含了许多硬件，例如Register，ALU，BUS，MUX等</li>
</ul></li>
<li>Control的作用是弄清楚一个指令要做什么，并正确的让Dathpath执行操作</li>
</ul>
<h2 id="r-type">R-Type</h2>
<ul>
<li>使用使用两个寄存器进行运算，将结果存储到另一个寄存器
<ul>
<li>获取指令</li>
<li>解析指令，具体操作的是哪些寄存器（rd,rs1,rs2 -&gt;
32个寄存器中的哪一个），操作是什么（add, sub, or ...）</li>
<li>从解析出的寄存器中读取数据</li>
<li>根据读取的数据以及操作运算</li>
<li>将结果写回到rd（目标寄存器）中</li>
</ul></li>
</ul>
<p><img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699423585966-03678628-0728-4006-a9fe-f7a58c9e2f95.png#averageHue=%23f3f3f3&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=453&amp;id=uf8f0f3ec&amp;originHeight=906&amp;originWidth=1496&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=121295&amp;status=done&amp;style=none&amp;taskId=u1f8c3ebc-02ff-4117-88e3-a5e964bf523&amp;title=&amp;width=748" srcset="/img/loading.gif" lazyload
alt="image.png" /> ### Get the Instruction</p>
<ul>
<li>指令存在哪里？
<ul>
<li>存在内存中，而IMEM中也存储了指令</li>
<li>CPU从哪里获取指令
<ul>
<li>IMEM中而不是内存中，内存中的指令例如addi会传输到IMEM中，CPU直接从IMEM中读取指令</li>
</ul></li>
</ul></li>
<li>我怎么知道该执行哪一条指令？
<ul>
<li>PC中存储了即将执行的指令的地址</li>
</ul></li>
<li>指令执行完后，怎么到下一条指令呢
<ul>
<li>对于R-Type类型的指令，只需要PC+4就行</li>
</ul></li>
<li>R-type的指令在取指阶段，Control还没有发挥作用</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699424737159-337f7751-44d3-4994-9cdd-d9f188c83a9e.png#averageHue=%23f2f2f2&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=348&amp;id=u889bcc36&amp;originHeight=696&amp;originWidth=1046&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=28340&amp;status=done&amp;style=none&amp;taskId=u982f2b19-c10a-4db7-acf2-f69defdb25c&amp;title=&amp;width=523" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="parse-instruction">Parse Instruction</h3>
<ul>
<li>通过取指我们已经确定到底要执行R-type类型的指令了，这个指令需要操作三个寄存器，所以我们需要从指令中解析出我们要操作的寄存器的实际地址</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699425035232-ca49ea0b-4bb0-4f05-b298-6438cfbbc214.png#averageHue=%23f0f0f0&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=353&amp;id=u3dc2c272&amp;originHeight=706&amp;originWidth=1054&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=37287&amp;status=done&amp;style=none&amp;taskId=u7c48b6e3-1150-4d62-87bb-8f6aaa08a36&amp;title=&amp;width=527" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>都是5位（RISC-V规定了32个寄存器）</li>
</ul>
<h3 id="read-data">Read-Data</h3>
<ul>
<li>现在我们有了寄存器的地址，需要从寄存器中把数据（操作数）取出来</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699425497792-efdffceb-5161-4c3e-838a-4d7d4ccf7679.png#averageHue=%23ebebeb&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=346&amp;id=u42fee804&amp;originHeight=692&amp;originWidth=1020&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=49338&amp;status=done&amp;style=none&amp;taskId=u7dab6816-419f-4112-9e0d-99ea1128e85&amp;title=&amp;width=510" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>RISC-V的CPU存在一个专有的硬件结构，专门用于存储寄存器中的值，称之为Register-File</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699425548280-3e65a142-b8d9-411f-a5ad-1964328542f0.png#averageHue=%23ebeae9&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=213&amp;id=u8ba27b19&amp;originHeight=852&amp;originWidth=1564&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=205383&amp;status=done&amp;style=none&amp;taskId=uc6c82d97-9426-4a70-8a89-137ef76a451&amp;title=&amp;width=391" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>Register-File具有32个32位的标准寄存器，0寄存器通常不会被设计进去，所以针对Register-File来说时往往是说有31个寄存器</li>
<li>端口A，B用于输出32位的数据给ALU做运算</li>
<li>RA，RB代表要读数据的寄存器的地址，RW代表要写数据的寄存器地址（当写使能为1时）</li>
<li>portW则用于接受要存入到寄存器中的数据</li>
<li>Clk同步读写的时钟信号</li>
</ul>
<h3 id="perform-operation">Perform operation</h3>
<ul>
<li>再有了实际的数据之后，我们需要通过ALU来执行计算</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699426426902-1fbf501e-7aff-47b5-a9c0-656b385bf8c5.png#averageHue=%23f1e9e9&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=368&amp;id=u360afb90&amp;originHeight=736&amp;originWidth=1016&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=59159&amp;status=done&amp;style=none&amp;taskId=u34949fc4-560c-482c-b36b-1a334e0b709&amp;title=&amp;width=508" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>在这一步Control来告诉了ALU到底该执行什么运算（func3+func7
来确定执行什么操作 R-type有很多运算 add和addi的fun3和fun7是一样的）</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699426664808-5e099664-c0c4-43fa-81d9-68e95cc826ad.png#averageHue=%23ededed&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=262&amp;id=ud6f58e9e&amp;originHeight=524&amp;originWidth=1666&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=573725&amp;status=done&amp;style=none&amp;taskId=uf8223486-6233-48ed-bc75-3a3b92d9287&amp;title=&amp;width=833" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>ALU从Register-File接受两个数据，在下一步写出到寄存器</li>
</ul>
<h3 id="write-res-to-destination-register">Write res to destination
register</h3>
<ul>
<li>控制写信号为1</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699426842572-c283a15f-584b-4530-af95-7c59eedc4d99.png#averageHue=%23eae7e7&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=381&amp;id=u3006fadf&amp;originHeight=762&amp;originWidth=996&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=62831&amp;status=done&amp;style=none&amp;taskId=u7d366067-8c94-43b1-9a5a-4e1fcd67d00&amp;title=&amp;width=498" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="i-type">I-type</h2>
<ul>
<li>当我们开始了解I-type时，我们就可以了解到，为什么指令集中的寄存器几乎总是规定在同样的位置，一切都是为了电路的简化与复用，我们每次不需要为每一种指令设置新的硬件结构，反而是不断的复用之前的结构</li>
<li>对于I-type类型的指令，以addi来做示例</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699428274920-46ad503f-1047-421c-87fe-2f2a41402cf0.png#averageHue=%23f0f0f0&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=375&amp;id=ue11c5559&amp;originHeight=750&amp;originWidth=1686&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=156064&amp;status=done&amp;style=none&amp;taskId=u0d5aac74-947a-43e6-958d-c7e5c176477&amp;title=&amp;width=843" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>对于I-type，我们去掉了fun7以及一个寄存器来表示一个带符号的立即数其他的位置和T-type的指令一摸一样</li>
</ul>
<p>对于I-type的指令，除了解析指令，以及执行计算部分，其他的一切和R-type保持一致，甚至是电路。</p>
<h3 id="parse-instruction-with-i-type">Parse Instruction with I
type</h3>
<ul>
<li>我们通过添加一个立即数生成器来完成立即数运算</li>
<li>我们通过ImmSel来控制如何对12位的imm进行拓展（例如符号拓展，无符号拓展等）</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699428618872-5b9e19a9-76c1-491c-8cf3-92b0fc1a44f8.png#averageHue=%23eceaea&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=453&amp;id=u6dd5a845&amp;originHeight=906&amp;originWidth=1076&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=75234&amp;status=done&amp;style=none&amp;taskId=ue62ba47b-5736-4fd2-baa3-a5814f0718e&amp;title=&amp;width=538" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="perform-operation-1">Perform operation</h3>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699429112979-20f6f8cf-4bbf-49ac-b71b-e1dba722faf1.png#averageHue=%23e9e7e7&amp;clientId=ub4f88ffc-0c5f-4&amp;from=paste&amp;height=421&amp;id=ua6c3fabf&amp;originHeight=842&amp;originWidth=1054&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=80882&amp;status=done&amp;style=none&amp;taskId=uf3a70291-cebc-4969-bdca-892f74e5569&amp;title=&amp;width=527" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>良好的指令编码设计规范体现了出来（RS2为什么在RS1之前？），我们通过添加一个MUX来控制送到ALU的是rs2还是imm，这个信号的控制通过BSel来直接控制</li>
</ul>
<h2 id="i-type-load-type">I-Type + (Load type)</h2>
<ul>
<li>Load type 也是I-type类型的指令</li>
<li>在I-Type的基础上，我们需要一个新的硬件结构来操作内存</li>
<li>我们从内存中读取数据首先会放到<code>DMEM</code>里</li>
<li>我们需要额外的MUX来决定，我们是要读取的数据，还是直接要ALU的运算结构，这个标志位由WBsel来控制</li>
<li>同时我们还需要一个标志位来控制这个时钟周期，我们是向DMEM中写数据还是从DMEM中拿数据出来</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699513628682-7bef1b37-f72b-4a64-b65d-2b6e22c822eb.png#averageHue=%23efeded&amp;clientId=u42a9ba41-dca7-4&amp;from=paste&amp;height=722&amp;id=u1f697239&amp;originHeight=1444&amp;originWidth=2064&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=184042&amp;status=done&amp;style=none&amp;taskId=u3829afc6-2557-4a02-ad35-8353a0cecc5&amp;title=&amp;width=1032" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>实际的DMEM会很复杂，我们通过简化的内存模块来描述</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699514044180-4062f199-fe04-49fe-8d96-f80d958b5fd6.png#averageHue=%23f0efee&amp;clientId=u42a9ba41-dca7-4&amp;from=paste&amp;height=655&amp;id=u514f440b&amp;originHeight=1310&amp;originWidth=2090&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=296318&amp;status=done&amp;style=none&amp;taskId=ufceea75d-0342-460d-83d1-a0931ce5cb9&amp;title=&amp;width=1045" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><p>存储器有一个输入端口（Data In）和一个输出端口（Data
Out）。</p></li>
<li><p>存储器访问可以是读操作或写操作：</p>
<ul>
<li>读操作：当Write
Enable（写使能信号）为0时，存储器会在特定的地址输出数据到Data
Out（32位）。</li>
<li>写操作：当Write Enable为1时，数据会被写入到特定的地址中。</li>
</ul></li>
<li><p>存储器还有一个时钟输入（CLK），这个输入只在写操作时是一个因素。写操作需要在时钟信号的控制下进行以保证数据的同步写入。</p></li>
<li><p>在读取时，存储器的行为类似于组合逻辑块：当地址有效后，Data
Out将在“访问时间”后变得有效。</p></li>
<li><p>数据路径：是指在处理器内部，数据从输入到输出过程中经过的逻辑和物理路径。这里涉及到的组件包括：</p></li>
<li><p>IMEM (指令存储器)</p></li>
<li><p>Register file(用来存放临时计算结果的寄存器集合)</p></li>
<li><p>ALU (算术逻辑单元，执行数学和逻辑运算)</p></li>
<li><p>DMEM (数据存储器，存放数据的存储器)</p></li>
<li><p>处理器设计有许多不同的组件。</p></li>
<li><p>不是每条指令都需要用到所有的组件。例如，所有的R类型指令（寄存器到寄存器的操作）以及某些I类型指令（即具有立即数的操作）在执行时不需要访问DMEM。</p></li>
<li><p>确实有某些指令需要用到所有的组件，如加载（load）指令。这类指令通常在数据路径中定义了“关键路径（critical
path）”，意思是这些指令在执行时会触及到数据路径中的每一个部分，可能因此决定了处理器性能的极限。</p></li>
</ul>
<p>所谓的“关键路径”是指处理器内部最长的数据处理路径，通常也是限制处理器性能的关键因素，因为它决定了处理器可以达到的最高时钟频率。</p>
<h2 id="s-type">S-Type</h2>
<ul>
<li>S-Type类型的指令是直接作用于内存的
<ul>
<li>需要IMEM</li>
<li>需要ALU</li>
<li>需要Imm</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699589709628-2f758d96-14dc-4a53-bf9a-ac5bc4bf9626.png#averageHue=%23eae9e9&amp;clientId=ue835a858-d22f-4&amp;from=paste&amp;height=320&amp;id=ufe75257e&amp;originHeight=640&amp;originWidth=1026&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=66484&amp;status=done&amp;style=none&amp;taskId=ufcadb776-4d81-4e96-a298-a1b6ca00f1b&amp;title=&amp;width=513" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>本质上我们添加了两条导线
<ul>
<li>RegWEN在S-type里一只会是False，因为我们不需要操作寄存器</li>
<li>可以直接把寄存器的值写到DMEM</li>
</ul></li>
</ul>
<h2 id="sb-type">SB-Type</h2>
<ul>
<li>SB-Formal和S-Format十分相像（除了立即数的摆放位置比较诡异）
<ul>
<li>这意味着他们的硬件有很大的复用设计</li>
<li>SB-type类型的指令主要就是用于分支的跳转，以及比较，因此我们需要在S-type基础之上添加一个新的比较硬件来实现分支的比较</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699590935304-03e35505-5089-45d2-8029-d63ed7eb6592.png#averageHue=%23f4f4f4&amp;clientId=ue835a858-d22f-4&amp;from=paste&amp;height=55&amp;id=u9d111744&amp;originHeight=110&amp;originWidth=1078&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=73302&amp;status=done&amp;style=none&amp;taskId=ubb7b44cc-3d3d-4abb-824c-f62be4d45e7&amp;title=&amp;width=539" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>这个硬件的作用就是根绝两个寄存器的值（注意是寄存器内的值）来输出比较信号
<ul>
<li>为我们不需要&gt;或者是&gt;=的信号线，&gt;可以用!&lt;= ，&gt;=
可以用!&lt;</li>
<li>哪里来处理这些额外的情况呢？（control）</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699591071931-0753fd9f-378c-45c7-9a55-3a216da5bab6.png#averageHue=%23eeeeee&amp;clientId=ue835a858-d22f-4&amp;from=paste&amp;height=302&amp;id=u868acf8c&amp;originHeight=604&amp;originWidth=1098&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=84746&amp;status=done&amp;style=none&amp;taskId=u4bcb3225-52b5-45cd-b3ed-369a6e0dca4&amp;title=&amp;width=549" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>我们主要需要处理控制逻辑
<ul>
<li>多了四条线，从左到右从上到下依次分析
<ul>
<li>第一条线承载了alu运算信号，即比较结果成立，跳转到PC+Imm处的地址（为什么连接到DMEM呢？）</li>
<li>第二条线将PC替换了RS1，ALU会把立即数和PC做相加运算</li>
<li>第三条线用于控制分支比较结果是否成立，来源于Branch
Comp硬件的输出的控制信号</li>
<li>第四条线用于控制，我们是需要RS1的值还是PC的值</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699591745442-ad79363a-06d9-434f-be22-329b0039f7ee.png#averageHue=%23e6e1e1&amp;clientId=ue835a858-d22f-4&amp;from=paste&amp;height=318&amp;id=ua118f616&amp;originHeight=636&amp;originWidth=1008&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=78037&amp;status=done&amp;style=none&amp;taskId=uaa7c5631-c732-40a1-a560-5213eefd9e0&amp;title=&amp;width=504" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="i-type-branch-related">I-type （Branch related）</h2>
<ul>
<li><code>JALR rd, rs, immediate</code>
<ul>
<li>跳转到PC+imm，写入PC+4 到寄存器</li>
</ul></li>
</ul>
<p><img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699593487306-ebdc7321-9e30-4101-ab8f-eb5720a28b94.png#averageHue=%23f8f8f7&amp;clientId=ue835a858-d22f-4&amp;from=paste&amp;height=75&amp;id=ue0014425&amp;originHeight=150&amp;originWidth=1036&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=72308&amp;status=done&amp;style=none&amp;taskId=ud1b52e13-3841-48e2-96b8-c6b49d42a9f&amp;title=&amp;width=518" srcset="/img/loading.gif" lazyload
alt="image.png" /> <img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699593340689-94f2b47f-7463-4f8c-a9ab-af3dd11d6f2b.png#averageHue=%23e1dfdf&amp;clientId=ue835a858-d22f-4&amp;from=paste&amp;height=311&amp;id=u1a4d69d7&amp;originHeight=622&amp;originWidth=998&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=76583&amp;status=done&amp;style=none&amp;taskId=u67415bed-646c-4df8-a9e6-e807c3b862b&amp;title=&amp;width=499" srcset="/img/loading.gif" lazyload
alt="image.png" /></p>
<ul>
<li>硬件设计也是在SB-Type上给MUX多加了一个控制信号，用于将PC+4的值写到某个寄存器</li>
</ul>
<h2 id="j-type">J-type</h2>
<ul>
<li>datapath没有任何改变</li>
</ul>
<h2 id="u-type-uj-type">U-type &amp; UJ-type</h2>
<ul>
<li>datapth没有任何改变</li>
</ul>
<h2 id="final-datahpath-risc-v">Final-Datahpath-RISC-V</h2>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699593723512-ea659337-a844-4f0d-a239-742e4553ff15.png#averageHue=%23e3dfdf&amp;clientId=ue835a858-d22f-4&amp;from=paste&amp;height=308&amp;id=u92a3f7b0&amp;originHeight=616&amp;originWidth=1008&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=76569&amp;status=done&amp;style=none&amp;taskId=uef250798-8b06-469d-8ea6-4a5816e5e20&amp;title=&amp;width=504" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><p>单指令周期CPU（一个CLOCK完成所有的事情，从内存中读取指令，指令解析，执行，读写内存，读写寄存器）</p></li>
<li><p>设计处理器的五个步骤：</p></li>
</ul>
<ol type="1">
<li><strong>分析指令集</strong> —
根据指令集分析数据通路需求。这涉及理解处理器需要执行的各种操作以及这些操作对硬件的具体需求。</li>
<li><strong>选择数据通路组件 &amp; 建立时钟方法论</strong> —
选择构成数据通路的不同硬件部件，并确定如何同步这些组件的操作，通常是通过一个时钟信号。</li>
<li><strong>组装满足需求的数据通路</strong> —
根据第一步中分析得出的需求，组装数据通路的硬件组件，确保它们能够执行所有必要的指令。</li>
<li><strong>分析每条指令的实现</strong> —
分析每条指令如何影响寄存器之间的数据传输，并确定控制点。这通常涉及指令的解码以及确定数据流向。</li>
<li><strong>组装控制逻辑</strong></li>
</ol>
<ul>
<li><p><strong>制定逻辑方程</strong> —
基于指令的需求和数据通路的功能，创建逻辑方程式来控制数据流向。</p></li>
<li><p><strong>设计电路</strong> —
根据逻辑方程设计电路，这些电路将实现处理器的控制逻辑。</p></li>
<li><p>设计处理器数据通路和控制信号的设计原则。</p></li>
</ul>
<ol type="1">
<li><strong>确定控制信号</strong>：</li>
</ol>
<ul>
<li>当数据通路的某个元素有输入改变其行为时（例如，算术逻辑单元（ALU）操作、读/写操作），它就需要一个控制信号。</li>
<li>每当你需要基于指令传递不同的输入时，就要添加一个带有控制信号作为选择器的多路复用器（MUX），如下一条程序计数器（PC）、ALU输入、要写入的寄存器等。</li>
</ul>
<ol start="2" type="1">
<li><strong>控制信号将基于您的确切数据通路而变化</strong>：</li>
</ol>
<ul>
<li>这意味着根据数据通路的设计和需求，控制信号的设置会有所不同。例如，不同类型的指令可能需要不同的控制信号来管理数据在数据通路中的流向。</li>
</ul>
<ol start="3" type="1">
<li><strong>数据通路将基于指令集架构（ISA）而变化</strong>：</li>
</ol>
<ul>
<li>处理器设计必须能够支持其指令集架构中定义的所有指令。因此，数据通路的设计会根据ISA的要求进行调整，以确保所有指令都可以被正确地执行。</li>
</ul>
<p>处理器设计具有模块化和灵活性，控制逻辑需要根据指令的不同而动态变化，以确保数据通路可以正确地执行指令集中的每条指令。</p>
<h1 id="lectur-13-risc-v-single-cycle-control-and-pipelining">Lectur 13
RISC-V Single-Cycle Control and Pipelining</h1>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1699595147216-5cd0371c-3b12-41dc-96c9-95e6eae7cbaf.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1699595147216-5cd0371c-3b12-41dc-96c9-95e6eae7cbaf.pdf%22%2C%22name%22%3A%22lec13.pdf%22%2C%22size%22%3A6094293%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ubd48f122-ca26-4003-a19b-e6e1b379e5d%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22uc0d4d48f%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec13.pdf</a></p>
<ul>
<li>回顾</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699873136535-72b696fa-7745-4770-9071-8f32bf45d9f5.png#averageHue=%23efe2ca&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=523&amp;id=ube91335d&amp;originHeight=1046&amp;originWidth=1534&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=147955&amp;status=done&amp;style=none&amp;taskId=uac2c0a93-9710-4bae-ab4c-9463a33545d&amp;title=&amp;width=767" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><p><strong>PCSel</strong>:
程序计数器选择信号，控制下一条指令的地址来源，比如是否来自分支指令或者正常的顺序执行。</p></li>
<li><p><strong>ImmSel</strong>:
立即数选择信号，用于控制是否将指令中的部分字段用作立即数。</p></li>
<li><p><strong>RegWEn</strong>:
寄存器写使能信号，控制是否将数据写入寄存器文件。</p></li>
<li><p><strong>BrUn/BrEq/BrLT</strong>:
分支指令的类型信号，用于判断分支条件，如无条件分支（BrUn）、相等分支（BrEq）或小于分支（BrLT）。</p></li>
<li><p><strong>BSel/ASel</strong>:
B选择和A选择信号，决定ALU的两个操作数来源，如是否来自寄存器或立即数。</p></li>
<li><p><strong>ALUSel</strong>:
ALU操作选择信号，决定ALU将执行哪种操作，如加法、减法等。</p></li>
<li><p><strong>MemRW</strong>:
内存读写信号，控制是对内存的读操作还是写操作。</p></li>
<li><p><strong>WBSel</strong>:
写回选择信号，决定写回阶段的数据来源，如来自ALU的结果或内存读数据。 ##
Control Implementation</p></li>
<li><p>13.2 for Lab3</p></li>
<li><p>控制信号的意义在于，我们可以通过不同的控制信号，来使得同样的硬件去识别并执行不同的指令</p></li>
<li><p>每个控制信号都基于func3和func7来确定具体的指令，对于某条确定的指令，我们可以不设计那些不涉及该条指令控制的信号（使用*来表示我们不在意的控制信号）</p>
<ul>
<li>func7尽管有7位，但我们目前并没有全部用到；同理fun3也是，这是对拓展性的一种兼容。</li>
<li>func7的高5位常被用于区分具有较大差异的指令（拓展指令），例如ADD和ADDI等“跨type”的指令；func3的高两位则用作更细粒度的区分，例如LB，LH等“type
内”的更为细粒度的操作</li>
</ul></li>
<li><p>通过ADD指令来观察不同的控制信号是如何被需要，以及被设置为*的</p></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699875737196-8e0725f3-7e76-460f-ba1c-9002d69e82f9.png#averageHue=%23efefef&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=393&amp;id=zSQop&amp;originHeight=786&amp;originWidth=1424&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=113678&amp;status=done&amp;style=none&amp;taskId=u49f1b324-ee01-42a5-8673-82d7331ffb9&amp;title=&amp;width=712" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>很明显对于ADD操作来说，我们的PCSel只需要+4就可以了，因为我们的ADD指令不设计任何分支的跳转</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699875822110-0981b10b-2f5f-4d39-9128-ce0cf4e81846.png#averageHue=%23efecec&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=510&amp;id=uced3bc9f&amp;originHeight=1020&amp;originWidth=1510&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=190355&amp;status=done&amp;style=none&amp;taskId=u89ef29b7-a5dc-4dd8-b627-6922780ecec&amp;title=&amp;width=755" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>ADD操作是针对两个寄存器内的值进行运算并存储到目标寄存器的运算，因此对于ImmSel信号来说，我们直接忽略掉，只有涉及到立即数运算的操作我们才需要关注这个信号；而对于RegWEn来说，很明显我们需要把它设置为1，因为我们要把结果写回到寄存器里。</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699875969843-7492513d-d4b6-4c2c-b00e-6ac7a980dfd9.png#averageHue=%23f1efef&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=522&amp;id=ua830967e&amp;originHeight=1044&amp;originWidth=1526&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=139943&amp;status=done&amp;style=none&amp;taskId=uf8fb4654-8050-4d1f-bbe3-f3213021b25&amp;title=&amp;width=763" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>很明显对于ADD操作来说，我们没有任何分支判断的概念，我们只是把两个寄存器的内容进行相加，因此设置为*</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699876046914-c7cc5590-08a7-4aab-9ead-a36adfe36eea.png#averageHue=%23f1eded&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=533&amp;id=u6cc9cc6d&amp;originHeight=1066&amp;originWidth=1648&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=187421&amp;status=done&amp;style=none&amp;taskId=u14b7ceec-be7b-447f-aba2-a1ffcd15ee2&amp;title=&amp;width=824" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>对于BSel信号和ASel信号来说，ADD操作涉及到了两个寄存器的值相加，因此我们不需要立即数，所以ASel和BSel一起设置为0来选择寄存器；对于ALUsel来说，我们需要设置ALU到底做了什么运算，我们需要选择为Add，所以设置为？<strong>这里头一次出现了我们无法用0或1来描述所有操作的情况，</strong>因为ALU不仅仅支持加法除法而已，实际上这里也有一个二进制值，具体的值和构建ALU的行为有关，我们只需要确定所有ADD的操作都使用一个ALUsel就行。</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699876654809-03039830-daba-47b7-96df-6bf7f09e04dc.png#averageHue=%23efecec&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=531&amp;id=u93db6920&amp;originHeight=1062&amp;originWidth=1554&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=195452&amp;status=done&amp;style=none&amp;taskId=u3d08720f-24c0-4d80-8e5a-8b0ff518429&amp;title=&amp;width=777" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>ADD操作不设计任何对RAM的操作，那依照刚刚的设计，MemRW作为无关的信号我们忽略就好，但这里存在一个准则，如果操作没有内容需要读/写到内存，MemRW永远为0。WBSel设置为1，将ALU结果输出到寄存器。</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699877160929-6dc1e282-1ca4-480e-965d-212df0056ef4.png#averageHue=%23eea677&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=553&amp;id=ufaff0dc3&amp;originHeight=1106&amp;originWidth=1546&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=223072&amp;status=done&amp;style=none&amp;taskId=u4cafc32b-fd2d-4019-833d-429efe82a2c&amp;title=&amp;width=773" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><p>绿色代表Control接收的信号输入，橙色则代表输出到DathPath的信号</p></li>
<li><p>我们有两种实现Control的方法，一种是通过ROM来存储上述的控制表，这种方法容易编程且容易修改；第二种是通过CL来实现，这种方法成本更低，但复杂度更高，因为需要电路设计。</p>
<ul>
<li>基于ROM的设计接受11位的控制信号输入，输出15位的控制信号</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699877807732-68b92d67-e5b0-4100-991d-eb7dc6e7cffa.png#averageHue=%23fcfefc&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=453&amp;id=u8adba903&amp;originHeight=906&amp;originWidth=1420&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=113654&amp;status=done&amp;style=none&amp;taskId=u370a7301-ef84-4476-a5ee-34f11beaec8&amp;title=&amp;width=710" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>当然首先要经过解码的处理</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699877892322-0238ce83-6bff-4612-b6dc-29d46f80d837.png#averageHue=%23f5f5f5&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=444&amp;id=udde06842&amp;originHeight=888&amp;originWidth=1406&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=88994&amp;status=done&amp;style=none&amp;taskId=u27d3078e-f329-494e-b553-b5e4670b5b9&amp;title=&amp;width=703" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="performance-analysis">Performance Analysis</h2>
<ul>
<li>在我们选购一台跑车时，我们希望它的平均速度能够很快，但很明显不是越快越好，这在物理上以及实际使用上都非常不切实际。</li>
<li>我们对于指令的要求，希望它越快越好，速度越快，我们可以解决越多的问题，然而受制于现实，这也显得不切实际。并且指令的执行速度，也不是唯一的性能指标。</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699878252553-d59ae283-e9f2-48ee-aa1e-3f7459021512.png#averageHue=%23e7d89b&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=416&amp;id=u404c315f&amp;originHeight=832&amp;originWidth=1498&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=197186&amp;status=done&amp;style=none&amp;taskId=u7c29331c-da4f-4a32-857d-75723a0477f&amp;title=&amp;width=749" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>我们指令的运行阶段分为五个周期，IF（取指），ID（读指），EX（执行），MEM（内存读写，WB（寄存器写？为什么呢？至少依照目前的理解，CPU的电路图表明一条指令要么是分支指令要么不是，如果不是那么意味着必须跳转到下一条指令）</li>
<li>我们可以看到的是ID和WB操作耗时是比较少的，ALU，IF，MEM都比较慢。</li>
</ul>
<p><span class="math inline">\(\frac{1}{800} ps = 1.25GHz\)</span></p>
<ul>
<li>RISC-V是单周期指令，所以在不考虑任何优化的情况下，我们时钟频率最大也只能在1Ghz左右浮动。即1条指令需要800ps的执行时间，我们希望能够提高指令的性能。</li>
</ul>
<h3 id="performance-in-cpu">Performance in CPU</h3>
<ul>
<li>CPU的性能指标不仅仅是指令的速度快慢，性能指标不那么明显，通常涉及到：
<ul>
<li>能源消耗</li>
<li>程序的执行时间能不能更慢</li>
<li>服务器的吞吐量能不能更高</li>
</ul></li>
</ul>
<h3 id="iron-law-of-processor-performance">Iron law of Processor
Performance</h3>
<p><img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699879801599-770076e8-6630-4fd7-bfa8-cd70e68e872e.png#averageHue=%23f0eaea&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=115&amp;id=ucac88725&amp;originHeight=230&amp;originWidth=1344&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=27095&amp;status=done&amp;style=none&amp;taskId=u9221c619-db80-42e5-96a8-9e14b062d65&amp;title=&amp;width=672" srcset="/img/loading.gif" lazyload
alt="image.png" />
"处理器性能的铁律"是一个基础公式，用于理解执行程序所需时间的影响因素。它将执行程序的总时间分解为三个主要组成部分：</p>
<ol type="1">
<li><strong>每个程序的指令数</strong>：程序包含的机器级指令总数。</li>
<li><strong>每条指令的周期数
(CPI)</strong>：处理器执行每条指令平均需要的时钟周期数。这取决于指令的复杂性和处理器的效率。</li>
<li><strong>每个周期的时间</strong>：这是时钟周期，或时钟频率的倒数。它是完成一个时钟周期所需的时间。</li>
</ol>
<p>这三个因素的乘积给出了执行程序所需的总时间。通过优化这些因素中的任何一个，可以提高处理器执行程序的性能。</p>
<ul>
<li>Instructions per Program
<ul>
<li>task - 复杂任务可能需要更多的指令数</li>
<li>算法 - 例如<span class="math inline">\(O(n)\)</span>和 <span
class="math inline">\(O(n^2)\)</span>，更高复杂度的算法可能会生成更多指令</li>
<li>编译器 - 编译优化</li>
<li>ISA的设计 -
某些复杂操作在某些ISA可能只需要一条指令，但在别的ISA可能需要数条</li>
<li>输入 -
直到输入之前我们是不知道程序会运行多久（这个感觉和某个程序的指令数不太搭，但也的确会影响执行效率）；此外一个比较合乎的解释就是，输入对动态执行指令的影响，虽然我们有很多指令，但是这些指令并不一定都会被执行。</li>
</ul></li>
<li>Clock cycles per Instruction （ CPI ）
<ul>
<li>ISA的设计，例如对于RISC-V来说，一个周期一个指令，而复杂指令集单条指令可能需要更多的周期从而导致更大的CPI</li>
<li>Superscalar processors ，想办法令CPI小于1</li>
</ul></li>
<li>Time per Cycle
<ul>
<li>处理器的微架构，例如关键路径会影响最小周期</li>
<li>晶体管技术的提高可以降低时钟周期</li>
<li>功率预算（低电压带来长周期）</li>
</ul></li>
<li>针对某任务的分析
<ul>
<li><span class="math inline">\(\frac{1*2.5}{2.5Ghz} &gt;
\frac{1.5*1}{2Ghz}\)</span></li>
<li>降低了电压，同时又降低了执行时间，这里的关键因素就是，CPI的大小</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699881394636-18f38318-1b90-4a76-9fbc-99d8dd476739.png#averageHue=%23cbe1bd&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=243&amp;id=u790041df&amp;originHeight=486&amp;originWidth=1428&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=81204&amp;status=done&amp;style=none&amp;taskId=u2a8a6463-2ff1-46de-a551-2f1fda393e0&amp;title=&amp;width=714" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>Energy per Task
<ul>
<li>单个程序的能源消耗等于单个程序的指令数乘每个指令消耗的能量，正比于单个程序的指令数乘电容和电压的平方</li>
<li>为了降低单个任务的能耗，我们需要降低电容和电压；由于电压是二次方项，降低这一项直接影响能耗。</li>
<li>摩尔定律意味着我们的CPU能耗比越来越高
<ul>
<li>电容的下降，电压的下降，更低的发热</li>
</ul></li>
</ul></li>
</ul>
<h3 id="energy-iron-law">Energy Iron Law</h3>
<p><span class="math inline">\(Performance = Power * Energy \
Efficiency\)</span></p>
<ul>
<li>同样的功率，要么意味着大功率，要么意味着利用率更高的系统</li>
<li>对于数据中心，我们的优先级是希望能够处理更多的任务，所以我们并不是Energy-sensitive的，但是对于移动设备而言，我们的能量是有限的，这意味着我们必须要极高的能量利用效率才可以维持一定的效能</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699930548981-08e9e571-36de-4861-9dc8-de959c4be2b5.png#averageHue=%23e5e5e5&amp;clientId=u2dfade29-2fd3-4&amp;from=paste&amp;height=356&amp;id=u54b51faa&amp;originHeight=712&amp;originWidth=1502&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=131998&amp;status=done&amp;style=none&amp;taskId=uf4eb541d-bf9b-435a-92c7-fe179062ea8&amp;title=&amp;width=751" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>现代CPU在制程方面遇到了一定瓶颈
<ul>
<li>电压过低导致的泄漏问题，开关（gate）无法闭合，导致我们只有1个状态</li>
<li>晶体管的缩小变得很困难</li>
<li>热管理也是一个问题，既然我们无法缩小芯片，那就提高功率，但这意味着我们在非常小的空间产生了巨大的能量，甚至可以融化芯片，风冷散热是我们的功率被限制在了150w
## Pipelined</li>
</ul></li>
<li>通过一个简单的例子来说明Pipelined的原理</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699934308309-4c92395b-7970-481b-8adf-e9b0fbf1dd51.png#averageHue=%23ededed&amp;clientId=ucfeacce5-31a1-4&amp;from=paste&amp;height=456&amp;id=u1f9dac16&amp;originHeight=912&amp;originWidth=1478&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=134682&amp;status=done&amp;style=none&amp;taskId=u3b647409-6527-4ed7-88da-2f397d06a52&amp;title=&amp;width=739" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>假设有四个不同人，他们都需要用到洗衣机，烘干机，厕所，而这些东西在一个屋子里。
<ul>
<li>最直接的策略就是一个人在屋子里处理完所有的事，然后由下一个人继续</li>
<li>每一个任务需要2小时来完成，四个任务一共需要8个小时</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699934363404-ead88815-3283-459f-bee1-33c3f4fe13ad.png#averageHue=%23f2f2f2&amp;clientId=ucfeacce5-31a1-4&amp;from=paste&amp;height=521&amp;id=u67090e73&amp;originHeight=1042&amp;originWidth=1500&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=148193&amp;status=done&amp;style=none&amp;taskId=u588a4847-ed69-4659-8de9-dbf852c96e2&amp;title=&amp;width=750" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>通过最大限度的资源抢占，3.5个小时可以完成4个任务</li>
<li>一个任务的延迟增加了</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699935783698-1264667c-54ab-431b-b2b6-a9cc8fbdfeb8.png#averageHue=%23818282&amp;clientId=ucfeacce5-31a1-4&amp;from=paste&amp;height=293&amp;id=ufab29eed&amp;originHeight=586&amp;originWidth=1270&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=123531&amp;status=done&amp;style=none&amp;taskId=u6471b15f-2e13-4af0-9ac8-04ad7bc4877&amp;title=&amp;width=635" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>流水线的延迟之所以提高了，是因为我们需要以最大延迟来设置指令五个阶段的每一段时延，如果不这样的话我们可能会读出垃圾信号</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699936148260-68ce58f4-a05d-4a71-a314-0c98a9d7b4c6.png#averageHue=%23f9f9f9&amp;clientId=ucfeacce5-31a1-4&amp;from=paste&amp;height=238&amp;id=uc94a2c8f&amp;originHeight=476&amp;originWidth=1242&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=103620&amp;status=done&amp;style=none&amp;taskId=u28c88bf7-262d-41cc-be6a-04bff4c2754&amp;title=&amp;width=621" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>原本需要串行执行的指令，现在在一部分时间上是并行的，但单个电路在同一时刻依然是串行的</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699936975492-5f153ec4-c8dc-48fd-ae24-054666dbde72.png#averageHue=%239dd06a&amp;clientId=ucfeacce5-31a1-4&amp;from=paste&amp;height=551&amp;id=ud45559a5&amp;originHeight=1102&amp;originWidth=1660&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=238240&amp;status=done&amp;style=none&amp;taskId=ucfd1e5c6-574c-4f15-8f4c-5cd07a6ca97&amp;title=&amp;width=830" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>对于<span
class="math inline">\(t_{cycle}\)</span>来说，它是大于给定值的，因为流水线的本质时是寄存器到每一个阶段，寄存器会导致一些其他的时延</li>
<li>我们希望CPI&lt;1
，但现实的情况是引入流水线后它会大于一，但这带来了更高的吞吐量</li>
<li>关于<span class="math inline">\(f_s\)</span>为什么是<span
class="math inline">\(\frac{1}{200}\)</span>，计算方式应该是<span
class="math inline">\(\frac{指令数}{总运行时间} =
\frac{5}{1000}\)</span></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699937497542-6bf6df95-3261-45e4-99df-dbdeea497e19.png#averageHue=%23eceaea&amp;clientId=ucfeacce5-31a1-4&amp;from=paste&amp;height=441&amp;id=u60b2af59&amp;originHeight=882&amp;originWidth=1506&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=205204&amp;status=done&amp;style=none&amp;taskId=ucd281340-725f-4d6b-b6dc-187acc562eb&amp;title=&amp;width=753" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>具体而言我们会在路径上添加寄存器，然后提高主频。</li>
<li>这里的流水线的电路以后需要的话在仔细研究</li>
</ul>
<h1 id="lecture-14-pipeline-hazards">Lecture 14 pipeline hazards</h1>
<ul>
<li>hazards是一种阻止下一条指令直接运行的情况，我们有三种不同的hazards
<ul>
<li>structural hazard</li>
<li>data hazard</li>
<li>control hazard</li>
</ul></li>
</ul>
<ol type="1">
<li>结构危险 (Structural Hazard):</li>
</ol>
<ul>
<li>结构危险发生在某个所需的资源正在被其他操作或指令占用的情况下。这种危险通常涉及到硬件资源的冲突，比如某个功能单元（如算术逻辑单元）同时被多条指令使用。</li>
<li>例子：如果一条指令需要执行一个乘法操作，而在同一时钟周期内另一条指令也需要执行乘法操作，那么就会发生结构危险，因为乘法功能单元可能无法同时处理这两条指令。</li>
</ul>
<ol start="2" type="1">
<li>数据危险 (Data Hazard):</li>
</ol>
<ul>
<li>数据危险发生在两条或多条指令之间存在数据依赖关系，后一条指令需要依赖前一条指令的结果，但前一条指令的结果还没有准备好。这种危险会导致等待前一条指令完成其数据写入。</li>
<li>例子：考虑一条指令要将一个值存储到内存中，而紧随其后的另一条指令需要读取刚刚存储的值。如果第一条指令的存储操作没有完成，第二条指令就无法获得正确的数据，从而导致数据危险。</li>
</ul>
<ol start="3" type="1">
<li>控制危险 (Control Hazard):</li>
</ol>
<ul>
<li>控制危险发生在指令的执行顺序取决于前一条指令的控制流（如分支或跳转指令）。如果前一条指令的条件分支还没有解决，那么下一条指令的执行路径可能会受到影响，需要等待前一条指令的分支决策。</li>
<li>例子：当执行条件分支指令（如if语句）时，如果分支条件还没有计算完成，系统可能需要等待条件计算完成后才能决定执行哪个分支，从而导致控制危险。</li>
</ul>
<p>这些危险类型都会影响指令的执行效率和流水线的吞吐量。为了解决这些危险，处理器设计师通常会采用技术如<strong>超标量执行</strong>、<strong>数据前瞻执行</strong>、<strong>乱序执行</strong>等，以最大程度地减少危险的影响，提高指令执行的效率。</p>
<h2 id="structure-hazards">Structure hazards</h2>
<ul>
<li>Register file
<ul>
<li>两种解决方案使得单个周期同时对寄存器读和写成立。
<ul>
<li>构建具有独立读和写端口的寄存器文件。这意味着在同一时钟周期内可以同时进行读和写操作（单级流水线很适合使用）。</li>
<li>Double Pumping第一个半周期的下降沿写，第二个半周期读</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699945252928-2b3e88c1-68c3-4b63-9e36-8fafc46dd6b7.png#averageHue=%23f5f5f5&amp;clientId=ub65e741a-44e6-4&amp;from=paste&amp;height=457&amp;id=ua50dbcc8&amp;originHeight=914&amp;originWidth=1612&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=156033&amp;status=done&amp;style=none&amp;taskId=u78003dc1-24f3-4c66-b926-b104e74b9e4&amp;title=&amp;width=806" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>Memory</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699946036129-73e1a243-9808-4f2e-8113-c1906159df98.png#averageHue=%23f5f4f4&amp;clientId=ub65e741a-44e6-4&amp;from=paste&amp;height=465&amp;id=uff49a987&amp;originHeight=930&amp;originWidth=1580&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=159603&amp;status=done&amp;style=none&amp;taskId=u7c25acc5-d852-4001-bfcb-2fa57b52e99&amp;title=&amp;width=790" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>就一个内存单元的话那就只能等，没什么特别好的方法，但是Cache一定程度会缓解这个问题，因为我们在IM阶段可能会从缓存中拿到数据。</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699946331006-607d95ed-c763-4f80-9ff6-18e4a2f7988f.png#averageHue=%2382a247&amp;clientId=ue4f24806-b56c-4&amp;from=paste&amp;height=381&amp;id=u85136ee4&amp;originHeight=762&amp;originWidth=1350&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=92520&amp;status=done&amp;style=none&amp;taskId=u902a1068-8a1c-4cd0-b7a2-4c2335cf36a&amp;title=&amp;width=675" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="data-hazards">Data Hazards</h2>
<ul>
<li>以Rtype为例</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699946935232-30973a18-c0fa-40f0-a4fd-e73322d51b8a.png#averageHue=%23f6f5f5&amp;clientId=ue4f24806-b56c-4&amp;from=paste&amp;height=254&amp;id=u4da68e42&amp;originHeight=508&amp;originWidth=1420&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=165776&amp;status=done&amp;style=none&amp;taskId=ua8a9053c-f432-469e-a60d-8c551379175&amp;title=&amp;width=710" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><p>对于第2，3条指令来说，它们依赖于t0寄存器的结果，如果没有pipline的话，那么这不是问题。但现在在第一条指令还没执行完的时候，我们的2，3指令就已经开始执行了。这种出现数据依赖的情况就叫做Data
hazards。</p></li>
<li><p>第一种解决方案就是流水线暂停，也叫Stalling。通过执行一些不会改变任何状态的命令例如add
x0, x0,x0 （x0寄存器永远是0）</p></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699947400307-be24e918-283d-4ac7-b5f8-05b7b73d67eb.png#averageHue=%23f6f6f6&amp;clientId=ue4f24806-b56c-4&amp;from=paste&amp;height=387&amp;id=uc1f7bccd&amp;originHeight=774&amp;originWidth=1768&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=313340&amp;status=done&amp;style=none&amp;taskId=u9f699ee8-0a49-4dc5-afac-5fb99699a48&amp;title=&amp;width=884" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>第二种可能的方案是由编译器进行的指令重排，或者由编写者手动进行优化</li>
<li>第三种方案是数据的前向传递，例如将ALU计算完之后直接将结果传递给流水线下一条指令的ALU，这需要额外的硬件实现</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699948155875-4a57cecd-ff48-4c6d-8d88-f69b251b9fa0.png#averageHue=%23f5f0f0&amp;clientId=ue4f24806-b56c-4&amp;from=paste&amp;height=440&amp;id=ubf120bff&amp;originHeight=880&amp;originWidth=1856&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=201109&amp;status=done&amp;style=none&amp;taskId=udc57e219-4876-4249-af19-3508524570b&amp;title=&amp;width=928" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>硬件原理在这里，需要的话在仔细研究</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699948531102-70b1b179-9dce-4722-9c73-90b1243ee2d7.png#averageHue=%23eceaea&amp;clientId=ue4f24806-b56c-4&amp;from=paste&amp;height=508&amp;id=uc116fa26&amp;originHeight=1016&amp;originWidth=1612&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=155085&amp;status=done&amp;style=none&amp;taskId=u0b358fba-72b3-4d98-bd03-ca8e7e1b862&amp;title=&amp;width=806" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>不是所有的data
hazards都可以用前向传递来解决，以加载指令为例，我们无法用前向传递来解决，必须要等，而且如果非要使用前向传递的话，我们还需要添加硬件</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699949418920-83d62d2d-4d9b-4bb9-9045-10f67aa4bd3d.png#averageHue=%23f0eeee&amp;clientId=u22923803-2ba2-4&amp;from=paste&amp;height=364&amp;id=ub4bddbe9&amp;originHeight=728&amp;originWidth=1788&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=145497&amp;status=done&amp;style=none&amp;taskId=u1da15f2c-dfaa-49f4-9512-c397aba52a3&amp;title=&amp;width=894" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>暂停的方法除了执行nop指令外，现代微处理器还支持硬件中断</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699949665278-75834907-e9bf-4099-91ae-795a3f4d1a88.png#averageHue=%23f5f4f3&amp;clientId=u22923803-2ba2-4&amp;from=paste&amp;height=427&amp;id=u9a2a9519&amp;originHeight=854&amp;originWidth=1688&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=200078&amp;status=done&amp;style=none&amp;taskId=u659d888c-991f-426a-854c-328fcfd4ae7&amp;title=&amp;width=844" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>效果和nop指令是一样的</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699949784010-51a57b07-7094-41d9-907c-f416849ca3d0.png#averageHue=%23f5f5f4&amp;clientId=u22923803-2ba2-4&amp;from=paste&amp;height=440&amp;id=u9c6caf7e&amp;originHeight=880&amp;originWidth=1706&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=186665&amp;status=done&amp;style=none&amp;taskId=u8769f648-bce7-4647-b3a6-1d303d7f3fd&amp;title=&amp;width=853" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>无论哪种方法，只要发生了暂停，那意味着我们效能的损失，因此我们可以让编译器来通过指令重排，使得那些本来需要中断或者添加nop指令的位置来执行其他指令</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1699950098999-806e5336-8ea6-4d6a-bd93-67fa12b1aeb9.png#averageHue=%23efecec&amp;clientId=u22923803-2ba2-4&amp;from=paste&amp;height=280&amp;id=u4d6e1904&amp;originHeight=560&amp;originWidth=1520&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=117097&amp;status=done&amp;style=none&amp;taskId=uc6d6a255-a45c-4896-81d4-ec34e385489&amp;title=&amp;width=760" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="control-hazards">Control Hazards</h2>
<ul>
<li>Pipline
会对beq指令产生一些影响，因为我们并不确定要跳转到哪里，直到ALU给出具体的地址
<ul>
<li>CPU就像一个自动机一样，不断的执行指令，对于没有pipline的CPU，我们的取指阶段总会在上一条指令执行完毕之后才会继续执行；而对于pipline来说，在第一条指令还没有结束的时候，第二条指令的IM就开始了。而此时的PC还没有更新</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1700109920508-b70a7db9-6327-4e65-adb9-6151e498c7bb.png#averageHue=%23f3f1f1&amp;clientId=u29fb0314-bb32-4&amp;from=paste&amp;height=384&amp;id=ub00ec4f7&amp;originHeight=384&amp;originWidth=640&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=54841&amp;status=done&amp;style=none&amp;taskId=ue2e12ce0-498f-4436-88a7-1f2e8dc4c26&amp;title=&amp;width=640" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>分支控制指令是在ALU阶段进行了分支的比较并更新寄存器；第一个解决方案是我们把这个比较的过程提前到ID阶段执行，这样可以可以减少一个nop指令；对应的，我们需要新的硬件以及逻辑和控制信号设计，我们必须实现在ID阶段就可以更新PC</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1700110689060-466ec92c-f421-4ed7-bbbd-65866523218c.png#averageHue=%23f5f3f3&amp;clientId=u29fb0314-bb32-4&amp;from=paste&amp;height=465&amp;id=u53d898f0&amp;originHeight=465&amp;originWidth=955&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=77877&amp;status=done&amp;style=none&amp;taskId=u97964d72-f19f-4c61-9445-743eae74d7e&amp;title=&amp;width=955" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>然而这个解决方案带来了新的问题，我们在beq指令的ID阶段就要t0的值，但现在这个值拿不到。</li>
<li>传统的流水线设计中，分支决策通常是在执行（EX）阶段完成的。这样，当add指令在EX阶段产生结果时，后续的beq指令还没有进入到ID阶段，因此不存在需要数据前送的情况。beq指令会在add指令完成后的下一个流水线阶段自然地等待它需要的数据。但是，如果分支决策被提前到ID阶段，如上一张PPT所建议的，那么beq指令会更早地需要t0的值，而这个值此时还在add指令的流水线阶段中被计算。这就导致了一个数据危害，因为beq指令需要的数据还没有准备好，我们必须在流水线中插入暂停（stall），直到add指令的结果变得可用。因此，只有在我们采取减少分支延迟危害的措施（如提前分支决策到ID阶段）时，这个数据危害才会出现。这也表明，任何对流水线架构的改进都需要综合考虑，因为改进的同时可能会引入新的问题.</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1700111492565-555aad81-477b-4769-9b22-8fb3c71162f7.png#averageHue=%23eeecec&amp;clientId=u29fb0314-bb32-4&amp;from=paste&amp;height=491&amp;id=uf7fbdfd0&amp;originHeight=491&amp;originWidth=1109&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=88237&amp;status=done&amp;style=none&amp;taskId=u7510ce08-c03f-4dfa-a80c-ceae2c7292d&amp;title=&amp;width=1109" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>似乎看起来无论如何，我们都需要等一段时间，或者加入一些新的硬件，在RISC-V中，我们采用了一种新的方式，分支预测。
<ul>
<li>分支预测就是猜PC的值，如果猜对了，那我们不需要任何的停顿；猜错了，那就清空pipline，从跳转指令的下一条继续执行；更详细的东西参照CS152。</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1700113062140-31d6ca35-3088-4dfd-88b8-a73e37bdd5d4.png#averageHue=%23f4f4f3&amp;clientId=u29fb0314-bb32-4&amp;from=paste&amp;height=477&amp;id=ud434e4e5&amp;originHeight=477&amp;originWidth=1154&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=54802&amp;status=done&amp;style=none&amp;taskId=ud63a6771-647e-495a-a1f0-6bd4011ba39&amp;title=&amp;width=1154" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>看起来选C，而实际上应该选A
<ul>
<li>lw
指令从内存中加载了一个字到t0中，这意味着我们对内存进行了操作，也就是结果最早也只能在DM阶段获得，而指令完整的结果将会在第五个阶段才会写到t0寄存器里；
<ul>
<li><code>IF</code> -&gt;<code>ID</code>-&gt; <code>ALU</code>-&gt;
<code>DM</code>-&gt; <code>Reg</code>-&gt;
(任意一个阶段只有在-&gt;才会执行完成）</li>
<li><pre><code class="hljs">          nop    `IF`-&gt; `ID`-&gt;  `ALU`-&gt; `DM` -&gt;`Reg` -&gt; （把DM的值通过后向传递直接给ALU）</code></pre>
<h2 id="spuerscalar-processors">spuerscalar processors</h2></li>
</ul></li>
</ul></li>
<li>为了更好的效能，我们可以：
<ul>
<li>提高时钟频率 - 受制于发热，能耗，科技，不能再高了</li>
<li>流水线 -
可以把流水线加深，但要处理更多的hazards问题，以及更多的硬件支持，这可能会增高CPI</li>
<li>超标程，这也是现代CPU的特点</li>
</ul></li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1700117827609-08746fe7-1d88-4557-b658-05a1aeab6a10.png#averageHue=%23f6f4f3&amp;clientId=u29fb0314-bb32-4&amp;from=paste&amp;height=651&amp;id=u7f02ea14&amp;originHeight=651&amp;originWidth=1039&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=113954&amp;status=done&amp;style=none&amp;taskId=u9ad5f900-2662-42bb-9204-98ba39e1d5e&amp;title=&amp;width=1039" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>同一时间多条指令同时执行，汇总结果，添加许多计算单元</li>
</ul>
<h1 id="lecture-15-memory-caches-fully-associative-cache">Lecture 15
Memory &amp; Caches &amp; Fully Associative Cache</h1>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1700143593897-d7bb3b01-8d36-41aa-be60-5bbd3416db23.png#averageHue=%23f9f9f9&amp;clientId=u9c1773a6-8481-4&amp;from=paste&amp;height=561&amp;id=u6c629770&amp;originHeight=561&amp;originWidth=1067&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=80028&amp;status=done&amp;style=none&amp;taskId=u99bd636b-d419-4d9c-a91e-c1354d4ea15&amp;title=&amp;width=1067" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><p>内存地址就是数，只不过是16进制的</p></li>
<li><p>数据从来不会包含在16进制的地址中，16进制的地址仅仅只是标识不同的地址，真正的数据存在别的地方，它的大小，其实就是我们说的按Byte寻址的Byte</p></li>
<li><p>Caches的存在根源在于局部性原理的作用</p>
<ul>
<li>时间局部性原理：当前访问过的指令或者数据，在下一时间还有可能被访问到</li>
<li>空间局部性原理：当前某个范围的指令或者数据，在下一时间还有可能被访问到
<ul>
<li>我们将<strong>一段连续的地址空间称之为Block</strong>，局部性原理的作用告诉我们，一小段时间的访问可能集中在某个很小的地址范围内，我们的Block则可能囊括了这个地址空间，也就意味着我们不需要造一个和内存一样贵而大的存储介质，通过造一个很小容量的存储介质，就可以加速CPU执行指令的速度。</li>
</ul></li>
</ul></li>
<li><p>Caches的设计伴随着四个重要的问题</p>
<ul>
<li>我们怎么把内存中的block data放到caches里？</li>
<li>我们怎么知道内存中的某个block data早已经在caches里了？</li>
<li>我们怎么快速的找到我们需要的某个block data？</li>
<li>如果我们的caches满了，那我们怎么办？</li>
</ul></li>
<li><p>Blocks一般是没有固定的大小的，但一般会用字大小来描述（32位）</p></li>
<li><p>Caches的大小一般也用字（Bytes）来描述</p></li>
<li><p>对于FA的Cache，空间利用率很高，不存在对齐的概念，任意部分的内存都可以存到任意Slot里</p></li>
</ul>
<h2 id="where-do-we-put-a-block-of-data-from-memory">Where do we put a
block of data from memory?</h2>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1700143961419-ac037d15-6bbc-4808-8e3f-c05eeb11b00f.png#averageHue=%23faf8f8&amp;clientId=u9c1773a6-8481-4&amp;from=paste&amp;height=547&amp;id=ube672b5a&amp;originHeight=547&amp;originWidth=647&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=83136&amp;status=done&amp;style=none&amp;taskId=uebf6bcfd-ccd8-474a-93fd-a407215a6cf&amp;title=&amp;width=647" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><p>我们的数据以Block的形式放在Cache中的某个硬件组成（Data
Block）</p>
<ul>
<li>缓存有多少Block，这种硬件就有多少个</li>
<li>每个Data Block都存储了内存中的一段连续内容 ## How do we know if a
block is already in cache? <img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1700288900615-76646d1d-7d21-4f44-b753-c0013f1fbee4.png#averageHue=%23faf9f9&amp;clientId=u5feb84ce-0875-4&amp;from=paste&amp;height=550&amp;id=u5ef2bdc7&amp;originHeight=1100&amp;originWidth=1332&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=238225&amp;status=done&amp;style=none&amp;taskId=u5a7ce431-e7e6-412b-92c7-fe96ce38586&amp;title=&amp;width=666" srcset="/img/loading.gif" lazyload
alt="image.png" /></li>
</ul></li>
<li><p>每当需要从内存中取数据时，这段地址会被解析为两部分；Offset部分会用作MUX部分用于选择偏移量，Tag则用于匹配具体的内存，V则会标志这个字或者是Byte是不是垃圾信号；
## How do we quickly find a block when we need it?</p></li>
<li><p>这个电路在时间上是并行进行地址匹配的 ## When do we replace
something in the cache?</p></li>
<li><p>常用的就是LRU</p></li>
</ul>
<h2 id="fa--cache">FA- Cache</h2>
<ul>
<li>总bits表示
<ul>
<li><span class="math inline">\(\frac{Cache\ Size(Byte)}{num \
block}*(8*2^{Offset}+Tag+1+?)\)</span>
<ul>
<li>8代表了我们Cache最基本的大小Byte，一个Byte是8位，因此<span
class="math inline">\(8*2^{Offset}\)</span>就表示了我们的一个缓存块需要多少位，<span
class="math inline">\(2^{Offset}\)</span>则代表我们的一个缓存块有多少字节</li>
<li>Tag其实就是内存地址的高位，用于确定到底是内存中的哪个Block</li>
<li>1是是否垃圾新的标志位</li>
<li>？存储一些额外的Bits例如LRUBits</li>
</ul></li>
</ul></li>
</ul>
<h2 id="cache-access">Cache Access</h2>
<ul>
<li>到目前似乎一切都看起来很好，但实际上我们回避了一个重要的问题，Cache的写以及由此引发的问题</li>
</ul>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1700295420849-395dcedd-268f-4e1d-b7bc-3edf482fe1d9.png#averageHue=%23efefef&amp;clientId=u5feb84ce-0875-4&amp;from=paste&amp;height=368&amp;id=ubc637d4c&amp;originHeight=736&amp;originWidth=1020&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=51692&amp;status=done&amp;style=none&amp;taskId=uc7647aca-74ed-4d6c-9f95-fdf2e2e2722&amp;title=&amp;width=510" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>Cache是独立于内存的，但是它有独立的数据吗？
<ul>
<li>没有，但是Cache的数据版本和RAM可能是不一致的，为了处理这个问题，我们需要一定的规范</li>
</ul></li>
<li>Cache现代一般会分为两部分，一部分是指令的的缓存I<span
class="math inline">\(，一部分是数据的缓存\)</span>D，两者都允许读，但是只有<span
class="math inline">\(D允许写，因此我们常说的缓存和主存一执性问题主要体现在\)</span>D上(I$也意味着自修改代码，在这里我们会忽略掉它）</li>
</ul>
<h3 id="cache-write-hits">Cache Write hits</h3>
<ul>
<li><p>对于Cache Read hits我们总希望它命中，对于写则不一定</p></li>
<li><p><strong>Write-Through Policy</strong></p>
<ul>
<li>这种策略要求我们每次的写操作都需要我们同时写到Cache和RAM中，这种方法保证了Cache和RAM的一致性，消除了不同版本的数据，但速度很慢，因为RAM很慢（我们在说Write
though policy时一般都会假定Write
Buffer的存在，也就意味着处理器可以不需要等待完整的写操作）</li>
</ul></li>
<li><p><strong>Write-Back Policy</strong></p>
<ul>
<li>这种策略的写会优先写到缓存里，当且仅当缓存中的数据要被淘汰掉时，才会写入到内存中。另外也不是所有的缓存中被淘汰掉的内容会被写到内存中，当且仅当发生了Write-Hits
（脏）的数据在被淘汰的时候，才会写入到内存。</li>
</ul></li>
</ul>
<h3 id="cache-wirte-miss">Cache Wirte miss</h3>
<ul>
<li><strong>未命中惩罚</strong>随着块大小的增加而增加，因为需要移动更多的数据。</li>
</ul>
<ol type="1">
<li><strong>读取未命中（I$ 和 D$）</strong>：
<ul>
<li>执行被暂停，从内存中取出数据块，放入缓存，然后恢复执行。</li>
</ul></li>
<li><strong>写入未命中（D$）</strong>：
<ul>
<li>总是需要从内存中更新块。</li>
<li>在这种情况下需要做出选择：
<ul>
<li>是否将更新后的块载入缓存中，这取决于所采用的具体策略和系统的设计。</li>
<li><strong>Write
Allocate策略</strong>：在写入未命中后，将数据块带入缓存。这意味着当尝试写入一个不在缓存中的地址时，首先将对应的内存块加载到缓存中，然后在缓存中进行写操作。这种策略通常与写回（Write-Back）策略结合使用。如果某个内存地址会被频繁访问和修改，那么将其加载到缓存中可以减少未来对该地址的写入操作对性能的影响。</li>
<li><strong>No Write
Allocate策略</strong>：在写入未命中后，不将数据块带入缓存，而只是修改主内存中的数据。这种策略通常与写通（Write-Through）策略结合使用。对于不太频繁或随机的写入操作，这种策略可以避免缓存的不必要更新，因为这些数据可能不会再被需要，所以没有必要将它们载入缓存。
# Lab ## Lab 0</li>
</ul></li>
</ul></li>
</ol>
<ul>
<li>常用的Cli快捷键
<ul>
<li><code>ctrl+u</code> 删除整行</li>
<li><code>ctrl+a</code> 移动到行首</li>
<li><code>ctrl+e</code> 移动到行尾</li>
<li><code>ctrl+r</code> 查询近期的命令<br />
</li>
</ul></li>
<li>文件操作
<ul>
<li>创建一个空文件 <code>touch a.txt</code></li>
<li>写入一些内容 <code>echo "hello world" &gt; a.txt</code></li>
<li>查看文件内容 <code>cat a.txt</code></li>
<li>比较两个文件内容的差别 <code>diff a b</code></li>
</ul></li>
<li>查看命令手册，以echo为例
<ul>
<li><code>man echo | less</code></li>
</ul></li>
<li>Vim</li>
<li>Git</li>
</ul>
<h2 id="lab-1">Lab 1</h2>
<ul>
<li><p>task1 通过修改eccentric.c中的宏得到如下的输出 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Berkeley eccentrics:<br>====================<br>Happy Happy Happy<br>Yoshua<br>Go BEARS!<br></code></pre></td></tr></table></figure>
没什么难度，就是又忘了gcc咋编译了 <img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1697976846675-2f8a02bc-3ecb-487e-a606-68d01a7e5796.png#averageHue=%23252525&amp;clientId=ufd2320c2-d23e-4&amp;from=paste&amp;height=110&amp;id=u99adfdbe&amp;originHeight=220&amp;originWidth=936&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=46345&amp;status=done&amp;style=none&amp;taskId=u99be2b0a-29fb-4fe6-a937-7e08d7eac1a&amp;title=&amp;width=468" srcset="/img/loading.gif" lazyload
alt="image.png" /></p></li>
<li><p>task2 用gdb</p></li>
</ul>
<ol type="1">
<li><p>While you’re in a gdb session, how do you <strong>set the
arguments</strong> that will be passed to the program when it’s
run?</p></li>
<li><p>How do you <strong>create a breakpoint</strong>?</p></li>
<li><p>How do you <strong>execute the next line of C code</strong> in
the program after stopping at a breakpoint?</p></li>
<li><p>If the next line of code is a function call, you’ll execute the
whole function call at once if you use your answer to #3. (If not,
consider a different command for #3!) How do you tell GDB that you
<strong>want to debug the code inside the function</strong> (i.e. step
into the function) instead? (If you changed your answer to #3, then that
answer is most likely now applicable here.)</p></li>
<li><p>How do you <strong>continue the program after stopping</strong>
at a breakpoint?</p></li>
<li><p>How can you <strong>print the value of a variable</strong> (or
even an expression like 1+2) in gdb?</p></li>
<li><p>How do you configure gdb so it <strong>displays the value of a
variable after every step</strong>?</p></li>
<li><p>How do you <strong>show a list of all variables and their
values</strong> in the current function?</p></li>
<li><p>How do you <strong>quit</strong> out of gdb?</p></li>
<li><p>use <code>set args arg1 arg2 arg3</code></p></li>
<li><p>use <code>break file.c:2</code></p></li>
<li><p><code>step</code> or <code>next</code>, but for stander fuc like
"printf" ,do not use step but next, cz stander func has no source code,
major of cases they are very low-level</p></li>
<li><p><code>step</code></p></li>
<li><p><code>continue</code></p></li>
<li><p><code>print a+b</code> and a or b respents the real
variables.</p></li>
<li><p>use <code>display a</code>, and <code>undisplay a</code>
cancel.</p></li>
<li><p><code>info locals</code></p></li>
<li><p><code>exit</code></p></li>
</ol>
<ul>
<li><p>task3 重定向</p>
<ul>
<li>./task &lt; input.out</li>
<li>run &lt; input.out &gt; output.out</li>
</ul></li>
<li><p>task4 Valgrind</p></li>
<li><p>task5 回环链表 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ll_has_cycle</span><span class="hljs-params">(node *head)</span> &#123;<br>    node* fast = head;<br>    node* slow = head;<br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="lab-2">Lab 2</h2>
<ul>
<li>Makefile 解释</li>
</ul>
<ol type="1">
<li><p>Which target is part of a rule that deletes all the compiled
programs?</p></li>
<li><p>Which target is part of a rule that makes all the compiled
programs?</p></li>
<li><p>Which compiler is currently being used?</p></li>
<li><p>What C standard are we currently using?</p></li>
<li><p>How would we reference a variable FOO in a makefile?</p></li>
<li><p>What operating system does the term “Darwin” represent?</p></li>
<li><p>What line creates the lfsr program from its object files? (Give
its line number.)</p></li>
<li><p>删除所有已编译程序的规则的目标是
<code>clean</code>。它用于清理和删除生成的文件。</p></li>
<li><p>制作所有已编译程序的规则的目标是
<code>all</code>。这是默认目标，运行 <code>make</code>
而不指定目标将构建所有已编译程序。</p></li>
<li><p>当前正在使用的编译器是 <code>gcc</code>，如 <code>CC</code>
变量中所指定的。</p></li>
<li><p>当前正在使用的C标准是C99，如<code>CFLAGS</code>变量中的<code>-std=c99</code>标志所指定。</p></li>
<li><p>要在Makefile中引用变量 <code>FOO</code>，使用 <code>$(FOO)</code>
表示。</p></li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 1. Variables and conditionals</span><br>UNAME_S := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -s)</span><br>CC=gcc<br>LD=gcc<br>CFLAGS=-ggdb -Wall -std=c99<br>LDFLAGS=<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(UNAME_S)</span>, Darwin)<br>    MEMCHECK=valgrind --tool=memcheck --leak-check=full --track-origins=yes --dsymutil=yes --suppressions=osx_vector.supp<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(UNAME_S)</span>, Linux)<br>    MEMCHECK=valgrind --tool=memcheck --leak-check=full --track-origins=yes<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment"># 2. Targets and their object files</span><br>BIT_OPS_OBJS = bit_ops.o test_bit_ops.o<br>BIT_OPS_PROG = bit_ops<br><br>LFSR_OBJS = lfsr.o test_lfsr.o<br>LFSR_PROG = lfsr<br><br>VECTOR_OBJS=vector.o vector_test.o<br>VECTOR_PROG=vector_test<br><br>LIST_OBJS=test_list.o list.o<br>LIST_PROG=list<br><br>BINARIES=<span class="hljs-variable">$(VECTOR_PROG)</span> <span class="hljs-variable">$(BIT_OPS_PROG)</span> <span class="hljs-variable">$(LFSR_PROG)</span> <span class="hljs-variable">$(LIST_PROG)</span><br><br><span class="hljs-comment"># 3. Compilation and linking rules</span><br><span class="hljs-section">all: <span class="hljs-variable">$(BINARIES)</span></span><br><br><span class="hljs-variable">$(BIT_OPS_PROG)</span>: <span class="hljs-variable">$(BIT_OPS_OBJS)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -g -o <span class="hljs-variable">$(BIT_OPS_PROG)</span> <span class="hljs-variable">$(BIT_OPS_OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span><br><br><span class="hljs-variable">$(LFSR_PROG)</span>: <span class="hljs-variable">$(LFSR_OBJS)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -g -o <span class="hljs-variable">$(LFSR_PROG)</span> <span class="hljs-variable">$(LFSR_OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span><br><br><span class="hljs-variable">$(VECTOR_PROG)</span>: <span class="hljs-variable">$(VECTOR_OBJS)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -g -o <span class="hljs-variable">$(VECTOR_PROG)</span> <span class="hljs-variable">$(VECTOR_OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span><br><br><span class="hljs-variable">$(LIST_PROG)</span>: <span class="hljs-variable">$(LIST_OBJS)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -g -o <span class="hljs-variable">$(LIST_PROG)</span> <span class="hljs-variable">$(LIST_OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span><br><br><span class="hljs-section">.c.o:</span><br>	<span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">vector-memcheck: <span class="hljs-variable">$(VECTOR_PROG)</span></span><br>	<span class="hljs-variable">$(MEMCHECK)</span> ./<span class="hljs-variable">$(VECTOR_PROG)</span><br><br><span class="hljs-comment"># 4. Header dependencies</span><br><span class="hljs-section">lfsr.c: lfsr.h</span><br><span class="hljs-section">test_lfsr.c: lfsr.h</span><br><br><span class="hljs-section">bit_ops.c: bit_ops.h</span><br><span class="hljs-section">test_bit_ops.c: bit_ops.h</span><br><br><span class="hljs-section">vector.c: vector.h</span><br><span class="hljs-section">vector_test.c: vector.h</span><br><br><span class="hljs-section">list.c: list.h</span><br><span class="hljs-section">list_test.c: list.h</span><br><br><span class="hljs-comment"># 5. Other commands</span><br><span class="hljs-section">clean:</span><br>	-rm -rf core *.o *~ <span class="hljs-string">&quot;#&quot;</span>*<span class="hljs-string">&quot;#&quot;</span> Makefile.bak <span class="hljs-variable">$(BINARIES)</span> *.dSYM<br><br></code></pre></td></tr></table></figure>
<ol type="1">
<li><code>UNAME_S := $(shell uname -s)</code>：这一行使用<code>uname -s</code>命令来获取当前操作系统的名称，并将其保存在<code>UNAME_S</code>变量中。</li>
<li>定义一些编译器和编译选项的变量：</li>
</ol>
<ul>
<li><code>CC</code>：C编译器，设置为<code>gcc</code>。</li>
<li><code>LD</code>：链接器，也设置为<code>gcc</code>。</li>
<li><code>CFLAGS</code>：编译器选项，包括<code>-ggdb</code>（生成调试信息）、<code>-Wall</code>（显示警告）、<code>-std=c99</code>（使用C99标准）等。</li>
<li><code>LDFLAGS</code>：链接器选项，目前为空，可以用于添加链接选项。</li>
</ul>
<ol start="3" type="1">
<li>根据操作系统设置<code>MEMCHECK</code>变量，用于在不同操作系统上运行内存检查工具（Valgrind）时使用不同的选项。在Darwin（macOS）上，设置了一组选项，而在Linux上设置了另一组选项。</li>
<li>定义了三个目标的相关变量：</li>
</ol>
<ul>
<li><code>BIT_OPS_OBJS</code>：用于存储与位操作相关的目标文件的名称。</li>
<li><code>LFSR_OBJS</code>：用于存储与线性反馈移位寄存器相关的目标文件的名称。</li>
<li><code>VECTOR_OBJS</code>：用于存储与向量操作相关的目标文件的名称。</li>
</ul>
<ol start="5" type="1">
<li>定义了三个可执行程序的名称：</li>
</ol>
<ul>
<li><code>BIT_OPS_PROG</code>：位操作相关的可执行程序名称。</li>
<li><code>LFSR_PROG</code>：线性反馈移位寄存器相关的可执行程序名称。</li>
<li><code>VECTOR_PROG</code>：向量操作相关的可执行程序名称。</li>
</ul>
<ol start="6" type="1">
<li>定义了一个包含所有可执行程序名称的变量<code>BINARIES</code>。</li>
<li><code>all: $(BINARIES)</code>：这是默认目标，表示运行<code>make</code>命令时将构建所有的可执行程序。</li>
<li>下面是各个可执行程序的构建规则。每个规则指定了可执行程序的依赖项（目标文件）和如何构建它们。例如，<code>$(BIT_OPS_PROG)</code>的构建规则包括将<code>$(BIT_OPS_OBJS)</code>链接到一起，然后使用指定的编译器和选项生成可执行文件。</li>
<li>下面的规则用于生成目标文件（.o文件）：<code>.c.o:</code>。它告诉Make如何将C源文件编译成目标文件。它使用了<code>$(CC)</code>和<code>$(CFLAGS)</code>变量来执行编译。</li>
<li><code>vector-memcheck: $(VECTOR_PROG)</code>：这是一个自定义的目标，用于运行Valgrind内存检查工具来测试<code>$(VECTOR_PROG)</code>程序。</li>
<li><code>clean:</code>：这是一个用于清理项目的目标。它删除生成的可执行文件、目标文件、临时文件等。<code>-rm</code>表示即使文件不存在也不会生成错误消息，因此可以安全地删除文件。</li>
<li>最后，有一些依赖关系规则，用于确保源文件（.c文件）与相关的头文件（.h文件）之间的一致性。</li>
</ol>
<p>通过在命令行中运行<code>make</code>并选择目标，可以构建可执行程序，运行内存检查，或者执行清理操作，具体取决于需求。例如，要构建所有的可执行程序，只需运行<code>make</code>。要运行<code>vector_test</code>的内存检查，可以运行<code>make vector-memcheck</code>。要清理项目，可以运行<code>make clean</code>。</p>
<ul>
<li>Bit operations
<ul>
<li>只能用&amp;，^，以及 ｜</li>
<li>不能循环，不能除法，不能取模 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bit_ops.h&quot;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> mp[<span class="hljs-number">32</span>] = &#123;<br>    <span class="hljs-number">0x80000000</span>,<br>    <span class="hljs-number">0x40000000</span>,<br>    <span class="hljs-number">0x20000000</span>,<br>    <span class="hljs-number">0x10000000</span>,<br>    <span class="hljs-number">0x08000000</span>,<br>    <span class="hljs-number">0x04000000</span>,<br>    <span class="hljs-number">0x02000000</span>,<br>    <span class="hljs-number">0x01000000</span>,<br>    <span class="hljs-number">0x00800000</span>,<br>    <span class="hljs-number">0x00400000</span>,<br>    <span class="hljs-number">0x00200000</span>,<br>    <span class="hljs-number">0x00100000</span>,<br>    <span class="hljs-number">0x00080000</span>,<br>    <span class="hljs-number">0x00040000</span>,<br>    <span class="hljs-number">0x00020000</span>,<br>    <span class="hljs-number">0x00010000</span>,<br>    <span class="hljs-number">0x00008000</span>,<br>    <span class="hljs-number">0x00004000</span>,<br>    <span class="hljs-number">0x00002000</span>,<br>    <span class="hljs-number">0x00001000</span>,<br>    <span class="hljs-number">0x00000800</span>,<br>    <span class="hljs-number">0x00000400</span>,<br>    <span class="hljs-number">0x00000200</span>,<br>    <span class="hljs-number">0x00000100</span>,<br>    <span class="hljs-number">0x00000080</span>,<br>    <span class="hljs-number">0x00000040</span>,<br>    <span class="hljs-number">0x00000020</span>,<br>    <span class="hljs-number">0x00000010</span>,<br>    <span class="hljs-number">0x00000008</span>,<br>    <span class="hljs-number">0x00000004</span>,<br>    <span class="hljs-number">0x00000002</span>,<br>    <span class="hljs-number">0x00000001</span><br>    &#125;;<br><br><span class="hljs-comment">// Return the nth bit of x.</span><br><span class="hljs-comment">// Assume 0 &lt;= n &lt;= 31</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">get_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> x,<span class="hljs-type">unsigned</span> n)</span>&#123;<br>    n = <span class="hljs-number">31</span> - n;<br><br>    <span class="hljs-keyword">if</span>((x &amp; mp[n])!=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// Set the nth bit of the value of x to v.</span><br><span class="hljs-comment">// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">set_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> * x,</span><br><span class="hljs-params">             <span class="hljs-type">unsigned</span> n,</span><br><span class="hljs-params">             <span class="hljs-type">unsigned</span> v)</span> &#123;<br>    n = <span class="hljs-number">31</span> - n;<br>    <span class="hljs-type">unsigned</span> mpn = mp[n];<br>    <span class="hljs-keyword">if</span>(v == <span class="hljs-number">0</span>)&#123;<br>        mpn = mpn ^ <span class="hljs-number">0xFFFFFFFF</span>;<br>        *x = *x &amp; mpn;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v == <span class="hljs-number">1</span>)<br>        *x = *x | mpn;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-comment">// Flip the nth bit of the value of x.</span><br><span class="hljs-comment">// Assume 0 &lt;= n &lt;= 31</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">flip_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> * x,</span><br><span class="hljs-params">              <span class="hljs-type">unsigned</span> n)</span> &#123;<br>    <span class="hljs-type">unsigned</span> flipped_value = get_bit(*x, n) ^ <span class="hljs-number">1</span>;<br>    set_bit(x, n, flipped_value);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul></li>
<li>LSFR
线性反馈移位寄存器线性反馈移位寄存器（LFSR）是数字系统中的一种常见结构，它具有多种应用：</li>
</ul>
<ol type="1">
<li><strong>伪随机数生成器 (PRNG)</strong>：LFSR
是一种有效的方式来生成伪随机数序列。由于其固定的结构和特性，它可以在硬件中非常高效地实现，而不需要大量的存储空间或复杂的算法。</li>
<li><strong>测试模式生成</strong>：在硬件测试中，LFSR
常用于生成测试模式，特别是在内存和逻辑电路的内建自测 (BIST, Built-In
Self-Test) 中。</li>
<li><strong>数据加密和解密</strong>：由于其伪随机性，LFSR
可以用于流密码中的密钥流生成。它们生成的位流可以与数据流进行异或操作来加密或解密信息。</li>
<li><strong>误差检测和纠正</strong>：LFSR 可用于生成和检测多项式编码，如
CRC (循环冗余检查)。这些编码用于检测数据传输中的错误。</li>
<li><strong>数字通信</strong>：LFSR
用于扩频通信技术，例如直接序列扩频。</li>
<li><strong>信号扩展</strong>：在某些应用中，LFSR
可用于将较短的信号序列扩展为更长的序列。</li>
</ol>
<figure>
<img
src="https://cdn.nlark.com/yuque/0/2023/png/22918222/1698041210599-1419aaee-d528-4a88-a670-e0fe151453dc.png#averageHue=%230f0e0e&amp;clientId=uaef816b2-9c2c-4&amp;from=paste&amp;height=94&amp;id=udd797765&amp;originHeight=188&amp;originWidth=624&amp;originalType=binary&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;size=9768&amp;status=done&amp;style=none&amp;taskId=u0ba0d908-663b-40c8-869b-3f927433a24&amp;title=&amp;width=312" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lfsr_calculate</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> *reg)</span> &#123;<br>    <span class="hljs-type">short</span> loc[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">uint16_t</span> fill = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;<br>        fill ^= (*reg &gt;&gt; loc[i]) &amp; <span class="hljs-number">1</span>;<br>    &#125;<br>    *reg = *reg &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(fill == <span class="hljs-number">1</span>)&#123;<br>        *reg = *reg | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>);<br>    &#125;<br>    <span class="hljs-comment">// 不需要填充0，因为向右移位操作已经为最左边的位设置了0</span><br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>LinkList
<ul>
<li>太熟悉了直接放代码</li>
<li>想一下为什么传指针时是<code>**p</code>而不是<code>*p</code>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Add a node to the end of the linked list. Assume head_ptr is non-null. */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append_node</span><span class="hljs-params">(node** head_ptr, <span class="hljs-type">int</span> new_data)</span> </span>&#123;<br>    node *new_node = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(node));  <span class="hljs-comment">// 更改变量名为new_node</span><br>    <span class="hljs-keyword">if</span> (new_node == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 处理内存分配失败的情况，例如返回或退出</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    new_node-&gt;val = new_data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (*head_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>        *head_ptr = new_node;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    node* curr = *head_ptr;<br>    <span class="hljs-keyword">while</span> (curr-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        curr = curr-&gt;next;<br>    &#125;<br>    curr-&gt;next = new_node;  <span class="hljs-comment">// 连接新节点到链表的尾部</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Reverse a linked list in place (in other words, without creating a new list).</span><br><span class="hljs-comment">   Assume that head_ptr is non-null. */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse_list</span> <span class="hljs-params">(node** head_ptr)</span> </span>&#123;<br>        node* prev = <span class="hljs-literal">NULL</span>;<br>        node* curr = *head_ptr;<br>        node* next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(curr==<span class="hljs-literal">NULL</span> || curr-&gt;next == <span class="hljs-literal">NULL</span>)<br>          <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">NULL</span>) &#123;<br>                next = curr-&gt;next;<br>                curr-&gt;next = prev;<br>                prev = curr;<br>                curr = next;<br>        &#125;<br>        <span class="hljs-comment">/* Set the new head to be what originally was the last node in the list */</span><br>        *head_ptr = prev;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>vector <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CS61C_VECTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CS61C_VECTOR_H_</span><br><span class="hljs-comment">/* vector.h originally written by Jeremy Huddleston &lt;jeremyhu@eecs.berkeley.edu&gt; Sp2004</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * So it looks like you&#x27;ve decided to venture into the &quot;other&quot; files of this</span><br><span class="hljs-comment"> * lab.  Good.  C Header files (the .h extension) are a way of telling other .c</span><br><span class="hljs-comment"> * files what they can have access to.  You usually include stdlib.h in your</span><br><span class="hljs-comment"> * C programs, and this process is identical to including this .h file with the</span><br><span class="hljs-comment"> * one change being:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * #include &quot;file.h&quot;</span><br><span class="hljs-comment"> * versus</span><br><span class="hljs-comment"> * #include &lt;file.h&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The difference is that the &lt;&gt; notation is for system header files and the &quot;&quot;</span><br><span class="hljs-comment"> * is for ones you provide yourself (in your local directory for instance).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The header file starts off with</span><br><span class="hljs-comment"> * #ifndef CS61C_VECTOR_H_</span><br><span class="hljs-comment"> * #define CS61C_VECTOR_H_</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * and ends with a final #endif.  This prevents the file from being included</span><br><span class="hljs-comment"> * more than once which could&#x27;ve possibly resulted in an infinite loop of</span><br><span class="hljs-comment"> * file inclusions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * First, we define the &#x27;vector_t&#x27; datatype.  This next line says that a &#x27;vector_t&#x27;</span><br><span class="hljs-comment"> * is the same as a &#x27;struct vector_t&#x27;.  So anywhere in the code after this, we</span><br><span class="hljs-comment"> * can use &#x27;vector_t *&#x27; to mean a pointer to a &#x27;struct vector_t&#x27; (which is defined in</span><br><span class="hljs-comment"> * vector.c).  We can get away with doing this even though we don&#x27;t know what a</span><br><span class="hljs-comment"> * struct vector is because all struct pointers have the same representation in memory.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vector_t</span> <span class="hljs-title">vector_t</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  Next, we provide the prototypes for the functions defined in vector.c.  This</span><br><span class="hljs-comment"> *  is a way of telling the .c files that #include this header what they will</span><br><span class="hljs-comment"> *  have access to.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Create a new vector */</span><br><span class="hljs-type">vector_t</span> *<span class="hljs-title function_">vector_new</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">/* Free up the memory allocated for the passed vector */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vector_delete</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v)</span>;<br><br><span class="hljs-comment">/* Return the value in the vector */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vector_get</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc)</span>;<br><br><span class="hljs-comment">/* Set a value in the vector */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vector_set</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc, <span class="hljs-type">int</span> value)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Include the system headers we need */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">/* Include our header */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.h&quot;</span></span><br><br><span class="hljs-comment">/* Define what our struct is */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vector_t</span> &#123;<br>    <span class="hljs-type">size_t</span> size;<br>    <span class="hljs-type">int</span> *data;<br>&#125;;<br><br><span class="hljs-comment">/* Utility function to handle allocation failures. In this</span><br><span class="hljs-comment">   case we print a message and exit. */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">allocation_failed</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Out of memory.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/* Bad example of how to create a new vector */</span><br><span class="hljs-function"><span class="hljs-type">vector_t</span> *<span class="hljs-title">bad_vector_new</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//这段代码在栈上创建了一个vector，而返回的内存地址会在函数执行完后销毁</span><br>    <span class="hljs-comment">/* Create the vector and a pointer to it */</span><br>    <span class="hljs-type">vector_t</span> *retval, v;<br>    retval = &amp;v;<br><br>    <span class="hljs-comment">/* Initialize attributes */</span><br>    retval-&gt;size = <span class="hljs-number">1</span>;<br>    retval-&gt;data = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (retval-&gt;data == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">allocation_failed</span>();<br>    &#125;<br><br>    retval-&gt;data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br><br><span class="hljs-comment">/* Another suboptimal way of creating a vector */</span><br><span class="hljs-comment">// 同样的，在栈上创建了一个vector</span><br><span class="hljs-function"><span class="hljs-type">vector_t</span> <span class="hljs-title">also_bad_vector_new</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/* Create the vector */</span><br>    <span class="hljs-type">vector_t</span> v;<br><br>    <span class="hljs-comment">/* Initialize attributes */</span><br>    v.size = <span class="hljs-number">1</span>;<br>    v.data = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (v.data == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">allocation_failed</span>();<br>    &#125;<br>    v.data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-comment">/* Create a new vector with a size (length) of 1</span><br><span class="hljs-comment">   and set its single component to zero... the</span><br><span class="hljs-comment">   RIGHT WAY */</span><br><span class="hljs-function"><span class="hljs-type">vector_t</span> *<span class="hljs-title">vector_new</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/* Declare what this function will return */</span><br>    <span class="hljs-type">vector_t</span> *retval;<br><br>    <span class="hljs-comment">/* First, we need to allocate memory on the heap for the struct */</span><br>    retval = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">vector_t</span>));<br><br>    <span class="hljs-comment">/* Check our return value to make sure we got memory */</span><br>    <span class="hljs-keyword">if</span> (retval == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">allocation_failed</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* Now we need to initialize our data.</span><br><span class="hljs-comment">       Since retval-&gt;data should be able to dynamically grow,</span><br><span class="hljs-comment">       what do you need to do? */</span><br>    retval-&gt;size = <span class="hljs-number">1</span>;<br>    retval-&gt;data = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* Check the data attribute of our vector to make sure we got memory */</span><br>    <span class="hljs-keyword">if</span> (retval-&gt;data == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">free</span>(retval);				<span class="hljs-comment">//Why is this line necessary?</span><br>        <span class="hljs-built_in">allocation_failed</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* Complete the initialization by setting the single component to zero */</span><br>    retval-&gt;data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* and return... */</span><br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br><br><span class="hljs-comment">/* Return the value at the specified location/component &quot;loc&quot; of the vector */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vector_get</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc)</span> </span>&#123;<br><br>    <span class="hljs-comment">/* If we are passed a NULL pointer for our vector, complain about it and exit. */</span><br>    <span class="hljs-keyword">if</span>(v == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;vector_get: passed a NULL vector.\n&quot;</span>);<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* If the requested location is higher than we have allocated, return 0.</span><br><span class="hljs-comment">     * Otherwise, return what is in the passed location.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (loc &lt; v-&gt;size) &#123;<br>	<span class="hljs-keyword">return</span> v-&gt;data[loc];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* Free up the memory allocated for the passed vector.</span><br><span class="hljs-comment">   Remember, you need to free up ALL the memory that was allocated. */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vector_delete</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(v-&gt;data);<br>    <span class="hljs-built_in">free</span>(v);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* Set a value in the vector. If the extra memory allocation fails, call</span><br><span class="hljs-comment">   allocation_failed(). */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vector_set</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-comment">/* What do you need to do if the location is greater than the size we have</span><br><span class="hljs-comment">     * allocated?  Remember that unset locations should contain a value of 0.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span>(loc &lt; v-&gt;size) &#123;<br>        v-&gt;data[loc] = value;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> *new_data = <span class="hljs-built_in">realloc</span>(v-&gt;data, (loc + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span>(!new_data) &#123;<br>            <span class="hljs-built_in">allocation_failed</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = v-&gt;size; i &lt;= loc; i++) &#123;<br>            new_data[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        v-&gt;data = new_data;<br>        v-&gt;size = loc + <span class="hljs-number">1</span>;<br>        v-&gt;data[loc] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="lab-3">Lab 3</h2>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/">#笔记</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>cs16c</div>
      <div>http://shuaizhang1998.github.io/2023/11/19/CS61C_ Great Ideas in Computer Architecture/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zs</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月19日</div>
        </div>
      
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/30/Introductory%20C%20Programming%20Specialization/" title="c/c++">
                        <span class="hidden-mobile">c/c++</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
