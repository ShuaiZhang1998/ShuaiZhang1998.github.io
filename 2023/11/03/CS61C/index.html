

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zs">
  <meta name="keywords" content="">
  
    <meta name="description" content="课程网站：https:&#x2F;&#x2F;cs61c.org&#x2F;su20&#x2F; B 站 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1fC4y147iZ&#x2F;?vd_source&#x3D;518199b8942410d3723d3db827513479 https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list&#x3D;PLDoI-XvXO0aqgoMQvogzmf7CKiSMSUS3M https">
<meta property="og:type" content="article">
<meta property="og:title" content="cs16c">
<meta property="og:url" content="http://shuaizhang1998.github.io/2023/11/03/CS61C/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="课程网站：https:&#x2F;&#x2F;cs61c.org&#x2F;su20&#x2F; B 站 https:&#x2F;&#x2F;www.bilibili.com&#x2F;video&#x2F;BV1fC4y147iZ&#x2F;?vd_source&#x3D;518199b8942410d3723d3db827513479 https:&#x2F;&#x2F;www.youtube.com&#x2F;playlist?list&#x3D;PLDoI-XvXO0aqgoMQvogzmf7CKiSMSUS3M https">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-11-02T16:00:30.765Z">
<meta property="article:modified_time" content="2023-11-02T16:13:45.622Z">
<meta property="article:author" content="Zs">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>cs16c - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shuaizhang1998.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="cs16c"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-03 00:00" pubdate>
          2023年11月3日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          30k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          250 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">cs16c</h1>
            
            
              <div class="markdown-body">
                
                <ul>
<li>课程网站：<a
target="_blank" rel="noopener" href="https://cs61c.org/su20/">https://cs61c.org/su20/</a></li>
<li>B 站 <a
target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1fC4y147iZ/?vd_source=518199b8942410d3723d3db827513479">https://www.bilibili.com/video/BV1fC4y147iZ/?vd_source=518199b8942410d3723d3db827513479</a></li>
<li><a
target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLDoI-XvXO0aqgoMQvogzmf7CKiSMSUS3M">https://www.youtube.com/playlist?list=PLDoI-XvXO0aqgoMQvogzmf7CKiSMSUS3M</a></li>
<li><a
target="_blank" rel="noopener" href="https://github.com/PKUFlyingPig/CS61C-summer20/tree/master/slides">https://github.com/PKUFlyingPig/CS61C-summer20/tree/master/slides</a></li>
</ul>
<h1 id="lecture-1---number-representation">Lecture 1 - Number
Representation</h1>
<ul>
<li><p>numbers representate everything</p>
<p>数字可以表示任何东西，只需要对其赋予意义，例如对于1-10来说</p>
<ul>
<li>可以代表10个正数</li>
<li>可以代表10个不同的东西</li>
<li>....</li>
</ul></li>
<li><p>为什么使用二进制</p>
<ul>
<li>涉及到电气的特性，2进制信号可以简单的用高低电平来表示，这提供了更大的容错率，在一定的电压区间中，进制越高，错误率越高。</li>
<li><span class="math inline">\(C_{10} = a[n-1] \cdot r^{n-1} + a[n-2]
\cdot r^{n-2} + \ldots + a[0] \cdot r^0\)</span> <span
class="math inline">\(r\)</span>代表<span
class="math inline">\(r\)</span>进制</li>
<li><span class="math inline">\(1011 = 1*2^0+1*2^1+0+1*2^3\)</span></li>
</ul></li>
<li><p>怎么表示有符号数</p>
<ul>
<li>Sign and Magnitude （符号-幅度 原码）
<ul>
<li>最高位代表符号位，其余位代表数值，缺点是（同时存在两种0：<code>100</code>
= <code>000</code>)</li>
</ul></li>
<li>Biased Notation （偏置法）
<ul>
<li>思想就是定义域的移动，选取某个正区间中的某个数作为<code>0</code><br />
</li>
</ul></li>
<li>One‘s Complement （1补数 反码）
<ul>
<li>同样使得最高位代表符号位，最大正数为<code>0111...111</code>,最小负数为<code>100...000</code>,同样存在两个<code>0</code>（<code>000 = 111</code>），有溢出问题(循环移位）</li>
</ul></li>
<li>Two‘s Complement <strong>（2补数 补码）</strong>
<ul>
<li>现在都在用的，处理溢出问题比较简单（<code>++ -&gt; -</code>
<code>-- -&gt; +</code> <code>+(-)- -&gt; -</code>
<code>-(-)+ -&gt;+</code>，现代处理器检查溢出标志位</li>
<li><code>111...111</code>不在代表<code>0</code>而是代表<code>1</code></li>
</ul></li>
</ul></li>
<li><p>有符号数的处理</p>
<ul>
<li>Sign Extension 很多操作需要，例如不同位宽数据的运算
<ul>
<li>正数添加前导0即可，负数则需要先复制符号位，然后再复制其余位。符号位复制多少次取决于新的位宽，例如从8位到16位，则需要把符号位复制8次。</li>
</ul></li>
</ul></li>
<li><p>转换规则推荐</p>
<ul>
<li><code>Ki=1024</code> ，而<code>K=1000</code>
。<code>B</code>是字节（Byte） ，而<code>b</code>是二进制位</li>
</ul></li>
<li><p>原码，反码，补码 用补码运算，用原码看结果</p>
<ul>
<li>0三码都为0</li>
<li>正数三码相等</li>
<li>负数反码是原码符号位以外全部取反，补码在反码基础上加1</li>
</ul></li>
</ul>
<h1 id="lecture-2-intro-with-c">Lecture 2 Intro with c</h1>
<ul>
<li>学完<code>Introductory C Programming Specialization</code>即可</li>
</ul>
<h1 id="lecture-3-intro-with-array">Lecture 3 Intro with array</h1>
<ul>
<li><p>学完<code>Introductory C Programming Specialization</code>即可 #
Lecture 4 Memory Management and Usage</p></li>
<li><p>学完<code>Introductory C Programming Specialization</code>即可</p></li>
</ul>
<h1 id="lecture-5-floating-representation">Lecture 5 floating
representation</h1>
<ul>
<li>十进制or二进制<code>**点分法**</code>理论上可以表示无穷的精度
<ul>
<li>例如<span class="math inline">\(\frac{1}{3} =
0.333.....\)</span></li>
<li>例如<span class="math inline">\(\frac{1}{10} =
0.0001100011...\)</span></li>
<li>为什么会出现无限循环小数</li>
</ul></li>
</ul>
<hr />
<p><strong>定理</strong>：考虑一个分数<span
class="math inline">\(\frac{a}{b} （其中b \neq 0 )\)</span>，若其在<span
class="math inline">\(N\)</span>进制下表示为有限小数，则分母<span
class="math inline">\(b\)</span>的所有质因子必须是进制数<span
class="math inline">\(N\)</span>的质因子。</p>
<p><strong>证明</strong>：</p>
<ol type="1">
<li>设<span class="math inline">\(N\)</span>的质因子分解为：<span
class="math inline">\(N = p_1^{k_1} p_2^{k_2} \dots
p_m^{k_m}\)</span>，其中，<span class="math inline">\(p_1, p_2, \dots,
p_m\)</span>是质数，且<span class="math inline">\(k_1, k_2, \dots,
k_m\)</span>是正整数。</li>
<li>若<span class="math inline">\(\frac{a}{b}\)</span>在<span
class="math inline">\(N\)</span>进制下是有限小数，则存在某个正整数<span
class="math inline">\(s\)</span>使得<span class="math inline">\(b \times
N^s\)</span>是一个整数。这意味着：</li>
</ol>
<p><span class="math inline">\(b \times N^s = b \times p_1^{k_1 s}
p_2^{k_2 s} \dots p_m^{k_m s}\)</span>是一个整数。</p>
<ol start="3" type="1">
<li>现在考虑<span class="math inline">\(b\)</span>的质因子分解。若<span
class="math inline">\(b\)</span>有一个质因子<span
class="math inline">\(q\)</span>不是<span
class="math inline">\(N\)</span>的质因子（ 即<span
class="math inline">\(q\)</span>不等于任何的<span
class="math inline">\(p_i\)</span>），则对于任何正整数<span
class="math inline">\(s\)</span>，乘积<span class="math inline">\(b
\times N^s\)</span>都不可能是整数，因为无法消除这个“外部”质因子<span
class="math inline">\(q\)</span>。</li>
</ol>
<hr />
<ul>
<li>二进制点分法中的点的位置不确定(多少位表示整数，多少位表示小数)，所以引入<code>二进制科学计数法</code>
<ul>
<li>优点
<ul>
<li>相对于二进制点分法
表示的范围能够很轻松的通过调整指数和尾数来<strong>扩大或减小数的范围</strong></li>
</ul></li>
<li>缺点
<ul>
<li>实际计算的舍入误差 （尾数位有限导致）</li>
<li>不精确的表示 （尾数位有限导致）</li>
</ul></li>
</ul></li>
</ul>
<hr />
<p>给定一个非零实数 <span
class="math inline">\(x\)</span>，在二进制科学计数法中，<span
class="math inline">\(x\)</span> 可以表示为： <span
class="math inline">\(x = (-1)^s \times 1.f_1 f_2 f_3 \ldots \times
2^e\)</span> 其中：</p>
<ol type="1">
<li><span class="math inline">\(s\)</span> 是符号位，当 <span
class="math inline">\(x\)</span> 为正数时 <span class="math inline">\(s
= 0\)</span>，当 <span class="math inline">\(x\)</span> 为负数时 <span
class="math inline">\(s = 1\)</span>。</li>
<li><span class="math inline">\(1.f_1 f_2 f_3 \ldots\)</span>
是一个二进制小数（<code>尾数</code>），其中 <span
class="math inline">\(f_i\)</span> 是位于小数点后的第 <span
class="math inline">\(i\)</span> 位的数字，每个 <span
class="math inline">\(f_i\)</span> 要么为 <span
class="math inline">\(0\)</span> 要么为 <span
class="math inline">\(1\)</span>。注意，我们默认小数点前有一个<span
class="math inline">\(1\)</span>，这是因为在二进制科学计数法的规范化表示中，非零数的最高有效位<strong>总是1。</strong></li>
<li><span class="math inline">\(e\)</span>
是一个整数（<code>指数</code>），代表二进制指数。</li>
</ol>
<p>例如，数字 <span class="math inline">\(13\)</span> 在二进制中表示为
<span class="math inline">\(1101\)</span>，其二进制科学计数法表示为
<span class="math inline">\(1.101 \times 2^3\)</span>。 在计算机的IEEE
754浮点数表示法中，因为最高有效位总是1，所以通常会省略它以节省存储空间。这是所谓的"隐藏位"技术。</p>
<hr />
<ul>
<li>IEEE754是目前常用的标准</li>
</ul>
<p><code>符号位（1位）``指数位（阶码 8位无符号数）``尾数位（小数位 23位）</code>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">annotated_ieee754_conversion</span>(<span class="hljs-params">num</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Convert a floating-point number to its IEEE 754 single-precision representation.</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Parameters:</span><br><span class="hljs-string">    - num: Floating-point number to be converted</span><br><span class="hljs-string">    </span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">    - Tuple containing (sign_bit, exponent_binary, fraction_bits)</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <br>    <span class="hljs-comment"># Step 1: Determine the sign bit</span><br>    <span class="hljs-comment"># If the number is positive or zero, sign bit is 0. Otherwise, it&#x27;s 1.</span><br>    sign_bit = <span class="hljs-number">0</span> <span class="hljs-keyword">if</span> num &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1</span><br>    <br>    <span class="hljs-comment"># Convert the number to positive for further processing.</span><br>    num = <span class="hljs-built_in">abs</span>(num)<br><br>    <span class="hljs-comment"># Step 2: Convert the number to binary representation.</span><br>    <span class="hljs-comment"># Convert the integer part of the number to binary.</span><br>    int_part = <span class="hljs-built_in">int</span>(num)<br>    int_binary = <span class="hljs-built_in">bin</span>(int_part)[<span class="hljs-number">2</span>:]<br>    <br>    <span class="hljs-comment"># Convert the fractional part of the number to binary.</span><br>    frac_num = num - int_part<br>    frac_binary = <span class="hljs-string">&quot;&quot;</span><br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(frac_binary) &lt; <span class="hljs-number">40</span> <span class="hljs-keyword">and</span> frac_num != <span class="hljs-number">0</span>:  <span class="hljs-comment"># Limit to 40 bits for precision.</span><br>        frac_num *= <span class="hljs-number">2</span><br>        frac_bit = <span class="hljs-built_in">int</span>(frac_num)<br>        frac_binary += <span class="hljs-built_in">str</span>(frac_bit)<br>        frac_num -= frac_bit<br><br>    <span class="hljs-comment"># Combine the integer and fractional parts.</span><br>    combined_binary = int_binary + frac_binary<br>    <br>    <span class="hljs-comment"># Step 3: Normalize the binary representation.</span><br>    normalized_position = combined_binary.index(<span class="hljs-string">&#x27;1&#x27;</span>)<br>    <br>    <span class="hljs-comment"># Calculate the number of shifts required to normalize the number.</span><br>    shift = <span class="hljs-built_in">len</span>(int_binary) - <span class="hljs-number">1</span> - normalized_position <br>    <br>    <span class="hljs-comment"># Step 4: Calculate the biased exponent.</span><br>    <span class="hljs-comment"># IEEE 754 single-precision format uses a bias of 127.</span><br>    exponent_with_bias = shift + <span class="hljs-number">127</span><br>    exponent_binary = <span class="hljs-built_in">bin</span>(exponent_with_bias)[<span class="hljs-number">2</span>:].rjust(<span class="hljs-number">8</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>    <br>    <span class="hljs-comment"># Step 5: Determine the fraction part with rounding.</span><br>    fraction_24_bits = combined_binary[normalized_position+<span class="hljs-number">1</span>:normalized_position+<span class="hljs-number">25</span>].ljust(<span class="hljs-number">24</span>, <span class="hljs-string">&#x27;0&#x27;</span>) <span class="hljs-comment"># Ensure length</span><br><br>    <span class="hljs-comment"># Implement the &quot;round to nearest, ties to even&quot; strategy.</span><br>    <span class="hljs-keyword">if</span> fraction_24_bits[-<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;1&#x27;</span> <span class="hljs-keyword">in</span> fraction_24_bits[<span class="hljs-number">1</span>:] <span class="hljs-keyword">or</span> fraction_24_bits[-<span class="hljs-number">2</span>] == <span class="hljs-string">&#x27;1&#x27;</span>:<br>            fraction_bits = <span class="hljs-built_in">bin</span>(<span class="hljs-built_in">int</span>(fraction_24_bits[:-<span class="hljs-number">1</span>], <span class="hljs-number">2</span>) + <span class="hljs-number">1</span>)[<span class="hljs-number">2</span>:].rjust(<span class="hljs-number">23</span>, <span class="hljs-string">&#x27;0&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            fraction_bits = fraction_24_bits[:-<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">else</span>:<br>        fraction_bits = fraction_24_bits[:-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">return</span> (sign_bit, exponent_binary, fraction_bits)<br><br><span class="hljs-comment"># The testing part remains the same as before.</span><br>consistent = <span class="hljs-literal">True</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):<br>    random_num = random.uniform(-<span class="hljs-number">1e6</span>, <span class="hljs-number">1e6</span>)<br>    single_precision_num = <span class="hljs-built_in">float</span>(random_num)<br>    manual_ieee754 = annotated_ieee754_conversion(single_precision_num)<br>    <br>    binary_representation = <span class="hljs-built_in">format</span>(struct.unpack(<span class="hljs-string">&#x27;!I&#x27;</span>, struct.pack(<span class="hljs-string">&#x27;!f&#x27;</span>, single_precision_num))[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;032b&#x27;</span>)<br>    builtin_sign_bit = <span class="hljs-built_in">int</span>(binary_representation[<span class="hljs-number">0</span>])<br>    builtin_exponent = binary_representation[<span class="hljs-number">1</span>:<span class="hljs-number">9</span>]<br>    builtin_fraction = binary_representation[<span class="hljs-number">9</span>:]<br>    builtin_ieee754 = (builtin_sign_bit, builtin_exponent, builtin_fraction)<br>    <br>    <span class="hljs-keyword">if</span> manual_ieee754 != builtin_ieee754:<br>        consistent = <span class="hljs-literal">False</span><br>        <span class="hljs-keyword">break</span><br><br>consistent<br><br></code></pre></td></tr></table></figure></p>
<ul>
<li>浮点数存在精度问题</li>
</ul>
<p><strong>基本概念</strong>: IEEE 754
浮点数使用固定数量的位来表示实数。由于实数范围是无限的，而我们的表示位数是有限的，所以必然会有精度损失。
<strong>具体问题</strong>：</p>
<ol type="1">
<li><strong>非规范化数与规范化数</strong>:
当数值非常接近于0，我们使用非规范化数来表示。这意味着我们放弃了一个隐含的前导1，以获得更多的小数点后的位数，但这降低了精度。</li>
<li>考虑一个非常小的数，如 <span class="math inline">\(1.0 \times
10^{-45}\)</span> 在 IEEE 754
单精度格式中，这个数是一个非规范化数，因为它太小了，无法用规范化数表示。</li>
<li><strong>舍入错误</strong>:
由于表示位数的限制，当我们尝试表示某些数值时，可能需要进行舍入。这导致了所谓的舍入错误。</li>
<li>考虑数字 <span
class="math inline">\(0.1\)</span>。在二进制中，它是一个无限重复的小数。因此，当我们尝试将其表示为
IEEE 754 浮点数时，它必须被舍入，导致精度损失。</li>
<li><strong>计算中的累积误差</strong>:
在进行浮点运算时（如加法、乘法等），误差可能会累积，特别是在迭代计算中。</li>
<li>考虑一个简单的操作：将 <span class="math inline">\(0.1\)</span> 加上
<span class="math inline">\(0.2\)</span>。理论上，结果应该是 <span
class="math inline">\(0.3\)</span>，但由于舍入误差，实际的浮点计算结果可能会略有不同。</li>
<li><strong>浮点数相等性</strong>:
由于精度问题，直接比较两个浮点数是否相等通常是不安全的。例如，计算的结果(0.3
+ 0.3 + 0.3)可能不等于(0.9)，尽管差异很小。</li>
<li>假设我们有一个程序，它计算 <span class="math inline">\(0.3 - 0.2 -
0.1\)</span>。理论上，结果应该是 <span
class="math inline">\(0\)</span>，但由于舍入误差，实际的浮点结果可能非常接近于零，但不完全是零。</li>
<li><strong>消失的尾数位</strong>:
当差异很大的两个数相加时，小的数可能在结果中"消失"，因为它对最终结果的贡献太小，不能在有限的尾数位中表示。</li>
<li>考虑两个数：<span class="math inline">\(10^9 + 1\)</span> 和 <span
class="math inline">\(10^9\)</span>。当它们相减时，理论上的结果是 <span
class="math inline">\(1\)</span>，但在浮点计算中，结果可能是 <span
class="math inline">\(0\)</span>，因为小的数在差异很大的数的计算中可能会“消失”。</li>
</ol>
<ul>
<li>浮点数等间隔中能表示的数的数量，随着数的大小的增加而减少</li>
</ul>
<p><strong>基本概念</strong>:
浮点数由符号、指数和尾数三部分组成。指数部分决定了数的范围或大小，而尾数部分决定了数的精度。</p>
<ol type="1">
<li><strong>固定宽度的尾数</strong>：尾数的宽度是固定的，例如，对于 IEEE
754
单精度，尾数有23位。这意味着，在给定的指数值下，我们可以表示的数的数量是固定的。</li>
<li>考虑数字 <span
class="math inline">\(1.23456789\)</span>。尽管这个数字在十进制中很简单，但在固定宽度的二进制浮点表示中，我们可能无法准确地表示它。</li>
<li><strong>等间隔表示</strong>:
对于给定的指数值，尾数的每一个位的增加都表示了一个等间隔的增量。但是，当指数值增加时，这个间隔会变得更大。因此，对于较大的数，我们可以表示的数之间的间隔会变得更大。</li>
<li>考虑两个相邻的 IEEE 754
单精度浮点数，其中一个具有最大的正指数和全零的尾数，而另一个具有最大的正指数但尾数增加了最小的量（即尾数的最后一位是1）。这两个数之间的差异将是巨大的。</li>
<li><strong>表示范围与间隔的权衡</strong>:
由于尾数宽度的限制，当我们表示更大的数时，我们可以表示的数的间隔必然增加。这意味着，尽管我们仍然可以表示大范围内的数，但这些数之间的间隔会变得更大，从而导致精度损失。</li>
<li>考虑数字 <span class="math inline">\(10^{30}\)</span> 和 <span
class="math inline">\(10^{30} +
10^{15}\)</span>。在单精度浮点数中，这两个数字可能会映射到相同的值，因为尾数的宽度限制了我们能够区分的数的数量。这显示了随着数的增大，我们失去了区分相对较小差异的能力。</li>
</ol>
<h1 id="lecture-6-assembly">Lecture 6 Assembly</h1>
<h2 id="lec06.pdfx86"><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698299457180-6a6c42fb-f3b9-40bb-9384-5f41bd85ecce.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698299457180-6a6c42fb-f3b9-40bb-9384-5f41bd85ecce.pdf%22%2C%22name%22%3A%22lec06.pdf%22%2C%22size%22%3A8497764%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22uf1db4eaf-271c-485e-a482-07a2dc2187d%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u6c61a067%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec06.pdf</a>x86</h2>
<ul>
<li><strong>Designer</strong>: Intel, AMD</li>
<li><strong>Bits</strong>: 16-bit, 32-bit and 64-bit</li>
<li><strong>Introduced</strong>:
<ul>
<li>1978 (16-bit)</li>
<li>1985 (32-bit)</li>
<li>2003 (64-bit)</li>
</ul></li>
<li><strong>Design</strong>: CISC</li>
<li><strong>Type</strong>: Register-memory</li>
<li><strong>Encoding</strong>: Variable (1 to 15 bytes)</li>
<li><strong>Endianness</strong>: Little</li>
<li><strong>Usage</strong>: Macbooks &amp; PCs (Core i3, i5, i7, M)</li>
</ul>
<hr />
<h2 id="arm-architectures">ARM architectures</h2>
<ul>
<li><strong>Designer</strong>: ARM Holdings</li>
<li><strong>Bits</strong>: 32-bit, 64-bit</li>
<li><strong>Introduced</strong>: 1985; 31 years ago</li>
<li><strong>Design</strong>: RISC</li>
<li><strong>Type</strong>: Register-Register</li>
<li><strong>Encoding</strong>:
<ul>
<li>AArch64/A64 and AArch32/A32 use 32-bit instructions</li>
<li>T32 (Thumb-2) uses mixed 16- and 32-bit instructions. ARMv7
user-space compatibility</li>
</ul></li>
<li><strong>Endianness</strong>: Bi (little as default)</li>
<li><strong>Usage</strong>: Smartphone-like devices (iPhone, Android),
Raspberry Pi, Embedded systems</li>
</ul>
<hr />
<h2 id="risc-v">RISC-V</h2>
<ul>
<li><p><strong>Designer</strong>: University of California,
Berkeley</p></li>
<li><p><strong>Bits</strong>: 32, 64, 128</p></li>
<li><p><strong>Introduced</strong>: 2010</p></li>
<li><p><strong>Version</strong>: 2.2</p></li>
<li><p><strong>Design</strong>: RISC</p></li>
<li><p><strong>Type</strong>: Load-store</p></li>
<li><p><strong>Encoding</strong>: Variable</p></li>
<li><p><strong>Branching</strong>: Compare-and-branch</p></li>
<li><p><strong>Endianness</strong>: Little</p></li>
<li><p><strong>Usage</strong>: Versatile and open-source. Relatively
new, designed for cloud computing, embedded systems, academic
use</p></li>
<li><p>早期指令集设计方向</p>
<ul>
<li>复杂指令集（不断细化指令） -&gt;
(难学，但是编译器可以做更少的事，比较慢，因为主要是设计更多的指令）
x86是典型 <code>CISC</code></li>
<li>精简指令集 -&gt;（好学，复杂的指令通过简单指令的组合来实现 快）
<code>RISC</code></li>
</ul></li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698299998791-135851ce-b583-4d5c-b382-7bf7e3c71a5c.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698299998791-135851ce-b583-4d5c-b382-7bf7e3c71a5c.pdf%22%2C%22name%22%3A%22RISV-2016-1.pdf%22%2C%22size%22%3A959927%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22uf7cc602f-2fe1-4ca7-af70-0e13efc8ca0%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22udd5c5e7a%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">RISV-2016-1.pdf</a></p>
<h2 id="registers">Registers</h2>
<ul>
<li><p>汇编没有变量的概念，只有寄存器</p></li>
<li><p>不同的硬件可能寄存器数量/位数不同</p></li>
<li><p>可以读，写；耗电量相较于Memory很少；性能快</p></li>
<li><p>寄存器是在CPU上的直接结构</p></li>
<li><p>既然寄存器这么快，为什么不直接用寄存器替代内存，外存等</p>
<ul>
<li>💰</li>
<li>针对存储设计的分层体系架构，越底层的存储介质容量越大，速度越慢</li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002971.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ol type="1">
<li><strong>寄存器表示</strong>：在RISC-V中，寄存器可以用‘x’加上一个数字（如x0、x1...x31）来表示，或者用特定的名字来表示。
(RISCV一共有32个寄存器，寄存器并不是越多越好，需要在存储量以及读取速度做权衡)</li>
<li><strong>寄存器种类</strong>：</li>
</ol>
<ul>
<li><strong>程序员变量寄存器</strong>：这类寄存器用于保存程序中的变量。
<ul>
<li>s0-s1 对应 x8-x9</li>
<li>s2-s11 对应 x18-x27</li>
</ul></li>
<li><strong>临时变量寄存器</strong>：这类寄存器用于暂时保存数据。
<ul>
<li>t0-t2 对应 x5-x7</li>
<li>t3-t6 对应 x28-x31</li>
</ul></li>
</ul>
<ol start="3" type="1">
<li><strong>寄存器类型</strong>：RISC-V中的寄存器没有类型（与C语言的概念相反）。执行的操作决定了如何处理寄存器的内容。</li>
</ol>
<p>在RISC-V架构中，x0-x7的寄存器有特定的用途和命名：</p>
<ul>
<li><strong>x0</strong>:
常被称为<code>zero</code>寄存器。它是一个硬编码的寄存器，总是返回0。无论你尝试写入什么值，它都会保持为0。</li>
<li><strong>x1</strong>:
通常被称为<code>ra</code>，即返回地址寄存器。它用于保存函数返回地址。</li>
<li><strong>x2</strong>:
被称为<code>sp</code>，即堆栈指针寄存器。它指向当前堆栈的顶部。</li>
<li><strong>x3</strong>:
被称为<code>gp</code>，即全局指针寄存器。它通常用于指向全局变量。</li>
<li><strong>x4</strong>:
被称为<code>tp</code>，即线程指针寄存器。它用于指向线程相关的数据。</li>
<li><strong>x5-x7</strong>:
这些是<code>t0-t2</code>临时寄存器，主要用于编译器的中间操作。</li>
</ul>
<h2 id="assembly-code">Assembly code</h2>
<ul>
<li><code>opt</code> <code>dst</code>, <code>src1</code>,
<code>src2</code></li>
<li>c中的单行代码可能在<code>RSIC-V</code>中分解为多个不同的指令</li>
</ul>
<h3 id="basic-arithmetic-instructions">Basic Arithmetic
Instructions</h3>
<ul>
<li><p>例如c语言中的 <code>a = b + c</code> | <code>a = b - c</code> |
<code>a =  (b+c)  - (d+e)</code></p></li>
<li><p><code>add s1, s2, s3</code> | <code>sub s1, s2, s3</code> |
<code>add t1, s2, s3</code> <code>add t2, s4, s5</code>
<code>sub s1, t1, t2</code></p></li>
<li><p>有时候改变指令的顺序有助于提高执行效率，但某些指令是不可以随便交换的</p></li>
<li><p>立即数操作（思考为什么没有subi操作）</p>
<ul>
<li><code>addi s1,s2,2</code> | <code>a = b + 2</code>;</li>
<li><code>addi s3,s3,1</code> | <code>c++</code>;</li>
<li>立即数减法可以通过组合立即数加法和负的立即数，这减少了指令集的复杂性</li>
</ul></li>
<li><p>从内存中存或者读数据</p>
<ul>
<li><code>memop reg, off(bAddr)</code> （内存操作符
<code>目标寄存器/操作寄存器</code>
off是一个以<code>Byte</code>为单位的偏移量，<code>bAddr</code>一个存储内存基地址的寄存器</li>
<li><strong>A register holds a word of raw data (no type)</strong>:
寄存器存储的是原始数据，没有数据类型的区分。换句话说，不像高级编程语言中的变量，它们可能有一个指定的数据类型（如整数、浮点数或字符），寄存器仅仅存储一串二进制数据，而不关心这些数据代表什么类型。</li>
<li><strong>Make sure to use a register (and offset) that point to a
valid memory address</strong>:
当你使用寄存器来表示一个内存地址时（例如在数据传输指令中），你需要确保该寄存器中的值（以及与之相关的任何偏移量）确实指向一个有效的内存位置。这是为了防止尝试访问无效或受保护的内存区域，这样可能会导致程序崩溃或其他不可预测的行为。</li>
<li>从off的使用方法可以看到，汇编不提供类似c语言<code>p++</code>自动偏移对应类型的操作，数据的大小需要自己考虑。</li>
<li>a[10] = a[3] + b -&gt; <code>lw t1,12(s1)</code>
<code>addi t1,t1,s2</code> <code>sw t1, 40(s1)</code></li>
</ul></li>
<li><p>怎么在内存中用汇编初始化值 （造了一个数组）
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp">.data<br>    <span class="hljs-comment">// 这里创建了三个32位的整数，然而我们不知道它的实际地址</span><br>source:<br>    	.word <span class="hljs-number">3</span><br>        .word <span class="hljs-number">1</span><br>        .word <span class="hljs-number">4</span><br>.text<br>main:<br>    	la t1,source  <span class="hljs-comment">// 所以先把source的地址拿到 t1寄存器</span><br>        lw t2,<span class="hljs-number">0</span>(t1)   <span class="hljs-comment">// 然后把值（a[0]）加载到t2寄存器里</span><br>        lw t3,<span class="hljs-number">4</span>(t1)   <span class="hljs-comment">// 然后把值 (a[1]) 加载到t3寄存器里</span><br></code></pre></td></tr></table></figure></p></li>
<li><p>字（32位），字节（8位），半字（16位），我们讨论往往用<code>1Byte</code>来讨论内存</p></li>
<li><p>RISC-V的位拓展有0填充以及高位符号位填充，有些指令可能理论上进行了位拓展，例如<code>lui</code>指令是"Load
Upper
Immediate"的缩写，它用于将一个20位的立即数值加载到一个寄存器的上20位，同时将其下12位清零，这个指令前后操作数实质发生了位拓展，但是因为没有多余的位进行拓展，所以实际没有进行位拓展。而<code>auipc</code>是把一个20bit位的数加载到<code>pc</code>中，至于具体的位数要看<code>RISC-V</code>的变种</p></li>
<li><p><code>lb/sb</code> <code>一切内容都以二进制的形式表示</code></p>
<ul>
<li><code>lb s1, 1(s0)</code> 从s0中拿第二个字节
，通过<code>符号</code>位拓展存储到s1中</li>
<li><code>sb s1, 2(s0)</code> 把s1的最低位存到s0中的第三个字节</li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002972.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><code>lh/sh</code> 和
<code>lb</code>以及<code>sb</code>一样，不过操作的是半字也就是16位比特位</li>
<li><code>lhu</code>和<code>lbu</code>用于无符号数的读取，但是它们只执行0拓展</li>
</ul>
<h3 id="control-flow">control flow</h3>
<ul>
<li>c有代码块的概念，但RISC-V没有，但是具有label的概念，例如<code>main:</code></li>
<li>label是可跳转的</li>
<li><code>beq reg1, reg2, label</code> Branch If Equal
，如果<code>reg1 == reg2</code> [寄存器内的值相等]
那么跳转到label，否则执行下一条指令</li>
<li><code>bne reg1, reg2, label</code> Branch If Not Equal ， 如果
<code>reg1 != reg2</code> [寄存器内的值相同]
那么跳转到label，否则执行下一条指令</li>
<li><code>j label</code> 无条件跳转到下一条指令</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002974.png" srcset="/img/loading.gif" lazyload
alt="截屏2023-10-28 13.16.37.png" />
<figcaption aria-hidden="true">截屏2023-10-28 13.16.37.png</figcaption>
</figure>
<ul>
<li><code>blt reg1,reg2, label</code> Branch Less Than, means &lt;, if
the value in reg1 is less than reg2, then go to label</li>
<li><code>bge reg1,reg2, label</code> Branch Greater Than or Equal &gt;=
<ul>
<li>为什么不设计一个&gt; 或者 &lt;= 呢？
这完全可以通过交换参数来实现。</li>
</ul></li>
<li>loop in RISC-V 有许多实现方法，关键就是分支控制</li>
<li>PC
<ol type="1">
<li><strong>Program Counter (PC)</strong>: PC 是一个寄存器，它存储着 CPU
下一步要执行的指令的地址。在顺序执行的程序中，每执行一条指令，PC
通常会自动加上该指令的长度，从而指向下一条指令。</li>
<li><strong>Branches</strong>: Branches
是指控制流指令，如条件分支和无条件跳转。当满足某个条件时，它们会修改 PC
的值，使其跳转到程序的另一个位置，而不是顺序地执行下一条指令。</li>
</ol>
<ul>
<li>当 CPU
执行到一个分支指令时，它会根据该指令和给定的条件来决定是否修改 PC
的值。如果决定跳转，则 PC
会被设置为目标地址，这导致程序从新的地址继续执行。如果不跳转，PC
将按常规递增，继续顺序执行。</li>
<li>无条件跳转（如 <code>jmp</code> 或 <code>j</code>
在某些汇编语言中）总是会修改 PC 的值。</li>
<li>条件分支（如 <code>beq</code>、<code>bne</code>
等）则会根据条件判断是否修改 PC。 ### Shifting Instructions <img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002975.png" srcset="/img/loading.gif" lazyload
alt="image.png" /></li>
</ul></li>
<li>没有算数左移是因为算数左移和逻辑左移是一样的，低位都会被填充为0</li>
<li>对于立即数而言，值只能在0-31之间（32位指令）</li>
<li>对于寄存器中的值而言，只有低5位的值会被读取</li>
</ul>
<h3 id="other-instructions">other Instructions</h3>
<ul>
<li><code>mul dst, src1,src2</code> 计算<code>src1</code> *
<code>src2</code> ,把<code>低32位</code>存到<code>dst</code>中</li>
<li><code>mulh dst, src1, src2</code> 把<code>高32位</code>
存储到<code>dst</code>中</li>
<li><code>div dst, src1, src2</code> 计算<code>src1 / src2</code>
,把商存到<code>dst</code>中</li>
<li><code>rem dst, src1, src2</code> 计算<code>src1 / src2</code> ,
把余树存储到 <code>dst</code>中</li>
<li><code>and dst, src1, src2</code>
计算<code>src1 &amp; src2</code>，把结果存到<code>dst</code>中</li>
<li><code>andi dst, src1, imm</code>
计算<code>src1 &amp; imm</code>，把结果存到<code>dst</code>中</li>
<li><code>or dst, src1, src2</code>
计算<code>src1 | src2</code>，把结果存到<code>dst</code>中</li>
<li><code>ori dst, src1, imm</code>
计算<code>src1 | imm</code>，把结果存到<code>dst</code>中</li>
<li><code>xor dst, src1, src2</code>
计算<code>src1 ^ src2</code>，把结果存到<code>dst</code>中</li>
<li><code>xori dst, src1, imm</code>
计算<code>src1 ^ imm</code>，把结果存到<code>dst</code>中</li>
<li><code>slt dst, reg1,reg2</code> 如果<code>reg1&lt;reg2</code>,
则<code>dst</code>为<code>1</code>否则为<code>0</code></li>
<li><code>slti dst, reg1, imm</code> 如果<code>reg1&lt;imm</code>,
则<code>dst</code>为<code>1</code>否则为<code>0</code></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002976.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h3 id="interact-with-os">Interact with os</h3>
<ul>
<li>基于<code>a0</code>寄存器与<code>os</code>交互</li>
<li><a
target="_blank" rel="noopener" href="https://github.com/ThaumicMekanism/venus/wiki/Environmental-Calls">https://github.com/ThaumicMekanism/venus/wiki/Environmental-Calls</a></li>
</ul>
<h1 id="lecture-7-more-about-assembly">Lecture 7 More about
assembly</h1>
<h2 id="pseudo-instructions">Pseudo-Instructions</h2>
<ul>
<li>不同于高级语言例如c，汇编语言一定是针对于具体硬件而运行的</li>
<li>我们有时候使用的指令并不是“真正的指令”，而是为了方便记忆而做了一层抽象
<ul>
<li><code>mv dst, reg1</code> -&gt; <code>addi dst, reg1, 0</code>
移动寄存器中的一个值到另一个寄存器中</li>
<li><code>li dst, imm</code> -&gt; <code>addi, lui</code>
加载一个立即数到寄存器</li>
<li><code>la dst, label</code> -&gt; <code>auipc dst</code>
将指定标签的地址加载到寄存器</li>
<li><code>nop</code> -&gt; <code>addi x0, x0, 0</code>
不执行任何操作</li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002977.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>如何将这段代码转化为汇编语言呢？
<ul>
<li>明确写下每一步</li>
<li>一步一步的进行翻译</li>
<li>进行指令优化 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//   define *p, define *q       --&gt;  p-&gt;  s0,  q -&gt; s1    </span><br><span class="hljs-comment">//   loop                       --&gt;  Loop:</span><br><span class="hljs-comment">//   take *p                    --&gt;  lb t0,0(s0)</span><br><span class="hljs-comment">//   set to *q                  --&gt;  sb t0,0(s1)</span><br><span class="hljs-comment">//   p++                        --&gt;  addi s0,s0,1</span><br><span class="hljs-comment">//   q++                        --&gt;  addi s1,s1,1</span><br><span class="hljs-comment">//   if *q == &#x27;\0&#x27; else to loop --&gt;  beq s0,x0,next</span><br><span class="hljs-comment">//								--&gt;  j Loop</span><br><span class="hljs-comment">//   go to next 				--&gt;  next:</span><br></code></pre></td></tr></table></figure></li>
</ul></li>
<li>我们的next出现了冗余，可以用更少的指令来描述</li>
</ul>
<h2 id="function-calling">function calling</h2>
<ul>
<li>函数调用通用流程
<ul>
<li>将被调用函数需要的变量存储到可以被访问到的地方（寄存器，内存）</li>
<li>将控制权转移给被调用的函数</li>
<li>被调用函数读取一些需要的资源</li>
<li>被调用函数执行自己的任务</li>
<li>被调用函数返回值，然后清空资源</li>
<li>控制元返回到调用者身上</li>
</ul></li>
<li>传入的参数存在哪里，返回值存在哪里
<ul>
<li>优先使用寄存器 <code>a0-a7</code> (传参)
，<code>a0-a1</code>(返回值）</li>
<li>如果空间不够用，那么用栈空间</li>
</ul></li>
<li>函数之间的控制权是如何转移的
<ul>
<li><code>Jump (j)</code>：无条件跳转到标签处。这是一个伪指令，实际上是
<code>jal x0 label</code> ,<code>x0</code>不会被修改
<ul>
<li>示例：<code>j label1</code></li>
</ul></li>
<li><code>Jump and Link (jal)</code>：用于调用函数。它将当前指令的地址保存到返回地址寄存器，并跳转到指定标签。
<ul>
<li>示例：<code>jal dst label</code></li>
</ul></li>
<li><code>Jump and Link Register (jalr)</code>：与<code>jal</code>相似，但允许更灵活的跳转地址，地址是从寄存器和立即数计算得到的。
<ul>
<li>示例：<code>jalr dst src imm</code>
将下一条指令的地址存到<code>dst</code>中（通常是<code>ra</code>），跳转到<code>src + imm</code>的地址</li>
</ul></li>
<li><code>Jump Register (jr)</code>：无条件跳转到源寄存器指定的地址。通常用于从函数返回。
<ul>
<li>示例：<code>jr src</code>
也是一个伪指令，<code>jalr x0, rs1, 0</code></li>
</ul></li>
<li><code>ra</code>：返回地址寄存器。用于保存从哪个地址调用了函数，以便后续可以返回。</li>
<li><code>sp</code>：一个指向栈顶的指针</li>
</ul></li>
<li>函数调用者与被调用者该怎么保证寄存器的安全使用 -&gt; 基于简单的约定
<ul>
<li>Saved Registers (Callee Saved)
<ul>
<li><code>s0-s11</code></li>
<li><code>sp</code></li>
<li>这些寄存器在被调用者返回前（callee），必须把Saved
Registers恢复到调用之前</li>
</ul></li>
<li>Volatile Registers （if needed Caller Saved）
<ul>
<li><code>t0-t6</code> 局部变量用</li>
<li><code>a0-a7</code> 返回值及传入参数用</li>
<li><code>ra</code> 返回地址寄存器</li>
<li><figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002978.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure></li>
</ul></li>
</ul></li>
<li>例子</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002979.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h1 id="lecture-8-risc-v-format">Lecture 8 RISC-V format</h1>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698730134374-89704955-8d29-44c5-b9b9-af80d35e802f.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698730134374-89704955-8d29-44c5-b9b9-af80d35e802f.pdf%22%2C%22name%22%3A%22lec08.pdf%22%2C%22size%22%3A14352933%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u47969a60-abb8-4c09-983b-8b4e6ad5dec%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22u6001ded4%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec08.pdf</a></p>
<ul>
<li>最开始的ENIAC能够在2ms内计算两个十位数的乘法，但是需要两到三天设置程序</li>
<li>为什么不用bit来表示指令呢？所有要执行的指令全部加载到内存中，这是现代计算的核心思想。
<ul>
<li>c语言的指针指向的是内存中的数据</li>
<li>PC指向的是内存中的代码、指令</li>
</ul></li>
<li>随着硬件的发展，我们既不想抛弃以前的指令集，又加入了新的指令集，这导致了指令集的膨胀
<ul>
<li>典型的例子就是x86</li>
<li>汇编器替我们把汇编代码转译为机器语言</li>
</ul></li>
<li>我们有6种不同的划分方法，将一个32位的指令划分为不同指令格式，这是对<code>硬件简化设计</code>以及<code>复杂指令设计</code>的妥协
<ul>
<li><code>R-Format</code>
实现所有需要三个寄存器的算数与逻辑操作指令</li>
<li><code>I-Format</code> 实现带有立即数的运算指令和加载指令</li>
<li><code>S-Format</code> 实现将寄存器的值写入到内存中</li>
<li><code>U-Format</code>
和<code>I-Format</code>类似，但是立即数是高20位</li>
<li><code>SB-Format</code> 分支指令设计</li>
<li><code>Uj-Format</code> 直接更改程序执行地址</li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002980.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><code>funct7</code>，<code>funct3</code>
组合起来用于指定具体的操作</li>
<li><code>rs1</code>，<code>rs2</code>
则存储了操作数，<code>rd</code>则标注了写入结果的寄存器</li>
<li><code>imm</code>是立即数，可以看到排布规则还是很奇怪的，甚至还有缩位，一切都是为了硬件</li>
<li><code>opcode</code>则告诉我们某条指令到底属于哪一类</li>
</ul>
<h2 id="r-format">R-Format</h2>
<ul>
<li>不同的filed长度不同，但都是<del>无符号数</del>，似乎并不是，imm是以补码的形式存储的</li>
<li>我们有<span class="math inline">\(2^3 * 2^7 =
2^{10}\)</span>个不同的<code>R-Format</code>指令</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002981.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>所有<code>R-Format</code>指令的操作码都是一致的</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002982.png" srcset="/img/loading.gif" lazyload
title="funct7，rs2，rs1，funct3，rd，opcode"
alt="funct7，rs2，rs1，funct3，rd，opcode" />
<figcaption
aria-hidden="true">funct7，rs2，rs1，funct3，rd，opcode</figcaption>
</figure>
<h2 id="i-format">I-Format</h2>
<ul>
<li>当存在立即数时，意味着我们的指令中必须包含一个立即数，而不是寄存器的地址，而对于我们已经知道的<code>R-Format</code>来说，用5位来表示一个立即数可用的范围太小了</li>
<li>RISC-V的设计理念希望我们只有一条指令，但现在我们需要违背这个理念，需要一个不同的格式</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002983.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><code>func7</code>和<code>rs2</code>被用于表示一个立即数，其他的filed和<code>R-Format</code>保持一致</li>
<li><code>imm</code>每次在进行算数运算时都会由12位数拓展为32位</li>
<li><code>imm</code>的范围是<span class="math inline">\([-2^{11},
+2^{11}-1]\)</span></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002984.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><p>对于特殊的移位操作，只使用低五位代表移动的位数</p></li>
<li><p>用<code>1</code>和<code>0</code>区别算数右移和逻辑右移</p></li>
<li><p>Load - Instructions 也是I-Format类型的指令</p></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002985.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>从<code>rs1</code>中取出内存中的基地址，与偏移量相加后取出值放到<code>dst</code>中</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002986.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>jalr也是I类型的指令</li>
<li>需要注意的就是，这里的偏移量单位就是字节，不需要乘以2字节进行对齐，跳转粒度是字节为单位的</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002987.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="s-format">S-Format</h2>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002988.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>去掉目标寄存器，更改为立即数的低5位</li>
<li>功能就是在<code>rs1</code>地址加上偏移量的位置写入<code>rs2</code>的内容</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002989.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="sb-format">SB-Format</h2>
<ul>
<li>一般用于循环或者流程控制，循环一般会小于50条指令</li>
<li>分支距离 从当前分支指令到目标位置的距离 一般用字节或者指令描述
<ul>
<li>这个大小收到代码段大小的限制（代码段本身的大小，不可以跳到代码段之外的位置）</li>
<li><code>PC</code>存储了当前指令的地址，具体跳转的位置由当前<code>PC</code>内的地址在<span
class="math inline">\([-2^{11},+2^{11]}\)</span>对齐的位置进行跳转（不对齐会引发性能问题），并且跳转的距离必须是4Byte的整数倍
<ul>
<li>RISC-V使用32位地址：这意味着它使用32位来表示内存地址。</li>
<li>内存是按字节寻址的：即每个地址对应一个字节。</li>
<li>32位指令是“word-aligned”：这意味着每个32位指令的地址都是4的倍数（因为一个字是4个字节）。例如，0x1000,
0x1004, 0x1008 等都是有效的指令地址，而0x1001, 0x1002, 0x1003
等则不是。</li>
<li>程序计数器（PC）始终指向一个指令：这是计算机硬件设计的基本原则，确保程序能够顺序地执行指令。</li>
<li>RISC-V的压缩指令：如果系统支持RISC-V的压缩指令（这些指令只有16位长），那么所有指令都是“half
word-aligned”，即指令的地址是2的倍数。</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002990.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>ISA 指令集的抽象体系结构
为同一ISA编写的程序可以在不同的ISA的实现平台上运行</li>
<li>拓展的RISC-V支持16位的压缩指令，为了对齐兼容，因此分支指令的偏移量以半字为单位，无论你有没有用到16位压缩指令</li>
<li>从当前指令最大只能实现<span
class="math inline">\(2^{10}\)</span>条32位指令的跳转，偏移量的单位是半字（16位bit，2Byte）
<ul>
<li>为什么不用一个字呢？ （兼容16位，以及可以缩减所占用空间的大小）</li>
<li>Imm实际表示的是13位的偏移，实际的偏移量既imm所表示的立即数<em>2（或者向最低位补一个零）</em>2Byte
<ul>
<li>为什么可以这样？因为我们的偏移量的最后一位总会是零（RISC-V是4字节或2字节对齐的指令）</li>
</ul></li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002991.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li><code>filed1</code>的最高位存储偏移量的第12位，剩余的位存第10-5位</li>
<li><code>filed5</code>的前4位存储偏移量的1-4位，最后一位存第11位</li>
<li>这十分地别扭，但一切都是基于硬件的考量</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002992.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>SB指令实现跳转是基于PC寄存器的相对寻址方式
<ul>
<li>整个代码区的移动不会导致立即数的改变（部分代码会）</li>
<li>当我们要跳转的指令范围大于了<span
class="math inline">\(2^{10}\)</span>条32位的指令，那么将会使用J指令进行跳转，J指令具有更大的跳转范围</li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002993.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h2 id="u-format">U-Format</h2>
<ul>
<li>I-Format指令只给了我们12位的立即数，假如我们需要用到更大的立即数，那么就需要使用到U-Format指令</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002994.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>加载32位立即数的高20位到程序寄存器/PC中，剩余的位置补0</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002995.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>加载这个32位的立即数出现了问题，原因是<code>addi</code>对要加载的立即数进行了符号拓展，这导致实际上我们计算的是<code>0xDEADB000</code>+<code>0xFFFFFEEF</code></li>
<li>我们只需要在处理需要符号拓展的<code>addi</code>对<code>0xDEADB</code>偏移一次就好，即得到<code>0xDEADC</code>
+ <code>0xFFFFFEEF</code> = <code>0xDEADBEEF</code></li>
<li>AUIPC是把立即数的高位和PC相加并存到dst寄存器中</li>
</ul>
<h2 id="uj-format">UJ-Format</h2>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002996.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>把PC+4 存到dst里</li>
<li>令PC = PC + offset</li>
<li>最大可跳过<span class="math inline">\(2^{19}\)</span>个
16位指令，即<span class="math inline">\(2^{18}\)</span>个32位的指令</li>
<li><code>J</code>是伪指令，还是基于<code>JAL</code>，利用了<code>x0</code>寄存器不会被修改的特点</li>
<li>imm的编码还是十分混乱，再次强调，这是为了降低硬件成本</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002997.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<p>看起来就很硬件友好，例如opcode的位置，rd，rs的位置都是对齐的</p>
<h1 id="lecture-9-call">Lecture 9 CALL</h1>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698909449654-f25c0253-547f-4ac1-884a-7f85cc0bc54e.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698909449654-f25c0253-547f-4ac1-884a-7f85cc0bc54e.pdf%22%2C%22name%22%3A%22lec09-2.pdf%22%2C%22size%22%3A8406067%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ucedb2fc9-46d6-493a-935e-c969e717e2e%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22ub5a4e767%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec09-2.pdf</a></p>
<ul>
<li><p>Compiler</p></li>
<li><p>Assembler</p></li>
<li><p>Linker</p></li>
<li><p>Loader ## Translation</p></li>
<li><p>当我们编写程序后，有两种方法运行我们编写的运行程序</p>
<ul>
<li>解释 ：边解释边运行 例如python<br />
</li>
<li>翻译： 转换为另一种等价语言来运行 例如c</li>
<li>当具有性能的考量的时候，用translate</li>
<li>解释语言往往性能慢一些 10x，但是代码少 2x</li>
</ul></li>
</ul>
<h2 id="compiler">Compiler</h2>
<ul>
<li>将.c源文件输出为.s汇编文件（可能包含伪指令）
<ul>
<li>预处理，例如宏替换，头文件包含</li>
<li>确定运算符的优先级 a = 3+ 4*2</li>
<li>...非常复杂</li>
<li><a
target="_blank" rel="noopener" href="https://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days">https://www.sigbus.info/how-i-wrote-a-self-hosting-c-compiler-in-40-days</a></li>
</ul></li>
</ul>
<h2 id="assembler">Assembler</h2>
<ul>
<li>将.s的汇编文件输出为.o二进制文件
<ul>
<li>读和使用Directives （区分代码段, 文本段，指令等）
<ul>
<li>Directives并不会被转换为机器代码</li>
<li>text:
该指令后的项目被放置在用户文本段中。通常，这是程序的机器代码部分，即实际的指令。</li>
<li>.data:
该指令后的项目被放置在用户数据段中。这是程序中的静态数据，如变量和常量。它存储源文件中数据的二进制表示。</li>
<li>.globl sym:
这声明了一个全局符号，这意味着该符号可以在其他文件中被引用。例如，这可以是一个在一个文件中定义但在其他文件中使用的函数或变量。</li>
<li>.asciiz str:
这将字符串str存储在内存中，并在其后添加一个null终止符。这是一个常用的方法，用于在C语言中表示字符串，因为C语言的字符串是以null字符（值为0的字符）终止的。</li>
<li>.word w1...wn: 这将连续的n个32位的数值存储在连续的内存单元中。</li>
</ul></li>
<li>替换伪指令</li>
<li>转换为机器语言（输出为目标文件）
<ul>
<li>在链接以前，需要解决一个符号引用的问题，例如label的跳转，从实际的内存中加载数据，这些需要精确的32位内存，而我们在汇编阶段是不可能确定的。这也叫做前向引用问题，这个问题可以通过维护一个<code>符号表</code>
和一个<code>重定位表</code>，运行多次<code>Assembler</code>来解决。</li>
<li>目标文件在<code>unix</code>和<code>Linux</code>
平台往往是<code>ELF</code>格式的</li>
<li>对象文件头 (object file
header)：这是目标文件的元信息部分，它提供了文件中其他部分的大小和位置。此头部标识了文件的类型（例如，是否是一个可执行文件，一个目标文件，还是一个共享库）以及其他关于文件的基本属性。</li>
<li>文本段 (text
segment)：这部分包含程序的实际机器代码。当程序运行时，这部分代码会被加载到内存并执行。</li>
<li>数据段 (data
segment)：此部分包含程序的静态数据和全局变量。在程序运行时，它们会被加载到内存中，供程序访问和修改。</li>
<li>重定位表 (relocation
table)：如前所述，重定位表列出了所有需要在连接时或运行时被“处理”或“修复”的代码位置。这是因为在编译时，编译器可能不知道所有外部引用的确切内存地址。</li>
<li>符号表 (symbol
table)：此表包含文件中定义和引用的所有符号（例如函数名和变量名）的列表。它帮助链接器解析外部和内部符号引用，以确保正确的链接。</li>
<li>调试信息 (debugging
information)：对于那些编译时带有调试信息的文件，这部分包含了源代码级别的信息，如变量名、行号等。这使得调试工具（如
gdb）可以在运行时映射机器代码回到其原始的源代码位置。</li>
<li><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698912220821-c1ba5ab6-6c27-41b3-b951-1b0486ecafbe.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698912220821-c1ba5ab6-6c27-41b3-b951-1b0486ecafbe.pdf%22%2C%22name%22%3A%22ELF_Format.pdf%22%2C%22size%22%3A152347%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22u19c8bb18-bc03-42de-ae26-29a20f2ad29%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22mode%22%3A%22title%22%2C%22id%22%3A%22ue7897fdb%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">ELF_Format.pdf</a></li>
</ul></li>
</ul></li>
</ul>
<h2 id="linker">Linker</h2>
<ul>
<li>把多个汇编产生的二进制文件组合到一个可执行文件里
<ul>
<li>多个有什么好处呢？某个部分改变了，那我们不需要重新编译整个工程</li>
<li>Link
Editor的旧名叫Link，因为它过去大部分的任务就是处理跳转带来的引用被正确的解析为内存地址，以及填充所有绝对地址</li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002998.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>有三种不同的地址（Adress）</li>
</ul>
<ol type="1">
<li><strong>PC-Relative Addressing (beq, bne, jal)</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：与程序计数器（PC）相关的地址方式。这意味着跳转的目标地址是基于当前指令的地址加上或减去一个偏移量来确定的。</li>
<li><strong>应用场景</strong>：常用于条件分支指令，如<code>beq</code>（等于则跳转）和<code>bne</code>（不等于则跳转），以及无条件跳转<code>jal</code>。</li>
<li><strong>补充</strong>：这种地址方式不会重新定位。这是因为它们的目标地址是动态计算的，不需要预先知道绝对地址。</li>
</ul>
<ol start="2" type="1">
<li><strong>External Function Reference (usually jal)</strong></li>
</ol>
<ul>
<li><strong>特点</strong>：用于引用外部函数。这些函数的确切地址直到链接时才能确定。</li>
<li><strong>应用场景</strong>：在调用库函数或其他模块中的函数时经常使用。</li>
<li><strong>补充</strong>：这种引用在链接时总是需要重新定位，因为在编译时不知道函数的确切地址。</li>
</ul>
<ol start="3" type="1">
<li><strong>Static Data Reference (often auipc and addi)</strong></li>
</ol>
<ul>
<li><p><strong>特点</strong>：用于引用静态数据，如全局变量或常量。</p></li>
<li><p><strong>应用场景</strong>：当程序需要访问静态数据时使用。</p></li>
<li><p><strong>补充</strong>：在RISC-V中，通常使用<code>auipc</code>（将PC值与一个20位的立即数相加并存储结果）和<code>addi</code>（将寄存器值与一个12位的立即数相加）指令组合来构造完整的32位地址。与使用<code>lui</code>（加载上位立即数到寄存器）不同，使用<code>auipc</code>可以确保大块数据可以在链接时重新定位，只要它相对于PC是固定的。</p></li>
<li><p>解决重引用问题</p>
<ul>
<li>Linker假设可执行文件的第一个<code>word</code>以及第一个<code>text</code>段的启始地址为0x10000
(针对RISC-V）
<ul>
<li>Linker知道<code>text</code>段以及<code>word</code>顺序及其各自的大小</li>
<li>Linker可以根据这些计算出每一个<code>label</code>以及每一块<code>data</code>的绝对地址
<ul>
<li>在符号表内寻找符号，找不到就去<code>library file</code></li>
<li>绝对地址只要被确定，那么就转换为机器代码</li>
<li>输出包含<code>text</code>和<code>data</code>以及<code>header</code>的可执行文件</li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h2 id="loader">Loader</h2>
<ul>
<li>接受可执行文件，并执行
<ul>
<li>从硬盘中读取可执行文件，加载到内存中，然后运行</li>
<li>这是由操作系统提供的功能</li>
</ul></li>
<li>大致有6步
<ul>
<li><strong>文件读取</strong>：加载器首先读取可执行文件的头部，以确定文本和数据段的大小。</li>
<li><strong>地址空间的创建</strong>：为包含文本和数据段的程序创建新的地址空间，此空间还包含一个堆栈段。</li>
<li><strong>指令与数据的复制</strong>：将来自可执行文件的指令和数据复制到新创建的地址空间中。</li>
<li><strong>参数复制</strong>：将传递给程序的参数复制到堆栈上。</li>
<li><strong>机器寄存器的初始化</strong>：
<ul>
<li>清除大多数寄存器。</li>
<li>初始化堆栈指针，使其指向堆栈的第一个可用位置。</li>
</ul></li>
<li><strong>启动程序</strong>：
<ul>
<li>跳转到启动例程，该例程从堆栈复制程序的参数到寄存器，并设置程序计数器（PC）。</li>
<li>如果主程序返回，启动例程将使用退出系统调用来终止程序。</li>
</ul></li>
</ul></li>
<li>Example</li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002999.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<ul>
<li>Auipc消失了
<ul>
<li>实际上是被优化为了立即数寻址</li>
</ul></li>
</ul>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002000.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<h1 id="lecture-10-combinational-logic">Lecture 10 Combinational
Logic</h1>
<p><a
target="_blank" rel="noopener" href="https://www.yuque.com/attachments/yuque/0/2023/pdf/22918222/1698920964742-d9ac9225-2738-4c1d-b9b2-83b6abd9729e.pdf?_lake_card=%7B%22src%22%3A%22https%3A%2F%2Fwww.yuque.com%2Fattachments%2Fyuque%2F0%2F2023%2Fpdf%2F22918222%2F1698920964742-d9ac9225-2738-4c1d-b9b2-83b6abd9729e.pdf%22%2C%22name%22%3A%22lec10.pdf%22%2C%22size%22%3A8535908%2C%22ext%22%3A%22pdf%22%2C%22source%22%3A%22%22%2C%22status%22%3A%22done%22%2C%22download%22%3Atrue%2C%22taskId%22%3A%22ub71ff804-0638-40a4-b174-0f77b69acaa%22%2C%22taskType%22%3A%22upload%22%2C%22type%22%3A%22application%2Fpdf%22%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22u7bfa9027%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22file%22%7D">lec10.pdf</a>
# Lab ## Lab 0</p>
<ul>
<li>常用的Cli快捷键
<ul>
<li><code>ctrl+u</code> 删除整行</li>
<li><code>ctrl+a</code> 移动到行首</li>
<li><code>ctrl+e</code> 移动到行尾</li>
<li><code>ctrl+r</code> 查询近期的命令<br />
</li>
</ul></li>
<li>文件操作
<ul>
<li>创建一个空文件 <code>touch a.txt</code></li>
<li>写入一些内容 <code>echo "hello world" &gt; a.txt</code></li>
<li>查看文件内容 <code>cat a.txt</code></li>
<li>比较两个文件内容的差别 <code>diff a b</code></li>
</ul></li>
<li>查看命令手册，以echo为例
<ul>
<li><code>man echo | less</code></li>
</ul></li>
<li>Vim</li>
<li>Git</li>
</ul>
<h2 id="lab-1">Lab 1</h2>
<ul>
<li><p>task1 通过修改eccentric.c中的宏得到如下的输出 <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">Berkeley eccentrics:<br>====================<br>Happy Happy Happy<br>Yoshua<br>Go BEARS!<br></code></pre></td></tr></table></figure>
没什么难度，就是又忘了gcc咋编译了 <img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002001.png" srcset="/img/loading.gif" lazyload
alt="image.png" /></p></li>
<li><p>task2 用gdb</p></li>
</ul>
<ol type="1">
<li><p>While you’re in a gdb session, how do you <strong>set the
arguments</strong> that will be passed to the program when it’s
run?</p></li>
<li><p>How do you <strong>create a breakpoint</strong>?</p></li>
<li><p>How do you <strong>execute the next line of C code</strong> in
the program after stopping at a breakpoint?</p></li>
<li><p>If the next line of code is a function call, you’ll execute the
whole function call at once if you use your answer to #3. (If not,
consider a different command for #3!) How do you tell GDB that you
<strong>want to debug the code inside the function</strong> (i.e. step
into the function) instead? (If you changed your answer to #3, then that
answer is most likely now applicable here.)</p></li>
<li><p>How do you <strong>continue the program after stopping</strong>
at a breakpoint?</p></li>
<li><p>How can you <strong>print the value of a variable</strong> (or
even an expression like 1+2) in gdb?</p></li>
<li><p>How do you configure gdb so it <strong>displays the value of a
variable after every step</strong>?</p></li>
<li><p>How do you <strong>show a list of all variables and their
values</strong> in the current function?</p></li>
<li><p>How do you <strong>quit</strong> out of gdb?</p></li>
<li><p>use <code>set args arg1 arg2 arg3</code></p></li>
<li><p>use <code>break file.c:2</code></p></li>
<li><p><code>step</code> or <code>next</code>, but for stander fuc like
"printf" ,do not use step but next, cz stander func has no source code,
major of cases they are very low-level</p></li>
<li><p><code>step</code></p></li>
<li><p><code>continue</code></p></li>
<li><p><code>print a+b</code> and a or b respents the real
variables.</p></li>
<li><p>use <code>display a</code>, and <code>undisplay a</code>
cancel.</p></li>
<li><p><code>info locals</code></p></li>
<li><p><code>exit</code></p></li>
</ol>
<ul>
<li><p>task3 重定向</p>
<ul>
<li>./task &lt; input.out</li>
<li>run &lt; input.out &gt; output.out</li>
</ul></li>
<li><p>task4 Valgrind</p></li>
<li><p>task5 回环链表 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">ll_has_cycle</span><span class="hljs-params">(node *head)</span> &#123;<br>    node* fast = head;<br>    node* slow = head;<br>    <span class="hljs-keyword">while</span>(fast!=<span class="hljs-literal">NULL</span>&amp;&amp;fast-&gt;next!=<span class="hljs-literal">NULL</span>)&#123;<br>        fast = fast-&gt;next-&gt;next;<br>        slow = slow-&gt;next;<br>        <span class="hljs-keyword">if</span>(fast == slow)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p></li>
</ul>
<h2 id="lab-2">Lab 2</h2>
<ul>
<li>Makefile 解释</li>
</ul>
<ol type="1">
<li><p>Which target is part of a rule that deletes all the compiled
programs?</p></li>
<li><p>Which target is part of a rule that makes all the compiled
programs?</p></li>
<li><p>Which compiler is currently being used?</p></li>
<li><p>What C standard are we currently using?</p></li>
<li><p>How would we reference a variable FOO in a makefile?</p></li>
<li><p>What operating system does the term “Darwin” represent?</p></li>
<li><p>What line creates the lfsr program from its object files? (Give
its line number.)</p></li>
<li><p>删除所有已编译程序的规则的目标是
<code>clean</code>。它用于清理和删除生成的文件。</p></li>
<li><p>制作所有已编译程序的规则的目标是
<code>all</code>。这是默认目标，运行 <code>make</code>
而不指定目标将构建所有已编译程序。</p></li>
<li><p>当前正在使用的编译器是 <code>gcc</code>，如 <code>CC</code>
变量中所指定的。</p></li>
<li><p>当前正在使用的C标准是C99，如<code>CFLAGS</code>变量中的<code>-std=c99</code>标志所指定。</p></li>
<li><p>要在Makefile中引用变量 <code>FOO</code>，使用 <code>$(FOO)</code>
表示。</p></li>
</ol>
<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 1. Variables and conditionals</span><br>UNAME_S := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -s)</span><br>CC=gcc<br>LD=gcc<br>CFLAGS=-ggdb -Wall -std=c99<br>LDFLAGS=<br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(UNAME_S)</span>, Darwin)<br>    MEMCHECK=valgrind --tool=memcheck --leak-check=full --track-origins=yes --dsymutil=yes --suppressions=osx_vector.supp<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(UNAME_S)</span>, Linux)<br>    MEMCHECK=valgrind --tool=memcheck --leak-check=full --track-origins=yes<br><span class="hljs-keyword">endif</span><br><br><span class="hljs-comment"># 2. Targets and their object files</span><br>BIT_OPS_OBJS = bit_ops.o test_bit_ops.o<br>BIT_OPS_PROG = bit_ops<br><br>LFSR_OBJS = lfsr.o test_lfsr.o<br>LFSR_PROG = lfsr<br><br>VECTOR_OBJS=vector.o vector_test.o<br>VECTOR_PROG=vector_test<br><br>LIST_OBJS=test_list.o list.o<br>LIST_PROG=list<br><br>BINARIES=<span class="hljs-variable">$(VECTOR_PROG)</span> <span class="hljs-variable">$(BIT_OPS_PROG)</span> <span class="hljs-variable">$(LFSR_PROG)</span> <span class="hljs-variable">$(LIST_PROG)</span><br><br><span class="hljs-comment"># 3. Compilation and linking rules</span><br><span class="hljs-section">all: <span class="hljs-variable">$(BINARIES)</span></span><br><br><span class="hljs-variable">$(BIT_OPS_PROG)</span>: <span class="hljs-variable">$(BIT_OPS_OBJS)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -g -o <span class="hljs-variable">$(BIT_OPS_PROG)</span> <span class="hljs-variable">$(BIT_OPS_OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span><br><br><span class="hljs-variable">$(LFSR_PROG)</span>: <span class="hljs-variable">$(LFSR_OBJS)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -g -o <span class="hljs-variable">$(LFSR_PROG)</span> <span class="hljs-variable">$(LFSR_OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span><br><br><span class="hljs-variable">$(VECTOR_PROG)</span>: <span class="hljs-variable">$(VECTOR_OBJS)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -g -o <span class="hljs-variable">$(VECTOR_PROG)</span> <span class="hljs-variable">$(VECTOR_OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span><br><br><span class="hljs-variable">$(LIST_PROG)</span>: <span class="hljs-variable">$(LIST_OBJS)</span><br>	<span class="hljs-variable">$(CC)</span> <span class="hljs-variable">$(CFLAGS)</span> -g -o <span class="hljs-variable">$(LIST_PROG)</span> <span class="hljs-variable">$(LIST_OBJS)</span> <span class="hljs-variable">$(LDFLAGS)</span><br><br><span class="hljs-section">.c.o:</span><br>	<span class="hljs-variable">$(CC)</span> -c <span class="hljs-variable">$(CFLAGS)</span> <span class="hljs-variable">$&lt;</span><br><br><span class="hljs-section">vector-memcheck: <span class="hljs-variable">$(VECTOR_PROG)</span></span><br>	<span class="hljs-variable">$(MEMCHECK)</span> ./<span class="hljs-variable">$(VECTOR_PROG)</span><br><br><span class="hljs-comment"># 4. Header dependencies</span><br><span class="hljs-section">lfsr.c: lfsr.h</span><br><span class="hljs-section">test_lfsr.c: lfsr.h</span><br><br><span class="hljs-section">bit_ops.c: bit_ops.h</span><br><span class="hljs-section">test_bit_ops.c: bit_ops.h</span><br><br><span class="hljs-section">vector.c: vector.h</span><br><span class="hljs-section">vector_test.c: vector.h</span><br><br><span class="hljs-section">list.c: list.h</span><br><span class="hljs-section">list_test.c: list.h</span><br><br><span class="hljs-comment"># 5. Other commands</span><br><span class="hljs-section">clean:</span><br>	-rm -rf core *.o *~ <span class="hljs-string">&quot;#&quot;</span>*<span class="hljs-string">&quot;#&quot;</span> Makefile.bak <span class="hljs-variable">$(BINARIES)</span> *.dSYM<br><br></code></pre></td></tr></table></figure>
<ol type="1">
<li><code>UNAME_S := $(shell uname -s)</code>：这一行使用<code>uname -s</code>命令来获取当前操作系统的名称，并将其保存在<code>UNAME_S</code>变量中。</li>
<li>定义一些编译器和编译选项的变量：</li>
</ol>
<ul>
<li><code>CC</code>：C编译器，设置为<code>gcc</code>。</li>
<li><code>LD</code>：链接器，也设置为<code>gcc</code>。</li>
<li><code>CFLAGS</code>：编译器选项，包括<code>-ggdb</code>（生成调试信息）、<code>-Wall</code>（显示警告）、<code>-std=c99</code>（使用C99标准）等。</li>
<li><code>LDFLAGS</code>：链接器选项，目前为空，可以用于添加链接选项。</li>
</ul>
<ol start="3" type="1">
<li>根据操作系统设置<code>MEMCHECK</code>变量，用于在不同操作系统上运行内存检查工具（Valgrind）时使用不同的选项。在Darwin（macOS）上，设置了一组选项，而在Linux上设置了另一组选项。</li>
<li>定义了三个目标的相关变量：</li>
</ol>
<ul>
<li><code>BIT_OPS_OBJS</code>：用于存储与位操作相关的目标文件的名称。</li>
<li><code>LFSR_OBJS</code>：用于存储与线性反馈移位寄存器相关的目标文件的名称。</li>
<li><code>VECTOR_OBJS</code>：用于存储与向量操作相关的目标文件的名称。</li>
</ul>
<ol start="5" type="1">
<li>定义了三个可执行程序的名称：</li>
</ol>
<ul>
<li><code>BIT_OPS_PROG</code>：位操作相关的可执行程序名称。</li>
<li><code>LFSR_PROG</code>：线性反馈移位寄存器相关的可执行程序名称。</li>
<li><code>VECTOR_PROG</code>：向量操作相关的可执行程序名称。</li>
</ul>
<ol start="6" type="1">
<li>定义了一个包含所有可执行程序名称的变量<code>BINARIES</code>。</li>
<li><code>all: $(BINARIES)</code>：这是默认目标，表示运行<code>make</code>命令时将构建所有的可执行程序。</li>
<li>下面是各个可执行程序的构建规则。每个规则指定了可执行程序的依赖项（目标文件）和如何构建它们。例如，<code>$(BIT_OPS_PROG)</code>的构建规则包括将<code>$(BIT_OPS_OBJS)</code>链接到一起，然后使用指定的编译器和选项生成可执行文件。</li>
<li>下面的规则用于生成目标文件（.o文件）：<code>.c.o:</code>。它告诉Make如何将C源文件编译成目标文件。它使用了<code>$(CC)</code>和<code>$(CFLAGS)</code>变量来执行编译。</li>
<li><code>vector-memcheck: $(VECTOR_PROG)</code>：这是一个自定义的目标，用于运行Valgrind内存检查工具来测试<code>$(VECTOR_PROG)</code>程序。</li>
<li><code>clean:</code>：这是一个用于清理项目的目标。它删除生成的可执行文件、目标文件、临时文件等。<code>-rm</code>表示即使文件不存在也不会生成错误消息，因此可以安全地删除文件。</li>
<li>最后，有一些依赖关系规则，用于确保源文件（.c文件）与相关的头文件（.h文件）之间的一致性。</li>
</ol>
<p>通过在命令行中运行<code>make</code>并选择目标，可以构建可执行程序，运行内存检查，或者执行清理操作，具体取决于需求。例如，要构建所有的可执行程序，只需运行<code>make</code>。要运行<code>vector_test</code>的内存检查，可以运行<code>make vector-memcheck</code>。要清理项目，可以运行<code>make clean</code>。</p>
<ul>
<li>Bit operations
<ul>
<li>只能用&amp;，^，以及 ｜</li>
<li>不能循环，不能除法，不能取模 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;bit_ops.h&quot;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">unsigned</span> mp[<span class="hljs-number">32</span>] = &#123;<br>    <span class="hljs-number">0x80000000</span>,<br>    <span class="hljs-number">0x40000000</span>,<br>    <span class="hljs-number">0x20000000</span>,<br>    <span class="hljs-number">0x10000000</span>,<br>    <span class="hljs-number">0x08000000</span>,<br>    <span class="hljs-number">0x04000000</span>,<br>    <span class="hljs-number">0x02000000</span>,<br>    <span class="hljs-number">0x01000000</span>,<br>    <span class="hljs-number">0x00800000</span>,<br>    <span class="hljs-number">0x00400000</span>,<br>    <span class="hljs-number">0x00200000</span>,<br>    <span class="hljs-number">0x00100000</span>,<br>    <span class="hljs-number">0x00080000</span>,<br>    <span class="hljs-number">0x00040000</span>,<br>    <span class="hljs-number">0x00020000</span>,<br>    <span class="hljs-number">0x00010000</span>,<br>    <span class="hljs-number">0x00008000</span>,<br>    <span class="hljs-number">0x00004000</span>,<br>    <span class="hljs-number">0x00002000</span>,<br>    <span class="hljs-number">0x00001000</span>,<br>    <span class="hljs-number">0x00000800</span>,<br>    <span class="hljs-number">0x00000400</span>,<br>    <span class="hljs-number">0x00000200</span>,<br>    <span class="hljs-number">0x00000100</span>,<br>    <span class="hljs-number">0x00000080</span>,<br>    <span class="hljs-number">0x00000040</span>,<br>    <span class="hljs-number">0x00000020</span>,<br>    <span class="hljs-number">0x00000010</span>,<br>    <span class="hljs-number">0x00000008</span>,<br>    <span class="hljs-number">0x00000004</span>,<br>    <span class="hljs-number">0x00000002</span>,<br>    <span class="hljs-number">0x00000001</span><br>    &#125;;<br><br><span class="hljs-comment">// Return the nth bit of x.</span><br><span class="hljs-comment">// Assume 0 &lt;= n &lt;= 31</span><br><span class="hljs-type">unsigned</span> <span class="hljs-title function_">get_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> x,<span class="hljs-type">unsigned</span> n)</span>&#123;<br>    n = <span class="hljs-number">31</span> - n;<br><br>    <span class="hljs-keyword">if</span>((x &amp; mp[n])!=<span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">// Set the nth bit of the value of x to v.</span><br><span class="hljs-comment">// Assume 0 &lt;= n &lt;= 31, and v is 0 or 1</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">set_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> * x,</span><br><span class="hljs-params">             <span class="hljs-type">unsigned</span> n,</span><br><span class="hljs-params">             <span class="hljs-type">unsigned</span> v)</span> &#123;<br>    n = <span class="hljs-number">31</span> - n;<br>    <span class="hljs-type">unsigned</span> mpn = mp[n];<br>    <span class="hljs-keyword">if</span>(v == <span class="hljs-number">0</span>)&#123;<br>        mpn = mpn ^ <span class="hljs-number">0xFFFFFFFF</span>;<br>        *x = *x &amp; mpn;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(v == <span class="hljs-number">1</span>)<br>        *x = *x | mpn;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><span class="hljs-comment">// Flip the nth bit of the value of x.</span><br><span class="hljs-comment">// Assume 0 &lt;= n &lt;= 31</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">flip_bit</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> * x,</span><br><span class="hljs-params">              <span class="hljs-type">unsigned</span> n)</span> &#123;<br>    <span class="hljs-type">unsigned</span> flipped_value = get_bit(*x, n) ^ <span class="hljs-number">1</span>;<br>    set_bit(x, n, flipped_value);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure></li>
</ul></li>
<li>LSFR
线性反馈移位寄存器线性反馈移位寄存器（LFSR）是数字系统中的一种常见结构，它具有多种应用：</li>
</ul>
<ol type="1">
<li><strong>伪随机数生成器 (PRNG)</strong>：LFSR
是一种有效的方式来生成伪随机数序列。由于其固定的结构和特性，它可以在硬件中非常高效地实现，而不需要大量的存储空间或复杂的算法。</li>
<li><strong>测试模式生成</strong>：在硬件测试中，LFSR
常用于生成测试模式，特别是在内存和逻辑电路的内建自测 (BIST, Built-In
Self-Test) 中。</li>
<li><strong>数据加密和解密</strong>：由于其伪随机性，LFSR
可以用于流密码中的密钥流生成。它们生成的位流可以与数据流进行异或操作来加密或解密信息。</li>
<li><strong>误差检测和纠正</strong>：LFSR 可用于生成和检测多项式编码，如
CRC (循环冗余检查)。这些编码用于检测数据传输中的错误。</li>
<li><strong>数字通信</strong>：LFSR
用于扩频通信技术，例如直接序列扩频。</li>
<li><strong>信号扩展</strong>：在某些应用中，LFSR
可用于将较短的信号序列扩展为更长的序列。</li>
</ol>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202311030002002.png" srcset="/img/loading.gif" lazyload
alt="image.png" />
<figcaption aria-hidden="true">image.png</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">lfsr_calculate</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> *reg)</span> &#123;<br>    <span class="hljs-type">short</span> loc[] = &#123;<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>&#125;;<br>    <span class="hljs-type">uint16_t</span> fill = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;<br>        fill ^= (*reg &gt;&gt; loc[i]) &amp; <span class="hljs-number">1</span>;<br>    &#125;<br>    *reg = *reg &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(fill == <span class="hljs-number">1</span>)&#123;<br>        *reg = *reg | (<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>);<br>    &#125;<br>    <span class="hljs-comment">// 不需要填充0，因为向右移位操作已经为最左边的位设置了0</span><br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>LinkList
<ul>
<li>太熟悉了直接放代码</li>
<li>想一下为什么传指针时是<code>**p</code>而不是<code>*p</code>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Add a node to the end of the linked list. Assume head_ptr is non-null. */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">append_node</span><span class="hljs-params">(node** head_ptr, <span class="hljs-type">int</span> new_data)</span> </span>&#123;<br>    node *new_node = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(node));  <span class="hljs-comment">// 更改变量名为new_node</span><br>    <span class="hljs-keyword">if</span> (new_node == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-comment">// 处理内存分配失败的情况，例如返回或退出</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    new_node-&gt;val = new_data;<br>    new_node-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (*head_ptr == <span class="hljs-literal">NULL</span>) &#123;<br>        *head_ptr = new_node;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    node* curr = *head_ptr;<br>    <span class="hljs-keyword">while</span> (curr-&gt;next != <span class="hljs-literal">NULL</span>) &#123;<br>        curr = curr-&gt;next;<br>    &#125;<br>    curr-&gt;next = new_node;  <span class="hljs-comment">// 连接新节点到链表的尾部</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Reverse a linked list in place (in other words, without creating a new list).</span><br><span class="hljs-comment">   Assume that head_ptr is non-null. */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reverse_list</span> <span class="hljs-params">(node** head_ptr)</span> </span>&#123;<br>        node* prev = <span class="hljs-literal">NULL</span>;<br>        node* curr = *head_ptr;<br>        node* next = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-keyword">if</span>(curr==<span class="hljs-literal">NULL</span> || curr-&gt;next == <span class="hljs-literal">NULL</span>)<br>          <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">while</span> (curr != <span class="hljs-literal">NULL</span>) &#123;<br>                next = curr-&gt;next;<br>                curr-&gt;next = prev;<br>                prev = curr;<br>                curr = next;<br>        &#125;<br>        <span class="hljs-comment">/* Set the new head to be what originally was the last node in the list */</span><br>        *head_ptr = prev;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<ul>
<li>vector <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> CS61C_VECTOR_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CS61C_VECTOR_H_</span><br><span class="hljs-comment">/* vector.h originally written by Jeremy Huddleston &lt;jeremyhu@eecs.berkeley.edu&gt; Sp2004</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * So it looks like you&#x27;ve decided to venture into the &quot;other&quot; files of this</span><br><span class="hljs-comment"> * lab.  Good.  C Header files (the .h extension) are a way of telling other .c</span><br><span class="hljs-comment"> * files what they can have access to.  You usually include stdlib.h in your</span><br><span class="hljs-comment"> * C programs, and this process is identical to including this .h file with the</span><br><span class="hljs-comment"> * one change being:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * #include &quot;file.h&quot;</span><br><span class="hljs-comment"> * versus</span><br><span class="hljs-comment"> * #include &lt;file.h&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The difference is that the &lt;&gt; notation is for system header files and the &quot;&quot;</span><br><span class="hljs-comment"> * is for ones you provide yourself (in your local directory for instance).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The header file starts off with</span><br><span class="hljs-comment"> * #ifndef CS61C_VECTOR_H_</span><br><span class="hljs-comment"> * #define CS61C_VECTOR_H_</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * and ends with a final #endif.  This prevents the file from being included</span><br><span class="hljs-comment"> * more than once which could&#x27;ve possibly resulted in an infinite loop of</span><br><span class="hljs-comment"> * file inclusions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * First, we define the &#x27;vector_t&#x27; datatype.  This next line says that a &#x27;vector_t&#x27;</span><br><span class="hljs-comment"> * is the same as a &#x27;struct vector_t&#x27;.  So anywhere in the code after this, we</span><br><span class="hljs-comment"> * can use &#x27;vector_t *&#x27; to mean a pointer to a &#x27;struct vector_t&#x27; (which is defined in</span><br><span class="hljs-comment"> * vector.c).  We can get away with doing this even though we don&#x27;t know what a</span><br><span class="hljs-comment"> * struct vector is because all struct pointers have the same representation in memory.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">vector_t</span> <span class="hljs-title">vector_t</span>;</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> *  Next, we provide the prototypes for the functions defined in vector.c.  This</span><br><span class="hljs-comment"> *  is a way of telling the .c files that #include this header what they will</span><br><span class="hljs-comment"> *  have access to.</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/* Create a new vector */</span><br><span class="hljs-type">vector_t</span> *<span class="hljs-title function_">vector_new</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">/* Free up the memory allocated for the passed vector */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vector_delete</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v)</span>;<br><br><span class="hljs-comment">/* Return the value in the vector */</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">vector_get</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc)</span>;<br><br><span class="hljs-comment">/* Set a value in the vector */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vector_set</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc, <span class="hljs-type">int</span> value)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br></code></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* Include the system headers we need */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-comment">/* Include our header */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;vector.h&quot;</span></span><br><br><span class="hljs-comment">/* Define what our struct is */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">vector_t</span> &#123;<br>    <span class="hljs-type">size_t</span> size;<br>    <span class="hljs-type">int</span> *data;<br>&#125;;<br><br><span class="hljs-comment">/* Utility function to handle allocation failures. In this</span><br><span class="hljs-comment">   case we print a message and exit. */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">allocation_failed</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;Out of memory.\n&quot;</span>);<br>    <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/* Bad example of how to create a new vector */</span><br><span class="hljs-function"><span class="hljs-type">vector_t</span> *<span class="hljs-title">bad_vector_new</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//这段代码在栈上创建了一个vector，而返回的内存地址会在函数执行完后销毁</span><br>    <span class="hljs-comment">/* Create the vector and a pointer to it */</span><br>    <span class="hljs-type">vector_t</span> *retval, v;<br>    retval = &amp;v;<br><br>    <span class="hljs-comment">/* Initialize attributes */</span><br>    retval-&gt;size = <span class="hljs-number">1</span>;<br>    retval-&gt;data = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (retval-&gt;data == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">allocation_failed</span>();<br>    &#125;<br><br>    retval-&gt;data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br><br><span class="hljs-comment">/* Another suboptimal way of creating a vector */</span><br><span class="hljs-comment">// 同样的，在栈上创建了一个vector</span><br><span class="hljs-function"><span class="hljs-type">vector_t</span> <span class="hljs-title">also_bad_vector_new</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/* Create the vector */</span><br>    <span class="hljs-type">vector_t</span> v;<br><br>    <span class="hljs-comment">/* Initialize attributes */</span><br>    v.size = <span class="hljs-number">1</span>;<br>    v.data = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>    <span class="hljs-keyword">if</span> (v.data == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">allocation_failed</span>();<br>    &#125;<br>    v.data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br><br><span class="hljs-comment">/* Create a new vector with a size (length) of 1</span><br><span class="hljs-comment">   and set its single component to zero... the</span><br><span class="hljs-comment">   RIGHT WAY */</span><br><span class="hljs-function"><span class="hljs-type">vector_t</span> *<span class="hljs-title">vector_new</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">/* Declare what this function will return */</span><br>    <span class="hljs-type">vector_t</span> *retval;<br><br>    <span class="hljs-comment">/* First, we need to allocate memory on the heap for the struct */</span><br>    retval = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">vector_t</span>));<br><br>    <span class="hljs-comment">/* Check our return value to make sure we got memory */</span><br>    <span class="hljs-keyword">if</span> (retval == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">allocation_failed</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* Now we need to initialize our data.</span><br><span class="hljs-comment">       Since retval-&gt;data should be able to dynamically grow,</span><br><span class="hljs-comment">       what do you need to do? */</span><br>    retval-&gt;size = <span class="hljs-number">1</span>;<br>    retval-&gt;data = <span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br><br>    <span class="hljs-comment">/* Check the data attribute of our vector to make sure we got memory */</span><br>    <span class="hljs-keyword">if</span> (retval-&gt;data == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">free</span>(retval);				<span class="hljs-comment">//Why is this line necessary?</span><br>        <span class="hljs-built_in">allocation_failed</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* Complete the initialization by setting the single component to zero */</span><br>    retval-&gt;data[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/* and return... */</span><br>    <span class="hljs-keyword">return</span> retval;<br>&#125;<br><br><span class="hljs-comment">/* Return the value at the specified location/component &quot;loc&quot; of the vector */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">vector_get</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc)</span> </span>&#123;<br><br>    <span class="hljs-comment">/* If we are passed a NULL pointer for our vector, complain about it and exit. */</span><br>    <span class="hljs-keyword">if</span>(v == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">fprintf</span>(stderr, <span class="hljs-string">&quot;vector_get: passed a NULL vector.\n&quot;</span>);<br>        <span class="hljs-built_in">abort</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/* If the requested location is higher than we have allocated, return 0.</span><br><span class="hljs-comment">     * Otherwise, return what is in the passed location.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (loc &lt; v-&gt;size) &#123;<br>	<span class="hljs-keyword">return</span> v-&gt;data[loc];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* Free up the memory allocated for the passed vector.</span><br><span class="hljs-comment">   Remember, you need to free up ALL the memory that was allocated. */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vector_delete</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v)</span> </span>&#123;<br>    <span class="hljs-built_in">free</span>(v-&gt;data);<br>    <span class="hljs-built_in">free</span>(v);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* Set a value in the vector. If the extra memory allocation fails, call</span><br><span class="hljs-comment">   allocation_failed(). */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">vector_set</span><span class="hljs-params">(<span class="hljs-type">vector_t</span> *v, <span class="hljs-type">size_t</span> loc, <span class="hljs-type">int</span> value)</span> </span>&#123;<br>    <span class="hljs-comment">/* What do you need to do if the location is greater than the size we have</span><br><span class="hljs-comment">     * allocated?  Remember that unset locations should contain a value of 0.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span>(loc &lt; v-&gt;size) &#123;<br>        v-&gt;data[loc] = value;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-type">int</span> *new_data = <span class="hljs-built_in">realloc</span>(v-&gt;data, (loc + <span class="hljs-number">1</span>) * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>));<br>        <span class="hljs-keyword">if</span>(!new_data) &#123;<br>            <span class="hljs-built_in">allocation_failed</span>();<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">size_t</span> i = v-&gt;size; i &lt;= loc; i++) &#123;<br>            new_data[i] = <span class="hljs-number">0</span>;<br>        &#125;<br>        v-&gt;data = new_data;<br>        v-&gt;size = loc + <span class="hljs-number">1</span>;<br>        v-&gt;data[loc] = value;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="lab3">Lab3</h2>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/">#笔记</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>cs16c</div>
      <div>http://shuaizhang1998.github.io/2023/11/03/CS61C/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zs</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月3日</div>
        </div>
      
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/09/30/Introductory%20C%20Programming%20Specialization/" title="c/c++">
                        <span class="hidden-mobile">c/c++</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
