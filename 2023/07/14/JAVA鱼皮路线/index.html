

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zs">
  <meta name="keywords" content="">
  
    <meta name="description" content="JDK的安装与配置 1.下载jdk-8并安装 https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;downloads&#x2F;#java8-windows 在安装过程中程序会提醒是否安装jre，jre是运行字节码文件的运行环境，jdk是开发环境。   image-20230126132016921  2.在系统变量里新建两个系统变量 12345678(1)JAVA_HOMEj">
<meta property="og:type" content="article">
<meta property="og:title" content="Avaj!">
<meta property="og:url" content="http://shuaizhang1998.github.io/2023/07/14/JAVA%E9%B1%BC%E7%9A%AE%E8%B7%AF%E7%BA%BF/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JDK的安装与配置 1.下载jdk-8并安装 https:&#x2F;&#x2F;www.oracle.com&#x2F;java&#x2F;technologies&#x2F;downloads&#x2F;#java8-windows 在安装过程中程序会提醒是否安装jre，jre是运行字节码文件的运行环境，jdk是开发环境。   image-20230126132016921  2.在系统变量里新建两个系统变量 12345678(1)JAVA_HOMEj">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-07-14T14:07:27.799Z">
<meta property="article:modified_time" content="2023-07-14T14:09:38.262Z">
<meta property="article:author" content="Zs">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>Avaj! - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shuaizhang1998.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Avaj!"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-14 22:07" pubdate>
          2023年7月14日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          40k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          334 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Avaj!</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="jdk的安装与配置">JDK的安装与配置</h2>
<p>1.下载jdk-8并安装</p>
<p>https://www.oracle.com/java/technologies/downloads/#java8-windows</p>
<p>在安装过程中程序会提醒是否安装jre，jre是运行字节码文件的<strong>运行环境</strong>，jdk是<strong>开发环境</strong>。</p>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230126132016921.png" srcset="/img/loading.gif" lazyload
alt="image-20230126132016921" />
<figcaption aria-hidden="true">image-20230126132016921</figcaption>
</figure>
<p>2.在系统变量里新建两个<strong>系统</strong>变量</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(1)</span><br>JAVA_HOME<br>jkd路径<br><br><span class="hljs-comment">(2)</span> JAVA<span class="hljs-number">5</span>以后可以缺省<br>CLASSPATH<br>.;<span class="hljs-meta">%</span>JAVA_HOME<span class="hljs-meta">%</span>\lib\dt.jar;<span class="hljs-meta">%</span>JAVA_HOME<span class="hljs-meta">%</span>\lib\tools.jar;<br><br></code></pre></td></tr></table></figure>
<p>3.在<strong>系统变量</strong>里的<strong>Path</strong>新建三个<strong>环境</strong>变量</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haml">(1)<br><span class="hljs-tag">%<span class="hljs-selector-tag">JAVA_HOME</span></span>%\bin<br>(2)<br><span class="hljs-tag">%<span class="hljs-selector-tag">JAVA_HOME</span></span>%\jre\bin<br>(3)<br>jdk路径定位到bin<br></code></pre></td></tr></table></figure>
<p>4.在shell里验证环境配置</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">javac -<span class="hljs-built_in">version</span> 编译器<br>java  -<span class="hljs-built_in">version</span> 解释器<br></code></pre></td></tr></table></figure>
<h2 id="第一个java程序">第一个java程序</h2>
<p>java的源代码文件不可以直接执行，需要编译器将其转换为字节码文件（Class），java解释器才可以运行。</p>
<p>在查看里可以设置显示文件后缀名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span>&#123;<br>          <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123;<br>          System.out.println(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>运行时使用解释器运行（无需带后缀）</p>
<p>java HelloWorld</p>
<p>java的字节码文件并不会直接被操作系统所识别，而是运行在java的虚拟机（JVM）上的。虚拟机主要是一个翻译的工作，承担了跨平台的翻译工作。java在不同平台生成的字节码文件是一致的，可以被jre环境识别。</p>
<h2 id="细节">细节</h2>
<p>1.java一个源文件中<strong>只能</strong>有<strong>一个</strong>使用<strong>public
修饰的类</strong>，<strong>其他的类数目不限</strong>，且<strong>每一个类</strong>经过<strong>编译</strong>后都会生成<strong>对应的字节码文件</strong>。</p>
<p>2.源文件中<strong>如果包含public类</strong>，那么文件名<strong>必须</strong>按照<strong>该类名进行命名</strong>。</p>
<p>3.主方法<strong>不一定</strong>非要<strong>定义在public类</strong>中，如定义在其他类中，入口方法就是<strong>非public类的main方法</strong>。</p>
<h2 id="java基础">java基础</h2>
<h3 id="文档注释">文档注释</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> zs</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@version</span> 1.0</span><br><span class="hljs-comment"> */</span>    <br></code></pre></td></tr></table></figure>
<p>使用eclipse生成文档注释时使用project -&gt; Generate -&gt; javadoc</p>
<p>指定编码 -encoding UTF-8 -charset UTF-8</p>
<h3 id="java代码规范">java代码规范</h3>
<ol type="1">
<li>类，方法的注释使用javadoc的方式来写。</li>
<li>shift + Tab 可实现整体代码左移</li>
<li>运算加一个空格</li>
</ol>
<h3 id="java-变量">java 变量</h3>
<p><strong>+运算：</strong></p>
<p>​ 当左右两边为数值时为加法运算；</p>
<p>​ 当左右有一个字符串时则做拼接运算；</p>
<h4 id="数据类型">数据类型</h4>
<p>​ <strong>基本数据类型</strong></p>
<p>​ 1.数值型</p>
<p>​ 整数型：byte1，short2，int4，long8</p>
<p>​ 浮点数：float4，double8</p>
<p>​ 2.字符型：char2 采用unicode作为编码方式</p>
<p>​ 3.布尔型：boolean1：true，false</p>
<p>​ <strong>引用数据类型</strong></p>
<p>​ 类：class</p>
<p>​ 接口：interface</p>
<p>​ 数组：[]</p>
<p><strong>tips：</strong></p>
<p>​ java各整数，浮点数类型的表示范围是固定的，无关于操作系统</p>
<p>​ 定义long末尾加L，定义float末尾加f</p>
<p>​ int型由一个符号位+31个表示位组成</p>
<p>​
float由一个符号位+指数位+尾数位构成，尾数位可能丢失（小数都是近似数）</p>
<p>​
<strong>不要对两个运算过后的小数进行相等判断</strong>，应该以两个数差值的绝对值的范围内进行判断</p>
<p>​ unicode编码所有的语言，ascii编码范围更小一些（128个字符）。</p>
<p>​ boolean不可以为空，不可以初始化为1或0</p>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230212161607125.png" srcset="/img/loading.gif" lazyload
alt="image-20230212161607125" />
<figcaption aria-hidden="true">image-20230212161607125</figcaption>
</figure>
<h4 id="自动转换">自动转换</h4>
<p>混合精度运算时，低精度自动向最高精度转换</p>
<p>byte -&gt; short -&gt;int -&gt;long -&gt;float -&gt;double</p>
<p>char-&gt;int -&gt;long -&gt;float -&gt;double</p>
<p>当加减运算中存在short，byte，char时，会自动转化为int类型</p>
<p>boolean不参加转换 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</p>
<p>char可以在初始化时为整数类型，但不能被初始化为int变量类型，需要强制转换</p>
<p>​ int a = 10;</p>
<p>​ char c = (char)a;</p>
<h4
id="基本数据类型与string类型的相互转换">基本数据类型与String类型的相互转换</h4>
<p>​ 基本数据类型转换为String：s+” “</p>
<p>​ String类型转换为基本数据类型：使用包装类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span> <span class="hljs-variable">aa</span> <span class="hljs-operator">=</span> Byte.parseByte(<span class="hljs-string">&quot;11&quot;</span>);<br><span class="hljs-type">short</span> <span class="hljs-variable">bb</span> <span class="hljs-operator">=</span> Short.parseShort(<span class="hljs-string">&quot;11&quot;</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">dd</span> <span class="hljs-operator">=</span> Integer.parseInt(<span class="hljs-string">&quot;11&quot;</span>);<br><span class="hljs-type">long</span> <span class="hljs-variable">ee</span> <span class="hljs-operator">=</span> Long.parseLong(<span class="hljs-string">&quot;123&quot;</span>);<br><span class="hljs-type">float</span> <span class="hljs-variable">ff</span> <span class="hljs-operator">=</span> Float.parseFloat(<span class="hljs-string">&quot;3.14&quot;</span>);<br><span class="hljs-type">double</span> <span class="hljs-variable">gg</span> <span class="hljs-operator">=</span> Double.parseDouble(<span class="hljs-string">&quot;3.14&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">hh</span> <span class="hljs-operator">=</span> Boolean.parseBoolean(<span class="hljs-string">&quot;true&quot;</span>);<br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;asdasd&quot;</span>.charAt(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure>
<h3 id="java-api">java API</h3>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230212160547954.png" srcset="/img/loading.gif" lazyload
alt="image-20230212160547954" />
<figcaption aria-hidden="true">image-20230212160547954</figcaption>
</figure>
<p>类里还有枚举</p>
<h3 id="java运算符">java运算符</h3>
<p><strong>tips:</strong></p>
<p>​ 取模的运算为 a%b = a-a/b*b</p>
<p>​ ^为<strong>异或</strong>操作，ab不同时为真，否则为假</p>
<p>​ 短路运算（）&amp;（） （）|（）
会在第一个条件为false或true时继续执行后边的条件</p>
<p>​ 复合运算会进行自动类型转换，byte b+=2不报错，byte b；b=b+2
报错，</p>
<p><strong>三目运算符</strong>：</p>
<p>​ （ 【关系运算】 ？【表达式1】：【表达式2】）</p>
<p>​
返回的是一个表达式，要求表达式是可以赋值给接受变量的类型（或者可以自动转换）；</p>
<p>​ &lt;&lt; ，&gt;&gt;移位运算，左移是乘2，右移是除2</p>
<pre><code class="hljs">  \&gt;\&gt;\&gt; 无符号移位运算，例如颜色的+ - 不代表数值类型</code></pre>
<h3 id="java-标识符">java 标识符</h3>
<p>所有的包名全部小写加点</p>
<p>所有的类名首字母大写</p>
<p>所有的方法名首字母小写后边的字母大写</p>
<p>所有常量名全部大写</p>
<h3 id="java-键盘输入">java 键盘输入</h3>
<p>使用scanner类来实现，表示简单的文本扫描器</p>
<p>1.导包 import java.util.Scanner</p>
<p>2.创建实例化对象 Scanner mysc = new Scanner(System.in)</p>
<p>3.接受 String s = mysc.netx();</p>
<h3 id="java进制">java进制</h3>
<p>二进制使用0b或者0B开头</p>
<p>八进制使用0开头</p>
<p>十进制正常</p>
<p>十六进制使用0x或0X表示，且A-F不区分大小写</p>
<p><strong>其他进制到10进制的转换</strong>： <span
class="math display">\[
\sum_{i=low} s_i*(c)^{i-1},c=2,8,16
\]</span> <strong>10进制向其他进制转换</strong>： <span
class="math display">\[
for \ 除以进制c ,记录余数与商
\\直到无法相除时，将余数倒着串起来
\]</span> <strong>2进制向8进制和16进制转换</strong>： <span
class="math display">\[
从低位到高位开始进行划分\\八进制使用3，十六进制时用4，一次划分，并转换为对应进制的数
\]</span> <strong>8进制和16进制向2进制进行转换：</strong> <span
class="math display">\[
从低位到高位开始\\
把每一个低位转成对应的3，或4的二进制数
\]</span></p>
<p>#### 原码，反码，补码</p>
<p>1.二进制的最高位是符号位，0正1负</p>
<p>2.正数的原码，反码，补码都一样</p>
<p>3.负数的反码符号位不变，其他按位取反</p>
<p>4.负数的补码等于它的反码加1，负数的反码等于负数的补码减1</p>
<p>5.0的反码补码都是0</p>
<p>6.java没有无符号数</p>
<p>7.计算机运算时<strong>都是以补码</strong>的方式来运算</p>
<p>8.看计算结果时需要看原码</p>
<p>https://blog.csdn.net/qq_48052049/article/details/125994544</p>
<h3 id="流程控制">流程控制</h3>
<p><strong>switch</strong>细节：</p>
<p>​
表达式的数据类型应和case后的常量保持一致，或者是可以自动转化成相互比较的类型</p>
<p>​ 表达式中的返回值必须是（byte，short，int，char，enum，String)</p>
<p>​ case中的值必须是常量</p>
<p>​ 别忘记default和break</p>
<h3 id="数组">数组</h3>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">//数组的动态初始化 -- 直接创建到内存</span><br><span class="hljs-type">int</span> a[] = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>];<br><br><span class="hljs-comment">// new时才会分配内存 --不直接创建到内存</span><br><span class="hljs-type">int</span> a[];<br>a = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>]<br><span class="hljs-comment">//数组的静态初始化</span><br><span class="hljs-type">int</span> a[] = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br><br><span class="hljs-comment">//-------------------------------------</span><br>java中的数组可以创建为引用类型<br>数组属于引用类型，数组型数据是对象<br><br><span class="hljs-comment">//-------------------------------------</span><br>基本数据类型赋值，如<span class="hljs-type">int</span> a = <span class="hljs-number">1</span>，这个值就是具体的数据（值拷贝，例如再另b=a，修改a的值时b不会受到影响）<br>数组在 默认 情况下是引用传递，赋的值是地址<br><br><span class="hljs-comment">//二维数组第一维中存放的不是具体的值而是地址</span><br></code></pre></td></tr></table></figure>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>java数组常用<br><span class="hljs-regexp">//</span>获取长度<br>n = a.length<br></code></pre></td></tr></table></figure>
<h3 id="类与对象">类与对象</h3>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">类：对现实的抽象<br>对象：类的实例化<br><span class="hljs-section">属性（字段，成员变量，filed【字段】）：还是变量，但是可以由修饰符进行修饰，public，protected，默认，private</span><br><span class="hljs-section">-----------------</span><br>拷贝对象时要拷贝每一个属性<br><br>使用对象.hashCode()来查看地址（实际上是把对象的实际地址转化为了一个整数）<br></code></pre></td></tr></table></figure>
<h3 id="方法">方法</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">同一个类里的方法可以直接调用不需要创建对象<br>方法的返回值可以为任意类型（基本，引用）<br>引用类型传递的是地址，因此可以通过形参影响实参<br></code></pre></td></tr></table></figure>
<h3 id="方法的重载">方法的重载</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">java允许同一个类中存在名称相同的方法，但是要求形参不同。（形参类型，形参个数，形参顺序）<br></code></pre></td></tr></table></figure>
<h3 id="可变参数">可变参数</h3>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">当存在多个方法名称相同，功能相同，单参数个数不同，可可以使用可变参数优化<br>		在定义方法时， <span class="hljs-built_in">int</span>...nums  <br>		将其视为一个数组来访问其中的元素<br></code></pre></td></tr></table></figure>
<h3 id="作用域">作用域</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">局部变量不可以加修饰符<br></code></pre></td></tr></table></figure>
<h3 id="构造器">构造器</h3>
<figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs wren">构造器用来在类创建的时候对成员变量进行初始化<br>构造器由修饰符 类名 形参组成<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>&#123;<br>	int <span class="hljs-variable">age</span>;<br>	<span class="hljs-title class_">String</span> <span class="hljs-variable">name</span>;<br>		<span class="hljs-variable">public</span> <span class="hljs-title function_">student</span>(_<span class="hljs-params">age</span>,_<span class="hljs-params">name</span>)&#123;<br>		<span class="hljs-variable">age</span> <span class="hljs-operator">=</span> <span class="hljs-variable">_age</span>;<br>		<span class="hljs-variable">name</span><span class="hljs-operator">=</span> <span class="hljs-variable">_name</span>;<br>		&#125;<br>&#125;<br>构造器可以看作一种特殊的方法，因此可以通过重载定义多个构造器。<br>一旦显示定义构造器，则默认的构造器会被覆盖掉，除非使用  类名()&#123;&#125;  再次显示定义<br>任何一个构造器都默认带有一个<span class="hljs-variable language_">super</span>()<br></code></pre></td></tr></table></figure>
<h3 id="this关键字">this关键字</h3>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">java虚拟机给每一个对象分配一个<span class="hljs-keyword">this</span>，代表当前对象<br><span class="hljs-number">1.</span><span class="hljs-keyword">this</span>关键字可以用来访问本类的属性，方法，构造器；<br>	<span class="hljs-keyword">this</span>可以用于区分本类的属性以及在同一作用域内的局部变量<br>	<span class="hljs-keyword">this</span>访问成员方法时 <span class="hljs-keyword">this</span>.meth(int <span class="hljs-number">1</span>,int <span class="hljs-number">2.</span>..)<br>	<span class="hljs-keyword">this</span>访问构造器时必须放在第一条语句，且后边的写法只能在构造器中使用，<span class="hljs-keyword">this</span>(parter1,parter2...)<br>	<span class="hljs-keyword">this</span>不能再类定义的外部使用	<br><span class="hljs-number">2.</span><span class="hljs-keyword">this</span>访问本类的属性或者方法不存在时，会寻找父类中可以访问的属性或方法<br></code></pre></td></tr></table></figure>
<h3 id="idea">IDEA</h3>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xl">菜单字体的调整：<span class="hljs-function"><span class="hljs-title">file</span> -&gt;</span><span class="hljs-function"><span class="hljs-title">setting</span> -&gt;</span>Appearence (外观) <br>编辑器字体的调整 :<span class="hljs-function"><span class="hljs-title">file</span> -&gt;</span><span class="hljs-function"><span class="hljs-title">setting</span> -&gt;</span>E<span class="hljs-function"><span class="hljs-title">ditor</span> -&gt;</span>font<br><br>ctrl + D 删除整行<br>alt + / 自动补全<br>ctrl + alt + ⬇ 复制这一行<br><span class="hljs-function"><span class="hljs-title">alt</span> + enter 自动导入（在 setting-&gt;</span><span class="hljs-function"><span class="hljs-title">edito</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">general</span>-&gt;</span>autoimport 中选中）<br>ctrl+alt+L 自动格式化<br>ctrl+shift + F10  运行<br>alt + insert 生成构造器<br>ctrl + H 查看继承关系<br>ctrl + B 定位到相应的方法<br>.var 自动生成变量<br>自定义模板 <span class="hljs-function"><span class="hljs-title">setting</span> -&gt;</span>E<span class="hljs-function"><span class="hljs-title">ditor</span> -&gt;</span>Live Templates<br></code></pre></td></tr></table></figure>
<h3 id="java包">java包</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">包具有三大作用<br>	<span class="hljs-number">1.</span>可以控制访问范围<br>	<span class="hljs-number">2.</span>可以使得区分类名相同的类<br>	<span class="hljs-number">3.</span>便于管理<br>包的本质就是创建不同的文件夹管理不同的类,<span class="hljs-keyword">package</span>需要放在类的最上边，一个类最多只允许有一句<span class="hljs-keyword">package</span><br>包的命名规范<br>	com.公司名.项目名.业务模块名<br>常用的包<br>	java.lang基本包默认引入<br>	java.util 系统提供的工具包<br>	java.net 网络包<br>	java.awt gui界面开发<br>包的引入:<br>	<span class="hljs-keyword">import</span> java.util.Scanner<br>	<span class="hljs-keyword">import</span> java.util.*  导入包下所有的类<br>常用的包:<br>	java.util.Scanner() 键盘输入<br>	java.util.Arrays 数组相关<br><br></code></pre></td></tr></table></figure>
<h3 id="java访问修饰符">java访问修饰符</h3>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">用于控制方法和属性的访问权限（范围）<br><span class="hljs-keyword">public</span> 不同的包 ，同一个包，本类，子类<br><span class="hljs-keyword">protected</span> 同一个包 ，本类，子类<br>默认 同一个包，本类<br>私有 本类<br></code></pre></td></tr></table></figure>
<h3 id="封装">封装</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">封装的实现<br>	1.将属性私有化，使得外部无法直接对属性进行修改<br>	2.提供一个公共的方法实现对属性的赋值（可以在内部加入判断流程）<br>	3.提供一个公共的方法实现对属性的获取<br></code></pre></td></tr></table></figure>
<h3 id="继承">继承</h3>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript">子类可以直接使用父类所有的属性和方法，但私有的属性需要提供一个公开的方法进行访问或修改（封装）<br>初始化子类时，父类的构造器会被调用。<br>创建子类对象时，默认情况总会调用父类的无参构造器，如果父类没有提供午餐构造器，则必须在子类的构造器中用<span class="hljs-variable language_">super</span>区指定使用父类的哪个构造器完成对父类的初始化工作<br>spuer必须在构造器的第一行调用，且只能在构造器中使用，因此<span class="hljs-variable language_">this</span>和spuer在一个构造器中只能二选一执行，即显示调用父类的某个构造器，或显示调用自身类中的某个构造器<br>java所有类都是<span class="hljs-title class_">Object</span>类的子类<br>父类构造器的调用不限于直接父类，将一直向上追溯到<span class="hljs-title class_">Object</span>类，并从上往下执行<br>java是单继承机制，一个子类只能有一个父类<br>访问子类的属性时，从该子类开始，按照继承树从下向上寻找该属性，直到<span class="hljs-built_in">object</span>类截至<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230216183353858.png" srcset="/img/loading.gif" lazyload
alt="image-20230216183353858" />
<figcaption aria-hidden="true">image-20230216183353858</figcaption>
</figure>
<h3 id="super关键字">super关键字</h3>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">super代表父类的引用，用于访问父类的属性，方法，构造器<br>在一个类中，如果<span class="hljs-built_in">cal</span>()方法是可以访问的，使用this<span class="hljs-selector-class">.cal</span>() 和<span class="hljs-built_in">cal</span>()是一样的效果 。当需要访问父类的方法时，使用super访问，如果直接父类没有该方法，则由继承关系自下向上寻找该方法。<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230217125556158.png" srcset="/img/loading.gif" lazyload
alt="image-20230217125556158" />
<figcaption aria-hidden="true">image-20230217125556158</figcaption>
</figure>
<h3 id="方法的重写">方法的重写</h3>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">方法的重写也叫方法的覆盖<br><br>需要满足以下三个条件<br>	<span class="hljs-number">1</span>.子类方法的参数，方法名称和父类方法的参数，方法名称完全一样<br>	<span class="hljs-number">2</span>.子类返回的类型《<span class="hljs-operator">=</span>父类返回类型<br>	<span class="hljs-number">3</span>.子类方法不能缩小父类方法的访问权限<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230217131429896.png" srcset="/img/loading.gif" lazyload
alt="image-20230217131429896" />
<figcaption aria-hidden="true">image-20230217131429896</figcaption>
</figure>
<h3 id="多态">多态</h3>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">方法或属性具有多种形态<br>为了提高代码的复用性<br>方法的重写和方法的重载体现了多态<br>	重载：传入参数的不同，调用了不同的方法<br>	重写：对象的不同，调用了不同的方法<br>	<br>对象的多态<br>	一个对象的编译类型和运行类型可以不一致，例如令一个父类指向一个子类 A <span class="hljs-keyword">a</span> = <span class="hljs-built_in">new</span> B()，即可以定义一个父类对象接受所有子类对象<br>	编译类型看定义时 = 的左边 ，运行类型看 = 的右边<br>	运行类型是可以变化的 如 A <span class="hljs-keyword">a</span> = <span class="hljs-built_in">new</span> B(), <span class="hljs-keyword">a</span> = <span class="hljs-built_in">new</span> C()<br>	编译类型不可以变化<br>多态的向上转型(可以提高代码的复用性，具体来说就是定义方法时定义为父类，传入参数时可以传入子类作为参数)<br>	父类的引用指向了子类的对象<br>	A <span class="hljs-keyword">a</span> = <span class="hljs-built_in">new</span> B() ;   B extends A<br>	编译类型为A，运行类型为 B<br>	可以调用父类所有的成员（访问权限）<br>	不能调用子类中的特有成员（可以调用子类中重写的父类的方法）【因为在编译阶段，编译类型决定了能调用哪些成员，例如 A <span class="hljs-keyword">a</span>的编译类型是A，B的特有成员与方法无法访问】<br><br>多态的向下转型（访问子类的成员方法和属性）<br>	B b = (B) <span class="hljs-keyword">a</span> <br>	只能强转父类的引用，不能强转父类的对象         <span class="hljs-comment">---  向上或向下转型的双方必须存在继承关系</span><br>	要求父类的引用必须指向的是当前目标类型的对象    <span class="hljs-comment">---</span><br>	可以调用子类类型中所有的成员<br></code></pre></td></tr></table></figure>
<h3 id="属性的重写机制">属性的重写机制</h3>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">属性没有重写这个概念，属性的值看编译类型 A <span class="hljs-keyword">a</span> = <span class="hljs-built_in">new</span> B（）;其中A是B的父类<br>	使用<span class="hljs-keyword">a</span>.<span class="hljs-keyword">a</span>访问A与B同名的属性时，不会像方法的重写一样去访问B中的属性，而是去访问了A中的属性<br><br><span class="hljs-keyword">a</span> instanceof b ：判断<span class="hljs-keyword">a</span>对象的运行类型是否为B类型的子类型<br></code></pre></td></tr></table></figure>
<h3 id="java的动态绑定机制">java的动态绑定机制</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">当调用对象的方法的时候，该方法会和该对象的内存地址/运行类型绑定<br>当调用对象的属性时，没有动态绑定机制，哪里声明，哪里使用<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">多态数组<br>    数组定义为父类类型，里边保存的元素为子类类型 <br>    需要访问子类的特有方法时，可以用<span class="hljs-keyword">instanceof</span>判断是哪个子类，并通过向下转型访问<br><span class="hljs-keyword">package</span> com.zs.poly_.Array_;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Test</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Person person[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>[<span class="hljs-number">5</span>];<br>        person[<span class="hljs-number">0</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小明&quot;</span>,<span class="hljs-number">13</span>,<span class="hljs-number">100</span>);<br>        person[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&quot;小张&quot;</span>,<span class="hljs-number">14</span>,<span class="hljs-number">60</span>);<br>        person[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;人&quot;</span>,<span class="hljs-number">13</span>);<br>        person[<span class="hljs-number">3</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;傻老师&quot;</span>,<span class="hljs-number">50</span>,<span class="hljs-number">5</span>);<br>        person[<span class="hljs-number">4</span>] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-string">&quot;特老师&quot;</span>,<span class="hljs-number">47</span>,<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; person.length;i++)&#123;<br>            System.out.println(person[i].say());<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt; person.length;i++)&#123;<br>            <span class="hljs-keyword">if</span>(person[i] <span class="hljs-keyword">instanceof</span> Student)<br>                ((Student)person[i]).Learn();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(person[i] <span class="hljs-keyword">instanceof</span> Teacher)<br>                ((Teacher)person[i]).Teach();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(person[i] <span class="hljs-keyword">instanceof</span> Person)<br>                System.out.println(person[i].say());<br>            <span class="hljs-keyword">else</span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;Wrong&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>### java多态参数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jade">//形参为父类类型，实参为父类的子类，好处就是可以通过重写父类的方法，来提高代码可用性<br>package com.zs.poly_.Partmes;<br><br>public class Test &#123;<br>    public double showEmpannal(Employee employee)&#123;<br>       return employee.GetAnnual();<br>    &#125;<br>    public void testWork(Employee employee)&#123;<br>        if(employee instanceof Nomral)<br>            ((Nomral)employee).work();<br>        else<br>            System.out.println(&quot;你不是打工人&quot;);<br>    &#125;<br>    public static void main(String[] args) &#123;<br>        Manner manner = new Manner(&quot;经理&quot;,99,100);<br>        Nomral nomral = new Nomral(&quot;张三&quot;,100);<br>        Test test = new Test();<br>        System.out.println(&quot;经理的工资是:&quot;+test.showEmpannal(manner));<br>        System.out.println(&quot;打工人的工资是&quot;+test.showEmpannal(nomral));<br>        test.testWork(manner);<br>        test.testWork(nomral);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="object类">object类</h3>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">equals</span><span class="hljs-params">()</span></span><br><br>== 和 equals<br>	== 既可以判断基本类型，也可以判断引用类型<br>		判断基本类型时，判断的是指向的值是否相等<br>		判断引用类型时，判断的是指向的地址是否相等<br>	equals是object类的方法，只能判断引用类型，equals默认判断引用类型是否相同<br>		<br><span class="hljs-function"><span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br>	<span class="hljs-number">1</span>. 提高具有哈希结构容器的效率<br>	<span class="hljs-number">2</span>. 两个引用，如果指向同一个对象，则哈希值肯定是一样的<br>	<span class="hljs-number">3</span>. 两个引用，如果指向不同的对象，哈希值可能不一样（碰撞）<br>	<span class="hljs-number">4</span>. 哈希值通过地址得到，不能完全将哈希值等价于地址【把地址映射为整数】<br>	<br><span class="hljs-function"><span class="hljs-title">toString</span><span class="hljs-params">()</span></span><br>	返回对象的全类名+@+哈希值的<span class="hljs-number">16</span>进制<br>	当直接输出一个对象时，toString会被默认调用<br>	<br><span class="hljs-function"><span class="hljs-title">finalize</span><span class="hljs-params">()</span></span><br>	当对象被回收时，系统自动调用该对象的finalize方法<br>	当某个对象没有任何引用时，jvm就会认为这个对象是一个垃圾，就会使用垃圾回收机制来销毁对象，在销毁对象前，会先调用finalize方法<br>	可以通过System.gc（）主动出发垃圾回收机制，但不一定会直接回收<br></code></pre></td></tr></table></figure>
<h3 id="断点调试">断点调试</h3>
<figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xl">F7 跳入方法内 S<span class="hljs-function"><span class="hljs-title">etting</span> -&gt;</span>B<span class="hljs-function"><span class="hljs-title">uild</span>,Execution,Deployment -&gt;</span>D<span class="hljs-function"><span class="hljs-title">ebugger</span> -&gt;</span>Stepping,取消勾选java,javax<br>F8 逐行执行<br>F9 执行到下一个断点<br>shitf + F8 跳出方法<br>调试时按运行类型来定位<br>断点支持动态的下断点<br></code></pre></td></tr></table></figure>
<h3 id="类变量静态变量">类变量（静态变量）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">使用<span class="hljs-keyword">static</span>来修饰，在类中定义<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> age;<br>&#125;<br>可以使用实例化的对象来访问<br><span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>();<br>a.age<br>可以使用对象名来访问<br>A.age<br>所有通过A实例化的对象，其类变量共享一块存储空间，jkd7以前时，静态变量放在方法区中的静态域中，以后的版本静态变量存放在堆中【每个类对应一个class实例，在class实例的尾部，class实例在堆中】<br><br>类变量在类加载的时候就生成了，因此可以不需要实例化任何对象就可以访问<br><br>类变量同样受访问修饰符的约束<br><br>类变量以外的变量成为实例变量，普通变量，非静态变量<br><br>类变量生命周期随着类加载开始，随着类消亡而销毁<br><br></code></pre></td></tr></table></figure>
<h3 id="类方法静态方法">类方法（静态方法）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">使用<span class="hljs-keyword">static</span>来修饰，在类中定义<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span>&#123;<br>&#125;;<br>&#125;<br>同样支持使用类名来直接访问<br>    <br>一些通用的方法比较适合设计成静态方法，比如计算任务，打印数组等，当希望不需要实例化类就可以调用方法时就可以创建类方法<br>    <br>类方法没有<span class="hljs-built_in">this</span>属性，<span class="hljs-built_in">super</span>属性<br>    <br>静态方法不能访问非静态方法，不能直接在方法体内访问非静态变量<span class="hljs-comment">//，但形参可以传入非静态成员或是类</span><br></code></pre></td></tr></table></figure>
<h3 id="main方法">Main方法</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">main</span>方法是java虚拟机在调用<br><br>public保证了虚拟机可以调用<span class="hljs-selector-tag">main</span>方法<br><br>static保证了不需要创建对象就可使用<span class="hljs-selector-tag">main</span>方法<br><br>args以字符串数组的形式，传入形参。在执行时传入<br><br>在<span class="hljs-selector-tag">main</span>方法中可以访问该类中的所有静态方法和静态属性<br><br>IDEA中，选择运行小绿按钮的下拉，选择Edit configurations，可以进行动态传参到<span class="hljs-selector-tag">main</span>方法<br></code></pre></td></tr></table></figure>
<h3 id="代码块">代码块</h3>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">【修饰符】&#123;<br><br>&#125;；<br>只能使用<span class="hljs-keyword">static</span>修饰<br>又称为初始化块，没有方法名，没有返回，没有参数，只有方法体，而且不用通过对象或者类显示调用，在加载类时 或 创建对象时隐式调用<br><br>可以对构造器做补充，例如多个构造器有重复的语句<br><br>代码块的调用优先于构造器<br><br>使用<span class="hljs-keyword">static</span>修饰的代码块随着类的加载而执行，而且只会执行一次，普通代码块每创建一个对象就会被隐式调用而执行<br>类什么时候会被加载<br>	<span class="hljs-number">1.</span>创建对象实例时<br>	<span class="hljs-number">2.</span>创建子类对象实例时，父类也会被加载<br>	<span class="hljs-number">3.</span>使用类的静态成员时<br>	<br>使用类的静态成员时，普通代码块不会执行，因为静态代码块只会在加载类时执行一次。<br><br>创建一个对象时，静态代码块和静态属性的初始化优先级一样，有多个静态代码块和多个静态属性初始化时，按照定义顺序执行。<br>			紧接着在调用普通代码块和普通属性的初始化，有多个时同样按照定义顺序执行<br><br>构造器中有两个隐藏的代码，<span class="hljs-keyword">super</span>（）以及普通代码块<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230220111724731.png" srcset="/img/loading.gif" lazyload
alt="image-20230220111724731" />
<figcaption aria-hidden="true">image-20230220111724731</figcaption>
</figure>
<h3 id="单例设计模式">单例设计模式</h3>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs gradle">静态方法和属性的经典使用<br>在大量实践中总结和理论化之后优选的代码结构，编程风格，解决问题的思考模式(java中一共有<span class="hljs-number">23</span>种)<br>	采取一定的方法，使得某个类只能存在一个对象实例，且只提供一个取得对象实例的方法（对于重资源的类，我们也许只需要一个就够了）<br>	<br>饿汉式:用不用都创建<br>	首先私有化构造器，<br>	在类内私有化实例对象<br>	提供一个静态的公开的方法暴露出来<br>懒汉式：不用不创建<br>	首先私有化构造器，<br>	在类内私有化实例对象<br>	提供一个静态的公开的方法暴露出来<br>饿汉式不存在线程安全问题，但存在资源浪费问题<br>懒汉式节省资源，但可能存在线程安全问题<br>java.lang.<span class="hljs-keyword">Runtime</span>是经典的单例模式<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230220124039292.png" srcset="/img/loading.gif" lazyload
alt="image-20230220124039292" />
<figcaption aria-hidden="true">image-20230220124039292</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230220124319432.png" srcset="/img/loading.gif" lazyload
alt="image-20230220124319432" />
<figcaption aria-hidden="true">image-20230220124319432</figcaption>
</figure>
<h3 id="final">final</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs fin">final class A&#123;&#125;<br>使得A无法被继承<br><br>final public void()&#123;&#125;<br>使得父类的某个方法无法被重写<br><br>public final int a = 0.001<br>使得类中的某个属性无法被修改<br><br>final double = 1.0<br>用于修饰局部变量，使得其无法被修改 <br><br>final修饰的属性一般叫常量，用XX_XX_XX<br><br>final修饰的变量必须被初始化（直接初始化，在构造器中，在代码块中）<br><br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230220142913319.png" srcset="/img/loading.gif" lazyload
alt="image-20230220142913319" />
<figcaption aria-hidden="true">image-20230220142913319</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230220143215912.png" srcset="/img/loading.gif" lazyload
alt="image-20230220143215912" />
<figcaption aria-hidden="true">image-20230220143215912</figcaption>
</figure>
<h3 id="抽象类">抽象类</h3>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">当父类中的某些方法不知道怎么实现，或者没必要实现时，将该方法声明为抽象方法，将上边的类声明为抽象类。方法的实现通常由子类通过继承来实现。<br><br>抽象类更多的作用是在于设计，在设计者设计好后，由子类来设计实现<br><br>抽象类不能被实例化<br><br>抽象类可以没有抽象方法，还可以有实现的方法<br><br><span class="hljs-keyword">abstract</span>只能修饰类或者方法<br><br>抽象类可以有任意成员，本质还是一个类<br><br>如果一个类继承了抽象类，则它必须实现抽象类所有的抽象方法，除非它自己也声明为抽象类。<br><br>抽象类不能使用<span class="hljs-keyword">private</span>，<span class="hljs-keyword">final</span>，<span class="hljs-keyword">static</span>来修饰方法，因为这三个关键字都会使得方法无法被重写<br></code></pre></td></tr></table></figure>
<h3 id="模板设计模式">模板设计模式</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">将多个类中共有的东西抽象出来，可以实现的部分直接实现，无法实现的部分使用抽象方法来实现。<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230220154045460.png" srcset="/img/loading.gif" lazyload
alt="image-20230220154045460" />
<figcaption aria-hidden="true">image-20230220154045460</figcaption>
</figure>
<h3 id="接口">接口</h3>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">定义接口<br>接口中的方法体都是抽象方法且不需要<span class="hljs-keyword">abstract</span>来修饰<br>定义接口的实现类<br>定义使用接口的类将接口作为形参<br>可以通过形参直接访问实现类的方法<br>接口不能被实例化<br>接口的所有方法都是<span class="hljs-keyword">public</span>方法，且默认都有<span class="hljs-keyword">abstract</span>来修饰<br>一个类实现接口，接口的所有方法都需要被实现<br>抽象类实现接口时可以不实现接口的抽象方法<br>一个类同时可以实现多个接口<br>接口中的属性只能是<span class="hljs-keyword">final</span>的，且前边默认由<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> 来修饰<br>接口中属性的访问使用 接口名.属性名来访问，或者是实现类.属性名 ，或者是实现类对象.属性名来访问<br>一个接口不能继承其他的类，但是可以继承多个别的接口<br>接口的修饰符只能是<span class="hljs-keyword">public</span><br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230220162739078.png" srcset="/img/loading.gif" lazyload
alt="image-20230220162739078" />
<figcaption aria-hidden="true">image-20230220162739078</figcaption>
</figure>
<h3 id="接口vs继承类">接口VS继承类</h3>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">接口是对<span class="hljs-keyword">java单继承的一种补充（同时使用extedns和implement）</span><br><span class="hljs-keyword"></span>接口实现了代码的解耦<br></code></pre></td></tr></table></figure>
<h3 id="接口的多态">接口的多态</h3>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">多态参数的体现，将接口变量作为形参，则该方法可以接受任意实现了该接口的类的对象。接口不能被实例化，但接口变量可以指向任意实现类的实例化对象。<br><br>接口也可以创建动态数组，内部可以存放不同的实现类<br><br>接口的多态传递现象，当某个实现类的接口<span class="hljs-selector-tag">B</span>继承了另一个接口<span class="hljs-selector-tag">A</span>时，则该实现类也实现了接口<span class="hljs-selector-tag">A</span><br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230220170459381.png" srcset="/img/loading.gif" lazyload
alt="image-20230220170459381" />
<figcaption aria-hidden="true">image-20230220170459381</figcaption>
</figure>
<h3 id="内部类">内部类</h3>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">在类里再次定义一个类<br><br>内部类构成类的第五大成员，属性，方法，构造器，代码块，<br><br>内部类最大的特点是可以直接访问私有属性，并且可以体现类与类之间的包含关系 <br><br>局部内部类：<br>	通常定义在外部类的方法中<br>	可以直接访问外部类的其他所有成员，包括私有的属性<br>	不能添加访问修饰符，但可以使用final修饰<br>	作用域仅仅在方法体内或者代码块中，就相当于一个局部变量<br>	访问局部内部类的方法为在 外部类 的 方法内 实例化一个 局部内部类 的 对象 ，然后在该方法内调用局部内部类的方法<br>	外部其他类不能访问内部类，因为内部类就相当于一个局部变量<br>	如果内部类的成员和外部类的成员重名时，遵守就近原则，需要在内部类访问外部类的崇明成员时，使用外部类名.this.成员名，外部类名.this本质就是外部类的对象，如 A a = <span class="hljs-built_in">new</span> A（）,A.this.x 就是 a.x<br>	<br>匿名内部类:<br>	通常定义在外部类的方法中<br>	本质还是类<br>	不需要定义名字（外部类+<span class="hljs-meta">$1</span>）<br>	同时还是一个对象<br>	存在的意义是，对于某些接口或者类，只需要用一次后边不再使用，额外定义一个类给开发添加了不必要的麻烦，因此使用匿名内部类简化了开发<br>	//基于接口的 底层自动生成了一个接口的实现类，类的名称为外部类+<span class="hljs-meta">$1</span>，运行类型为匿名内部类<br>	IA tiger = <span class="hljs-built_in">new</span> IA()&#123;<br>	@override<br>	<span class="hljs-built_in">public</span> <span class="hljs-type">void</span> cry()&#123;<br>	<span class="hljs-keyword">system</span>.<span class="hljs-keyword">out</span>.println(&quot;asdasd&quot;);<br>	&#125;<br>	&#125;<br>	在外部类使用tiger.cry()就可以直接访问而不需要实例化对象<br>	//基于类的 底层自动生成了一个外部类的继承类，类的名称为外部类+<span class="hljs-meta">$2</span>，运行类型为匿名内部类，IA还可以为抽象类<br>	IA tiger = <span class="hljs-built_in">new</span> IA()&#123;<br>	@override<br>	<span class="hljs-built_in">public</span> <span class="hljs-type">void</span> cry()&#123;<br>	<span class="hljs-keyword">system</span>.<span class="hljs-keyword">out</span>.println(&quot;asdasd&quot;);<br>	&#125;<br>	&#125;<br>	<br>	调用匿名内部类有两种方法，可以通过指向匿名内部类的引用访问（对象），也可以在创建时直接访问<br>	<br>	匿名内部类最常用的场景就是作为实参传递到方法中<br><br>成员内部类:<br>	通常直接定义在类中，而不是类中的方法<br>	作用域只在外部类体内，因此访问时需要在外部类创建并访问<br>	可以直接访问外部类的属性和方法（私有也可以）<br>	外部类也可以直接访问内部类的属性和方法（私有也可以）<br>	外部其他类可以访问和使用成员内部类 <br>			（<span class="hljs-number">1</span>）<span class="hljs-keyword">Outer</span> <span class="hljs-keyword">outer</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>() ; <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-keyword">outer</span>.<span class="hljs-built_in">new</span> <span class="hljs-keyword">Inner</span>();<br>			（<span class="hljs-number">2</span>）<span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> inner2 = <span class="hljs-keyword">outer</span>.getInner(); //在外部类定义一个返回内部类的方法<br>	如果外部类和内部类的成员重名，则在内部类或外部类访问该重名成员时遵守就近原则，需要在内部类访问外部类成员时使用this<br>静态内部类:<br>	通常直接定义在类中，而不是类中的方法<br>	使用static修饰<br>	可以使用访问修饰符来控制访问权限<br>	作用域为整个类体<br>	可以访问外部类所有静态成员<br>	外部类访问静态内部类时，先创建静态内部类的对象，再访问<br>	外部其他类访问内部类时，先创建 <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span> <span class="hljs-keyword">inner</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Outer</span>.<span class="hljs-keyword">Inner</span>()；可以直接创建 【满足访问权限】，或是写一个返回对象的方法【可以声明为静态】<br>	如果外部类和静态内部类成员重名时，遵守就近原则，需要访问范围之外的重名成员时，使用类名.x来访问<br>成员内部类和静态内部类本质还是一个成员<br></code></pre></td></tr></table></figure>
<h3 id="枚举类">枚举类</h3>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">当对象为有限个对象属性的组合时，可以定义枚举类<br>枚举类实际上对类的对象数量做了限制<br>自定义方法：<span class="hljs-number">1</span>.私有化构造器<span class="hljs-number">2</span>.设置getter方法<span class="hljs-number">3</span>.在类内实例化固定对象，使用final和static来优化<span class="hljs-number">4</span>.在类外通过类名.对象名.x来访问属性或者方法<br>使用关键字：enum替代class<br>	使用细节:使用 类名(” “，” “)来实例化对象,并且只能放在第一行。<br>			有多个对象时，使用逗号进行分隔。<br>	enum类继承了java<span class="hljs-selector-class">.lang</span>.Enum类，且被final所修饰,使用enum创建的枚举类不可以继承其他任何类，但是可以实现接口<br>枚举类常用的方法:<br>	<span class="hljs-selector-class">.name</span>() 返回创建枚举对象时定义的对象名（Enunm重写了tosTring方法）<br>	<span class="hljs-selector-class">.ordinal</span>() 返回创建枚举对象时的次序<br>	<span class="hljs-selector-class">.values</span>() 返回一个包含所有枚举对象的数组<br>	<span class="hljs-selector-class">.valuesOf</span>(<span class="hljs-string">&quot; &quot;</span>) 根据给定的字符串去匹配枚举对象，找不到就报错<br>	<span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.compareTo</span>(enum b) 返回<span class="hljs-selector-tag">a</span>.ordianl（）-<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.ordianl</span>()<br>枚举可以和switch一起使用<span class="hljs-built_in">switch</span>(枚举对象)<br></code></pre></td></tr></table></figure>
<h3 id="注解">注解</h3>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230222143027226.png" srcset="/img/loading.gif" lazyload
alt="image-20230222143027226" />
<figcaption aria-hidden="true">image-20230222143027226</figcaption>
</figure>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Override</span> 的意义在于语法检查，如果方法没有重写却加了注解，则会报错 <span class="hljs-variable">@interface</span>是注解类不是接口 jdk1.<span class="hljs-number">5</span>之后加入 只能修饰方法 <span class="hljs-variable">@Target</span>是修饰注解的注解，称为元注解<br><br><span class="hljs-variable">@Deprecated</span> 代表过时的，用来修饰类，方法，字段，包 还可以用但不推荐使用<br><br><span class="hljs-variable">@SuppressWarnings</span> 抑制警告,作用范围与该注解位于的位置有关，一般放在类上<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230222144937786.png" srcset="/img/loading.gif" lazyload
alt="image-20230222144937786" />
<figcaption aria-hidden="true">image-20230222144937786</figcaption>
</figure>
<p><img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230222145021606.png" srcset="/img/loading.gif" lazyload /></p>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230222145049673.png" srcset="/img/loading.gif" lazyload
alt="image-20230222145049673" />
<figcaption aria-hidden="true">image-20230222145049673</figcaption>
</figure>
<h3 id="异常">异常</h3>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs php">在可能的地方做异常处理，保持程序的健壮性<br><span class="hljs-keyword">try</span>&#123;&#125; <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> e)&#123;&#125;<br>java的异常分为:<br>	<span class="hljs-built_in">Error</span>(错误) JVM内部错误，资源耗尽，栈溢出，OOM内存耗尽<br>	以及<span class="hljs-built_in">Exception</span>(异常),访问空指针，读取不存在的文件，网络连接中断<br>		<span class="hljs-built_in">Exception</span>又分为运行时异常以及编译时异常<br>		<br>运行时异常可以不做处理（编译器检查不出来），编译时异常是编译器要求必须处置的异常<br><br>常见的运行时异常:<br>	NullpointerException 对一个指向空对象的引用进行操作<br>	ArithmeticException 数学算数异常<br>	ArrayIndexOutofBoundsException 数组越界异常<br>	ClassCastException 转型异常<br>	NumberFormalException 数字转换异常<br>常见的编译异常<br>	SQLExceptioon 操作数据库时可能发生异常<br>	IOException 操作文件时可能发生异常<br>	FileNotFoundException 操作一个不存在的文件发生异常<br>	ClassNotFoundException 加载类，但该类不存在时发生异常<br>	EOFexception 操作文件，到文件末尾发生异常<br>	IllegalArguementException 参数异常<br>	<br>异常处理机制有两种：<br>	一种是使用<span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span>来处理，捕获异常后自行处理，<span class="hljs-keyword">finally</span>无论有没有捕获到异常都会执行，通常用来进行资源的释放。<br>	一种是使用throws来处理，将异常抛出到上一个方法中，上一个方法可以选择继续抛出或者使用<span class="hljs-keyword">try</span>-cath-<span class="hljs-keyword">finally</span>来处理。顶端为JVM机，JVM机会抛出异常并中止运行。<br>	两种方案只能二选一，默认为throws 即throws <span class="hljs-built_in">Exception</span><br><br><span class="hljs-keyword">try</span>-<span class="hljs-keyword">catch</span>-<span class="hljs-keyword">finally</span> 可以进行多重匹配，每次只有一个异常会被捕获，父类<span class="hljs-built_in">Exception</span>必须在最后被捕获<br><span class="hljs-keyword">try</span>-<span class="hljs-keyword">finally</span>用法，执行完<span class="hljs-keyword">finally</span>直接中断程序<br><span class="hljs-keyword">throw</span>后边可以是异常列表，也可以抛出方法中产生异常类型的父亲<br>在进行方法的重写时，子类抛出的异常需要与父类异常类型一致或者是父类的异常的子类<br><br>自定义异常：<br>	<span class="hljs-number">1</span>.编写一个类继承异常类，创建构造器<br>	<span class="hljs-number">2</span>.在方法中使用<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> 类名(<span class="hljs-string">&quot;&quot;</span>)<br>    <span class="hljs-number">3</span>.一般是继承运行类异常，可以使用默认处理机制，如果是编译异常则还需要在调用方法抛出异常或者<span class="hljs-keyword">try</span>手动处理<br>    <span class="hljs-number">4</span>.<span class="hljs-keyword">throw</span>定义在方法体中，用于抛出一个异常对象 thow <span class="hljs-keyword">new</span> <span class="hljs-built_in">Exception</span>,throws定义在方法后，用于指定抛出的异常类<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223143226189.png" srcset="/img/loading.gif" lazyload
alt="image-20230223143226189" />
<figcaption aria-hidden="true">image-20230223143226189</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230222191453174.png" srcset="/img/loading.gif" lazyload
alt="image-20230222191453174" />
<figcaption aria-hidden="true">image-20230222191453174</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223143354747.png" srcset="/img/loading.gif" lazyload
alt="image-20230223143354747" />
<figcaption aria-hidden="true">image-20230223143354747</figcaption>
</figure>
<h3 id="包装类">包装类</h3>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Wrapper</span> 包装类<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223152530454.png" srcset="/img/loading.gif" lazyload
alt="image-20230223152530454" />
<figcaption aria-hidden="true">image-20230223152530454</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223152845558.png" srcset="/img/loading.gif" lazyload
alt="image-20230223152845558" />
<figcaption aria-hidden="true">image-20230223152845558</figcaption>
</figure>
<figure>
<img
src="C:\Users\zs\AppData\Roaming\Typora\typora-user-images\image-20230223152938396.png" srcset="/img/loading.gif" lazyload
alt="image-20230223152938396" />
<figcaption aria-hidden="true">image-20230223152938396</figcaption>
</figure>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">包装类就是对基本数据类型的一种扩展<br>jdk5前为手动装箱（基本类型-&gt;包装类型）和拆箱(包装类型-&gt;基本数据类型)<br>自动装箱底层调用的是valueOf方法<br><span class="hljs-comment">//手动装箱</span><br><span class="hljs-built_in">int</span> n1 = <span class="hljs-number">100</span>;<br>Integer integer = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Integer(<span class="hljs-params">n1</span>)</span><br>Integer integer1 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">n1</span>)</span><br><span class="hljs-comment">//手动拆箱</span><br><span class="hljs-built_in">int</span> i = integer.<span class="hljs-built_in">int</span><span class="hljs-constructor">Value(<span class="hljs-params">n1</span>)</span>;<br><br>自动装/拆箱<br><span class="hljs-built_in">int</span> n2 = <span class="hljs-number">100</span>;<br>Integer integer2 = n2; <span class="hljs-comment">//底层仍然是手动装</span><br><span class="hljs-built_in">int</span> n3 = integer2； <span class="hljs-comment">//底层仍然是手动拆箱</span><br><br>包装类型和String类型的相互转换<br>    Integer i = <span class="hljs-number">100</span>;<br>    <span class="hljs-number">1.</span>String str1 = i+ <span class="hljs-string">&quot;&quot;</span> （i没有变化）<br><br>    <span class="hljs-number">2.</span>String str2 = i.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span><br><br>    <span class="hljs-number">3.</span>String str3 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span>value<span class="hljs-constructor">Of(<span class="hljs-params">i</span>)</span><br>    <br>    <span class="hljs-number">1.</span>. Integer i2 = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Integer</span>.</span></span>parse<span class="hljs-constructor">Int(<span class="hljs-params">str3</span>)</span><br>    <br>    <span class="hljs-number">2.</span>. Integer i3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Integer(<span class="hljs-params">str3</span>)</span><br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223154321023.png" srcset="/img/loading.gif" lazyload
alt="image-20230223154321023" />
<figcaption aria-hidden="true">image-20230223154321023</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223155649766.png" srcset="/img/loading.gif" lazyload
alt="image-20230223155649766" />
<figcaption aria-hidden="true">image-20230223155649766</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223160332559.png" srcset="/img/loading.gif" lazyload
alt="image-20230223160332559" />
<figcaption aria-hidden="true">image-20230223160332559</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223160812868.png" srcset="/img/loading.gif" lazyload
alt="image-20230223160812868" />
<figcaption aria-hidden="true">image-20230223160812868</figcaption>
</figure>
<h3 id="string类">String类</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-type">String</span>类<br>    字符使用unicode字符编码，一个字符占两个字节（不区分英汉）<br>    Serializable 串行化：可以在网络传输<br>    Comparable:对象可以相互比较<br>    Charsequence:字符串序列<br>    使用<span class="hljs-keyword">final</span>修饰不能被继承<br>    保存时还是保存到<span class="hljs-type">char</span>数组 pravie <span class="hljs-keyword">final</span> <span class="hljs-type">char</span> value[] ,地址不可修改，里边的值可以修改（专有方法）<br>    <span class="hljs-type">String</span>有很多构造器<br><span class="hljs-type">String</span>两种创建方式的区别：<br>	<span class="hljs-type">String</span> s1 = <span class="hljs-string">&quot;asdasd&quot;</span>；<br>	查看常量池是否有<span class="hljs-string">&quot;asdasd&quot;</span>,没有的话在常量池创建常量，直接将地址引用返回到栈中<br>	<span class="hljs-type">String</span> s2 = new <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;asdasd&quot;</span>)<br>	在堆中创建空间，维护一个指向value的常量池属性，如果有<span class="hljs-string">&quot;asdasd&quot;</span>，则其value指向常量池中常量的地址，如果没有的话则创建常量并将地址返回给value，随后在堆中创建一个指向value的引用。所以对于相同的字符串常量，两个引用指向的地址是不同的<br>	<br><span class="hljs-type">String</span>的方法：<br>	equals比较的是字符串的值是否一一对应<br>	intern（）最终会返回的是常量池的地址<br>	<br><span class="hljs-type">String</span> 的特性：<br>	<span class="hljs-type">String</span>是一个<span class="hljs-keyword">final</span>类，其存放字符串的属性也是<span class="hljs-keyword">final</span>属性，因此字符串不可修改<br>        <span class="hljs-type">String</span> s = new <span class="hljs-title function_ invoke__">String</span>(<span class="hljs-string">&quot;asd&quot;</span>)<br>        s = <span class="hljs-string">&quot;bcx&quot;</span><br>        <span class="hljs-comment">//创建了两个对象</span><br>        <br>        <span class="hljs-type">String</span> s = “hello<span class="hljs-string">&quot;+”abc “ </span><br><span class="hljs-string">        //编译器会优化，等于String s = ”helloabc&quot;</span> 创建了一个对象<br>        <br>        <br>        <span class="hljs-type">String</span> a = <span class="hljs-string">&quot;hello&quot;</span><br>        <span class="hljs-type">String</span> b = <span class="hljs-string">&quot;abc&quot;</span><br>        <span class="hljs-type">String</span> c = a+b<br>        创建了三个对象，首先 a指向常量池，b指向常量池。<br>        其次调用StringBuilder 创建一个对象，并调用两次append方法将a与b拼接到一起存放在常量池中<br>        最后调用StringBuilder的toString方法返回给c的引用<br>        <br>        <span class="hljs-comment">//两个String常量相加看池，两个String变量相加看堆</span><br>        <br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223165055065.png" srcset="/img/loading.gif" lazyload
alt="image-20230223165055065" />
<figcaption aria-hidden="true">image-20230223165055065</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223170719129.png" srcset="/img/loading.gif" lazyload
alt="image-20230223170719129" />
<figcaption aria-hidden="true">image-20230223170719129</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230223171626073.png" srcset="/img/loading.gif" lazyload
alt="image-20230223171626073" />
<figcaption aria-hidden="true">image-20230223171626073</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230224145059366.png" srcset="/img/loading.gif" lazyload
alt="image-20230224145059366" />
<figcaption aria-hidden="true">image-20230224145059366</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230224150623253.png" srcset="/img/loading.gif" lazyload
alt="image-20230224150623253" />
<figcaption aria-hidden="true">image-20230224150623253</figcaption>
</figure>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs awk">String 常用方法<br>String是保存字符串常量的，每次更新都需要重新开辟空间，效率低<br>因此提供了StringBuilder和StringBuffer来增强String的功能<br><br>用这些方法看下是返回的新对象还是直接进行了修改<br><span class="hljs-regexp">//</span>equalsIgnoreCase()忽略大小写<br><span class="hljs-regexp">//i</span>ndexof(<span class="hljs-string">&quot;s&quot;</span>)查找该字符串s（字符也可以）在字符串对象中第一次出现的索引<br><span class="hljs-regexp">//</span>lastindexof(<span class="hljs-string">&#x27;a&#x27;</span>)查找该字符在字符串对象中最后一次出现的索引<br><span class="hljs-regexp">//</span>substring截取指定范围的子串  (n)从索引n后截取所有内容  （l，r）截取l到r-<span class="hljs-number">1</span>的内容<br><span class="hljs-regexp">//</span>toUpperCase 把字符串全部换为大写<br><span class="hljs-regexp">//</span>toLowerCase 把字符串全部换为大写<br><span class="hljs-regexp">//</span>s.concat(<span class="hljs-string">&quot;&quot;</span>).concat(<span class="hljs-string">&quot;&quot;</span>).concat(<span class="hljs-string">&quot;拼接&quot;</span>)<br><span class="hljs-regexp">//</span>s.replace(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>)把s中所有的a全部换为b<br><span class="hljs-regexp">//</span>String s[] = S.split(<span class="hljs-string">&quot;,&quot;</span>) 以逗号为间隔进行分割 注意特殊字符的转义字符<br><span class="hljs-regexp">//</span>s.toCharArray()转化为字符数组<br><span class="hljs-regexp">//</span>s1.compareTo(s2) 如果s1和s2完全相同，则返回零，如果一个长一个短，返回s1-s2的长  如果长度相同，则返回第一个不同的字符之间的ascii的差值<br><span class="hljs-regexp">//</span>String.formal() 格式化输出 String formatStr = <span class="hljs-string">&quot;%d %s %.2f %c&quot;</span>;String info = String.format(formalStr,age,name,money,sex) !!!<span class="hljs-string">&quot;参数是个String 对象，”asdasd“也是String对象！ &quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="stringbuffer-类">StringBuffer 类</h3>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs dart">StringBUffer 是对<span class="hljs-built_in">String</span>常量无法进行修改所存在的一个类<br>是一个容器，长度可变，可以对字符串内容进行增删<br>被<span class="hljs-keyword">final</span>修饰，不可被继承<br>存放字符串的变量定义在抽象父类中的valu数组中，没有被<span class="hljs-keyword">final</span>修饰所以可以修改，具体的位置在堆中存放<br>实现了序列化接口以及charSequence接口<br><span class="hljs-built_in">StringBuffer</span>增加或删除时不用每次都更换对象（地址，创建新的对象）<br><br><span class="hljs-built_in">StringBuffer</span>构造器:<br>	无参构造器：vlue[]数组被初始化为<span class="hljs-number">16</span>个长度<br>	<span class="hljs-built_in">StringBuffer</span>（<span class="hljs-built_in">int</span> a）:指定缓存区大小<br>	<span class="hljs-built_in">StringBuffer</span>(<span class="hljs-built_in">String</span> s)：长度为s的长度再加<span class="hljs-number">16</span><br><br><span class="hljs-built_in">StringBuffer</span>和<span class="hljs-built_in">String</span>的相互转换<br>	<span class="hljs-built_in">StringBuffer</span>通过<span class="hljs-keyword">new</span>来将<span class="hljs-built_in">String</span>转化为<span class="hljs-built_in">StringBuffer</span>对象<br>    <br>    <span class="hljs-built_in">StringBuffer</span>通过toString或者是将<span class="hljs-built_in">StringBuffer</span>传入<span class="hljs-built_in">String</span>的构造器中来转化为<span class="hljs-built_in">String</span>对象<br>    <br><span class="hljs-built_in">StringBuffer</span>的常见方法	<br><span class="hljs-comment">//s.append( * ) 可以是字符，字符串，数字，boolean等各种东西 </span><br><span class="hljs-comment">//s.delete(  [a,b) ):删除字符串，前闭后开</span><br><span class="hljs-comment">//s.replace( [a,b)  )：替换，前闭后开</span><br><span class="hljs-comment">//s.indexOf( ” “ ) ：定位第一次出现的位置</span><br><span class="hljs-comment">//s.insert(a,&quot; &quot;):在索引为n的位置插入</span><br><br><br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230226160417550.png" srcset="/img/loading.gif" lazyload
alt="image-20230226160417550" />
<figcaption aria-hidden="true">image-20230226160417550</figcaption>
</figure>
<h3 id="stringbuilder类">StringBuilder类</h3>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">不是线程安全的，用于字符缓冲区被单个线程使用的，如果可以建议优先使用这个类<br>与buffer的继承关系相同<br>也是<span class="hljs-keyword">final</span>类<br>字符序列也是存在堆里<br>方法没有实现线程安全，没有互斥处理，synchronied关键字<br></code></pre></td></tr></table></figure>
<h3 id="三种字符串对比">三种字符串对比</h3>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span> 不可变字符序列，修改效率低，但是复用率高<br>StringBuffer 可变字符序列，效率高，线程安全<br>StringBuilder 可变字符序列，效率最高，线程不安全<br><br><span class="hljs-type">String</span>每次修改时 s+=‘a<span class="hljs-number">&#x27;</span>会有大量的副本留存在内存中，使得效率降低，如果需要对<span class="hljs-type">String</span>做大量修改，不要使用<span class="hljs-type">String</span><br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230227185829121.png" srcset="/img/loading.gif" lazyload
alt="image-20230227185829121" />
<figcaption aria-hidden="true">image-20230227185829121</figcaption>
</figure>
<h3 id="math类">Math类</h3>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">包含了一系列静态方法<br><span class="hljs-built_in">round</span>四舍五入<br><span class="hljs-built_in">sqrt</span>开方<br><span class="hljs-built_in">random</span>()随机数 int(<span class="hljs-keyword">a</span>+f*(b-<span class="hljs-keyword">a</span>+<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure>
<h3 id="arrays-类">Arrays 类</h3>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">包含了一些列静态放啊，用于管理和操作数组<br><span class="hljs-regexp">//</span>toString 转换为一个String类型，并添加双括号<br><span class="hljs-regexp">//</span>sort排序算法 有两个参数，第一个参数是个类（不可以是基本数据类型），第二个类型是个匿名内部类，实现了Comparator接口中的compare方法。<br><span class="hljs-regexp">//</span>binarySearch 找不到时返回元素应该在的位置乘以负<span class="hljs-number">1</span>（不是索引，而是从一开始计算）<br><span class="hljs-regexp">//</span>copyOf(arr,length)拷贝length个元素到新数组，要求length&gt;=<span class="hljs-number">0</span>，当超出最大长度时，int型在末尾添加<span class="hljs-number">0</span>，Integer型在末尾添加null，该方法底层用的是System.arraycopy()<br><span class="hljs-regexp">//</span>fill使用指定数字替换数组所有元素<br><span class="hljs-regexp">//</span>equals 比较两个数组是否完全相同<br><span class="hljs-regexp">//</span>asList 将数组转化为List 运行类型是Arrays类的一个静态内部类，编译类型是一个asList编译类型（List接口）<br></code></pre></td></tr></table></figure>
<h3 id="system类">System类</h3>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>System.<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>) 表示正常退出<br><span class="hljs-regexp">//</span>System.arraycopy（arr1,a,arr2,b,n）; arr1原数组，a从哪开始拷贝，arr2接受拷贝元素的数组，b从哪开始拷贝，n拷贝几个<br><span class="hljs-regexp">//</span>Systyem.currentTimeMillents 返回从当前时间到某个时间的差异，以毫秒为单位<br></code></pre></td></tr></table></figure>
<h3 id="biglnteger类-和-bigdecimal类">Biglnteger类 和 BigDecimal类</h3>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">add</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">subtract</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">multiply</span><br><span class="hljs-keyword"></span><span class="hljs-keyword">divide </span>对于<span class="hljs-keyword">BigDecimal可能出现异常，无限循环小数，使用Bigdecimal.ROUND_CEILING </span>保留到分子的精度<br></code></pre></td></tr></table></figure>
<h3 id="日期类">日期类</h3>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Data 精确到毫秒，代表特定的时间 ，在java.util包里<br>Data d1 = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>() 获取当前系统时间 <br>SimpleDateFormat sdf = <span class="hljs-built_in">new</span> SimpledateFormat(&quot;yyyy年MM月dd日 hh时：mm分：ss秒 E星期几&quot;)<br>String <span class="hljs-keyword">format</span> = sdf.format(d1)<br>Data d1 = <span class="hljs-built_in">new</span> <span class="hljs-type">Date</span>(<span class="hljs-number">1234567</span>) 将毫秒数转化为时间<br><span class="hljs-type">Date</span> parse = sdf.parse(s) 将字符串按照指定的格式转化为时间 （抛出一个异常）<br><br>Calendar类<br>是一个抽象类，并且构造器是私有化的，使用getInstance()来获取实例<br>Calendar c = Calendar.getInstance();<br>c.<span class="hljs-keyword">get</span>(Calendar.YEAR)<br>c.<span class="hljs-keyword">get</span>(Calendar.MONTH)+<span class="hljs-number">1</span> //默认从<span class="hljs-number">0</span>开始<br>c.<span class="hljs-keyword">get</span>(Calendar.DAY_OF_OMNTH)<br>c.<span class="hljs-keyword">get</span>(Calendar.HOUR)<br>c.<span class="hljs-keyword">get</span>(Calendar.MINUTE)<br>c.<span class="hljs-keyword">get</span>(Calendar.SECOND)<br>自己组合日期<br>默认是<span class="hljs-number">12</span>小时进制，HOUR_OF_DAY <span class="hljs-number">24</span>小时进制<br>也有一些问题。例如日期和时间这样的类应该是不可变的<br>月份从<span class="hljs-number">0</span>开始<br>不能使用格式化<br>线程不安全；不能处理闰秒（每隔两天，多出<span class="hljs-number">1</span>s）<br><br><br>LocatDateTime类<br>获取当前时间 LocalDataTime lc = <span class="hljs-built_in">new</span> LocalDateTime.now()<br>lc.getYear(),lc.getMonthValue()返回值，lc.getMonth()返回英文月<br>LocalDate（只能获取年月日）<br><span class="hljs-built_in">LocalTime</span>(只能获取时分秒)<br>使用DateTimeFromatter 对象来进行格式化<br>	LocalDataTime ldt = LocalDateTime.now()<br>	DateTimeFormat dtf = DatetimeFormatter.ofPattern(&quot;yyyy年MM月dd日HH小时mm分钟ss秒&quot;)<br>	String strdate =  dtf.format(ldt)<br>	<br>Instant时间戳<br>通过静态方法now()获取表示当前时间戳的对象<br>Instant now = Instant.now()<br>转换成第一代时间对象<br><span class="hljs-type">Date</span> <span class="hljs-type">date</span> = <span class="hljs-type">Date</span>.<span class="hljs-keyword">from</span>(now)<br>转换成Instant<br>instant instant = <span class="hljs-type">date</span>.toInstant()<br></code></pre></td></tr></table></figure>
<h3 id="集合">集合</h3>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">数组的扩容比较麻烦，存储必须保存同一类型的元素，增加删除元素比较复杂<br><br>集合可以动态保存任意多个对象<br>提供了一系列方便的操作对象的方法，元素的添加删除方便<br><br>如何选取集合类？<br>	<span class="hljs-number">1.</span>先判断存储类型<br>		一组对象：<span class="hljs-variable">Collention</span>接口<br>			 允许重复：<span class="hljs-built_in">List</span><br>			 		增删多：<span class="hljs-variable">LinkedList</span><br>			 		改查多：<span class="hljs-variable">ArrayList</span><br>			 不允许重复：<span class="hljs-variable">set</span><br>			 		无序：<span class="hljs-variable">HashSet</span><br>			 		排序：<span class="hljs-variable">TreeSet</span>	<br>			 		插入和取出顺序一致：<span class="hljs-variable">LinkedHashSet</span><br>		一组键值对：<span class="hljs-built_in">Map</span><br>			 键无需：<span class="hljs-variable">HashMap</span><br>			 键排序：<span class="hljs-variable">TreeMap</span><br>			 键插入和去除顺序一致：<span class="hljs-variable">LinkedHashMap</span><br>			 读取文件：<span class="hljs-built_in">Properties</span><br>	<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230227194059987.png" srcset="/img/loading.gif" lazyload
alt="image-20230227194059987" />
<figcaption aria-hidden="true">image-20230227194059987</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230227194342121.png" srcset="/img/loading.gif" lazyload
alt="image-20230227194342121" />
<figcaption aria-hidden="true">image-20230227194342121</figcaption>
</figure>
<h4
id="单列集合collection放单个对象">单列集合collection（放单个对象）</h4>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">collection是个接口,实现子类可以存放多个元素，每个元素可以是对象<br>有些实现类可以存放重复元素，有些不可以<br>有些实现类是有序的（list），有些不是有序的（<span class="hljs-keyword">set</span>）<br>collection接口没有直接的实现子类，是通过它的子接口<span class="hljs-keyword">set</span>和list来实现的<br><br>collection常用方法<br>List list = <span class="hljs-keyword">new</span> ArrayList（）<br>list.add() 添加元素 只要是对象就可以添加<br>list.remove() 可以指定索引，可以指定某个对象<br>list.contains（)返回布尔类型<br>list.size（）获取元素的个数<br>list.isempty（）空<span class="hljs-number">1</span>非空<span class="hljs-number">0</span><br>list.clear（）清空所有元素<br>list.addAll()添加多个元素 接受一个集合<br>list.removeAll()删除多个元素 接受一个集合<br>list.containsAll() 查找多个元素 接受一个集合<br><br><span class="hljs-keyword">Iterator</span><br>调用<span class="hljs-keyword">iterator</span>.next()方法之前必须要调用<span class="hljs-keyword">iterator</span>.hasNext()进行检测，若不调用，且下一条记录无效，会抛出NoSuchElementException异常<br>    <span class="hljs-keyword">Iterator</span> <span class="hljs-keyword">iterator</span> = col.iterator()；<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">iterator</span>.haxNext())<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    Object obj = iterator.next();</span><br><span class="hljs-comment">    &#125;</span>	<br>    快捷键 itit <span class="hljs-comment">//ctrl+j显示所有快捷键</span><br>    当退出<span class="hljs-keyword">while</span>循环后，it已经指向最后一个元素，如果需要遍历，需要重置迭代器 <span class="hljs-keyword">iterator</span> = col.iterator()<span class="hljs-punctuation">;</span><br>    <br>    增强<span class="hljs-keyword">for</span> 底层仍然是迭代器<br>    <span class="hljs-keyword">for</span>(Object obj:实例对象的引用)<span class="hljs-comment">&#123;</span><br><span class="hljs-comment">    System.out.println(obj);</span><br><span class="hljs-comment">    &#125;</span><br>    快捷键 I<br></code></pre></td></tr></table></figure>
<h5 id="list">List</h5>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs vim">List集合类中元素有序（添加顺序和取出顺序一致，元素可重复）<br>List集合类中的每个元素都有对应元素的顺序索引 <span class="hljs-keyword">list</span>.<span class="hljs-built_in">get</span>(<span class="hljs-number">0</span>)<br>返回obj在当前集合中首次出现的位置List.indexOf()<br>返回obj在当前集合中最后一次出现的位置List.lastIndexOf()<br>移除索引为<span class="hljs-built_in">index</span>的元素List.<span class="hljs-built_in">remove</span>(<span class="hljs-number">0</span>)<br>替换索引为<span class="hljs-built_in">index</span>的元素List.<span class="hljs-keyword">set</span>(<span class="hljs-number">1</span>,obj) 必须得存在<br>返回子集合<span class="hljs-keyword">list</span>.subList(<span class="hljs-keyword">a</span>,<span class="hljs-keyword">b</span>) 前闭后开<br><br>ArrayList类<br>ArrayList可以存放空值，是由数组实现存储的，ArrayList基本等于同于Vector，但是线程不安全，效率高<br><br>ArrayList中维护了一个Object类型的数组，elementData<br>	首次创建时，如果使用的是无参构造器，则初始容量为<span class="hljs-number">0</span><br>	第一次添加扩容到<span class="hljs-number">10</span>，再次扩容时扩容<span class="hljs-number">1.5</span>倍<br>	使用指定大小的构造器时，扩容为已有大小的<span class="hljs-number">1.5</span>倍<br>	<br>Vector类<br>底层也是一个对象数组，是线程安全的，基本所有操作都被synchronized修饰<br>如果是无参初始化，默认十个空间，满了就<span class="hljs-number">2</span>倍扩容，如果指定了大小，则每次扩容时按照两倍扩容<br><br>LinkedList类<br>实现了双向链表和双端队列特点<br>可以添加任意元素（元素可以重复），包括null<br>线程不安全<br>LinkedList中维护了两个属性<span class="hljs-keyword">first</span>和<span class="hljs-keyword">last</span>分别指向首节点和尾节点<br>每个节点（Node对象【内部类】）又维护了<span class="hljs-keyword">prev</span>、<span class="hljs-keyword">next</span>、item三个属性，通过<span class="hljs-keyword">prev</span>指向前一个，<span class="hljs-keyword">next</span>指向后一个节点<br><br></code></pre></td></tr></table></figure>
<h5 id="set">set</h5>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">set</span>接口对象-----<span class="hljs-built_in">set</span>接口实现类的对象<br>无序，添加和取出的顺序不一样，但取出的顺序是固定的<br>重复元素不存在，但可以反复添加重复元素<br>常用方法和Collection接口一样<br>可以使用迭代器或者是增强<span class="hljs-keyword">for</span>来进行遍历，不可以使用索引的方式<br><br>HashSet类<br>底层是<span class="hljs-built_in">HashMap</span>，<span class="hljs-built_in">HashMap</span>底层是数组加链表加红黑树 <br>存储效率会很高<br>HashSet添加元素过程：<br>	首先将通过哈希函数得到hash值，再转换为索引值<br>	找到存储数据tabel对应的位置<br>	如果没有元素直接存进去<br>	如果有调用equals比较，相同就放弃添加，不同则添加到最后（所以值相同的string对象无法重复存储）<br>	如果某条链表的长度大于把，总table大小大于<span class="hljs-number">64</span>，则转化为红黑树存储<br>HashSet添加元素源码分析<br>	<span class="hljs-number">1.</span>首先执行构造器<br>	<span class="hljs-number">2.</span> 从<span class="hljs-built_in">add</span>方法跳到<span class="hljs-built_in">map</span>的put方法<br>	<span class="hljs-number">3.</span>put方法接受<span class="hljs-built_in">key</span> 和 value（hashmap） value被一个使用<span class="hljs-keyword">final</span>以及<span class="hljs-keyword">static</span>空对象占位<br>		返回 <span class="hljs-title function_">putVal</span>(hash（<span class="hljs-built_in">key</span>),<span class="hljs-built_in">key</span>,value,<span class="hljs-literal">false</span>,<span class="hljs-literal">true</span>) 即跳入putVal方法<br>	<span class="hljs-number">4.</span><span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>) 如果<span class="hljs-built_in">key</span>非空的话，返回 其hashcode与 hashcode无符号位移<span class="hljs-number">16</span>位后的异或 <span class="hljs-type">int</span>型变量<br>	<br>LinkedHashSet:HashSet的子类<br>底层是一个数组加一个双向链表，LinkedHashMap<br>同样根据元素的hashCode计算出hash值<br>与hashset的区别在于，每个节点多了一个前驱，遍历时可以按照插入顺序进行遍历<br>LinkedHashSet存放的节点类型是LinkedHashMap$Entry<br>数组是Hashmap$Node[] 存放的数据是LinkedHashMap$Entry Entry是一个内部类继承了Node类型，拥有前后指针<br><br>TreeSet可以排序，底层还是TreeMap<br>	使用无参构造器创建TreeSet时，仍然是无序的<br>    使用TreeSet的一个构造器 ，可以传入一个比较器<span class="hljs-title function_">Comparator</span>(匿名内部类)，比较器传递给TreeMap<br>    <br></code></pre></td></tr></table></figure>
<h4 id="双列集合放两个对象">双列集合(放两个对象)</h4>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">map</span>接口实现类特点<br><span class="hljs-built_in">map</span>中的<span class="hljs-built_in">key</span>和value可以是任何引用类型的数据（基本数据类型会被装箱）<br><span class="hljs-built_in">map</span>中的<span class="hljs-built_in">key</span>不允许重复<br>常用<span class="hljs-built_in">string</span>作为<span class="hljs-built_in">map</span>中的<span class="hljs-built_in">key</span><br>Map中的数据存放在Hashmap中的内部类Node中。<br>一对k-v也可以是一个Entry，但Entry并不存储数据,也称之为EntrySet集合，为了方便程序员的遍历，EntrySet&lt;Entry&lt;K,V&gt;&gt;<br><br><span class="hljs-built_in">map</span>接口常用方法<br><span class="hljs-built_in">put</span>添加<br><span class="hljs-built_in">remove</span>根据键删除映射关系<br>size获取元素个数<br>isEmpty判断是否空<br>clear清除<br>containKey查找键是否存在<br><br><span class="hljs-built_in">map</span>接口遍历方法<br>	(<span class="hljs-number">1</span>)先取出<span class="hljs-built_in">key</span>，通过<span class="hljs-built_in">key</span>取出相应的value<br>	Set keyset = <span class="hljs-built_in">map</span>.keySet();<br>	<span class="hljs-keyword">for</span>(object <span class="hljs-built_in">key</span>:keyset)&#123;<br>		sout(<span class="hljs-built_in">key</span>+<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>));<br>	&#125;<br>	Iterator iterator = keyset.iterator();<br>	<span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>	Object next = iterator.next();<br>	sout(next+<span class="hljs-string">&quot;&quot;</span>+<span class="hljs-built_in">map</span>.<span class="hljs-built_in">get</span>(next));<br>	&#125;<br>	(<span class="hljs-number">2</span>)把所有的value取出<br>	Collection <span class="hljs-built_in">values</span> = <span class="hljs-built_in">map</span>.<span class="hljs-built_in">values</span>();<br>	<span class="hljs-keyword">for</span>(Object obj:<span class="hljs-built_in">values</span>)&#123;<br>		sout(obj);<br>	&#125;<br>	Iterator iterator = <span class="hljs-built_in">values</span>.iterator();<br>	<span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>		Object value = iterator.next();<br>		sout(value)<br>	&#125;<br>	(<span class="hljs-number">3</span>)听过EntrySet来获取<span class="hljs-built_in">key</span><br>	Set entryset = <span class="hljs-built_in">map</span>.entrySet();<br>	<span class="hljs-keyword">for</span>(Object entry:entrySet)&#123;<br>		Map.entry m =(Map.Entry) entry;<br>		sout(m.getKey()+m.getValue)<br>	&#125;<br>	Iterator iterator = entryset.iterator();<br>	<span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>		Object obj = iterator.next();<br>		Map.Entry m = (Map.Entry)entry;<br>		sout(m.getKey(),m.getValue());<br>	&#125;<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230302135646652.png" srcset="/img/loading.gif" lazyload
alt="image-20230302135646652" />
<figcaption aria-hidden="true">image-20230302135646652</figcaption>
</figure>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//拿到key.<span class="hljs-keyword">Set</span>() 里边都是key<br><span class="hljs-keyword">Set</span> set1 = hashMap.keySet();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">Object</span> key :set1) &#123;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(hashMap.<span class="hljs-keyword">get</span>(key));<br>&#125;<br><br>Iterator iterator = hashMap.keySet().iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    <span class="hljs-keyword">Object</span> key =  iterator.next();<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(hashMap.<span class="hljs-keyword">get</span>(key));<br>&#125;<br>//拿到EntrySet 里边是一个一个Entry 一个Entry都有返回key的方法<br><span class="hljs-keyword">Set</span> set2 = hashMap.entrySet();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">Object</span> o :set2) &#123;<br>    Map.Entry entry = (Map.Entry) o;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(hashMap.<span class="hljs-keyword">get</span>(entry.getKey()));<br>&#125;<br>Iterator iterator1 = set2.iterator();<br><span class="hljs-keyword">while</span> (iterator1.hasNext()) &#123;<br>    <span class="hljs-keyword">Object</span> next =  iterator1.next();<br>    Map.Entry entry = (Map.Entry)next;<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(hashMap.<span class="hljs-keyword">get</span>(entry.getKey()));<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="hashmap">hashmap</h5>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sas">与hashset一样，不保证映射的顺序<br>允许键或者为空<br>没有实现线程同步，线程不安全，没有使用关键字修饰<br>底层数组加链表加红黑树<br>扩容机制和hashset完全一样<br>	1.HashMap底层维护了Node类型的数组<span class="hljs-keyword">table</span>，默认为<span class="hljs-keyword">null</span><br>	2.创建对象时通过加载因子loadfactor初始化为0.75<br>	3.添加<span class="hljs-keyword">key</span>-value时，首先通过<span class="hljs-keyword">key</span>的哈希值得到再<span class="hljs-keyword">table</span>的索引，在判断索引是否有元素，没有元素直接添加，铀元素判断两个元素的<span class="hljs-keyword">key</span>是否相同，如果相等则直接替换val；不等判断是树还是链表，并继续向下进行比较，容量不够时进行扩容。<br>	4.第一次添加时，默认<span class="hljs-keyword">table</span>容量为16，临界值（threshold）为12<br>	5.在扩容时，需要扩容的<span class="hljs-keyword">table</span>容量为原来的2倍，临界值为原来的2倍，依次类推<br>	6.Java8中，单链子元素超过TREEIFY_THRESHOLD（8）<span class="hljs-variable">&amp;&amp;</span> <span class="hljs-keyword">table</span> &gt;=MIN_TREEIFY_CAPACITY时，就会进行树化。<br>	<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230302152255292.png" srcset="/img/loading.gif" lazyload
alt="image-20230302152255292" />
<figcaption aria-hidden="true">image-20230302152255292</figcaption>
</figure>
<h5 id="hashtable">hashtable</h5>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">和hashmap使用方法基本和hashmap一致<br>与hashmap一样，不保证映射的顺序<br>但hashtable实现了线程安全 <br>hashtabel键和值都不允许为空，否则抛出空指针异常<br>底层数组为Hashtable%Entry[] 初始大小为<span class="hljs-number">11</span> <br>临界值为threshould <span class="hljs-number">8</span> <span class="hljs-operator">=</span> <span class="hljs-number">11</span>*<span class="hljs-number">0.75</span> ，超过<span class="hljs-number">8</span>才扩容<br>	<br></code></pre></td></tr></table></figure>
<p>properties</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">通常用来作为配置文件<br>是hashtable的子类<br>与hashtable一样，不保证映射的顺序<br>使用特点和Hashtable类似，存储键值对，不允许为空<br>可以从xxx.properties文件中加载某些数据到Properties类对象，并进行读取和修改<br>增加/修改 put<br>删除remove<br><br><span class="hljs-comment">//读取</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">fileReader</span>(<span class="hljs-string">&quot;src\\mysql.properties&quot;</span>));<br>properties.list(System.out)<br><span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> properties.getProperty(<span class="hljs-string">&quot;user&quot;</span>)<br><br><span class="hljs-comment">//创建,保存时使用的unicode码，修改就使用set方法</span><br><span class="hljs-type">Properties</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>p.setProperty(key,value);<br>p.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">fileOutputStream</span>(<span class="hljs-string">&quot;src\\mysel2.properties&quot;</span>),<span class="hljs-literal">null</span>)<br></code></pre></td></tr></table></figure>
<h5 id="treemap">treemap</h5>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm">默认构造器创建<span class="hljs-meta">map</span>是无序的<br>使用构造器传递一个实现了compator的匿名内部类进行key的比较<br>底层的put方法传入的是一个<span class="hljs-meta">Entry</span>，第一次添加把k-v封装到<span class="hljs-meta">Entry</span>对象，调用比较方法，判断放入的数据是否为空，然后放入root，以后添加走比较器。<br></code></pre></td></tr></table></figure>
<h3 id="collection工具类">Collection工具类</h3>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collection</span>.</span></span>reverse(<span class="hljs-built_in">list</span>)<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collection</span>.</span></span>shuffle(<span class="hljs-built_in">list</span>)<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collection</span>.</span></span>sort(<span class="hljs-built_in">list</span>)可以传入比较器<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collection</span>.</span></span>swap(<span class="hljs-built_in">list</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>)<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collection</span>.</span></span>max(<span class="hljs-built_in">list</span>)可以传入比较器 .min<span class="hljs-literal">()</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collection</span>.</span></span>frequency(<span class="hljs-built_in">list</span>,<span class="hljs-string">&quot;Tom&quot;</span>)<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collection</span>.</span></span>copy(newlist,formaerlist) newlist的长度需要和<span class="hljs-built_in">list</span>保持一致 newlist=formaerlist<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>replace<span class="hljs-constructor">All(<span class="hljs-params">list</span>,<span class="hljs-params">former</span>,<span class="hljs-params">new</span>)</span> former=<span class="hljs-keyword">new</span><br></code></pre></td></tr></table></figure>
<h3 id="泛型">泛型</h3>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">传统方法不能对加入到集合中的数据类型进行约束（不安全）<br>遍历的时候需要进行类型转换，影响效率<br><br>ArrayList&lt;Dog&gt; <span class="hljs-built_in">array</span>List = new ArrayList&lt;dog&gt;() <br>集合中的元素是Dog类型以及其子类型<br>遍历的时候可以直接取出dog类型<br><br>泛型可以表示多种数据类型（Integer，String，Dog）的数据类型<br>在类声名或者实例化的时候制定好具体的数据类型<br>泛型可以保证如果程序在编译时没有发出警告，运行时就不会出现类型转换异常<br>泛型可以在类声名时通过一个标识表示类中某个属性的类型，或者是某个方法返回值的类型，或者是参数类型<br>	<span class="hljs-keyword">class</span> <span class="hljs-symbol">Person</span>&lt;<span class="hljs-symbol">E</span>&gt;&#123;<br>		E s;<span class="hljs-comment">//E表示s的数据类型，该数据类型在定义Person对象的时候指定，即在编译期间就确定了E是什么类型</span><br>		<span class="hljs-keyword">public</span> E f()&#123;<span class="hljs-comment">//E可以是返回类型</span><br>			<span class="hljs-keyword">return</span> s;<br>		&#125;<br>		<span class="hljs-keyword">public</span> Person(E s)&#123; <span class="hljs-comment">//E 可以是参数类型</span><br>			<span class="hljs-keyword">this</span>.s = s;<br>		&#125;<br>	&#125;<br><br>泛型的声明<br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">student</span>&lt;<span class="hljs-symbol">Q</span>,<span class="hljs-symbol">K</span>,<span class="hljs-symbol">V</span>&gt;&#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-symbol">student</span>&lt;<span class="hljs-symbol">Q,<span class="hljs-symbol">K</span>,<span class="hljs-symbol">V</span></span>&gt;<br><br>泛型只能指定为引用类型<br>再给泛型指定具体类型后，可以传入该类型或该类型的子类<br><br>没有给泛型指定具体的类别，那么泛型的类型默认为<span class="hljs-symbol">Object</span><br><br>自定义泛型类的细节（使用 &lt;&gt;修饰的类）<br>普通成员（属性，方法）可以使用泛型<br>使用泛型的数组，不能初始化<br>静态方法中不能使用类的泛型（静态是和类相关的，在类加载时可能对象还没有创建，也就不知道泛型的具体类型是什么）<br>创建对象时，如果没有指定类型默认为<span class="hljs-symbol">object</span><br><br>自定义泛型接口细节<br>接口中，静态成员也不能使用泛型（<span class="hljs-symbol">U</span> <span class="hljs-symbol">name</span>也不行，接口内的变量默认被<span class="hljs-symbol">static</span>修饰）<br>泛型接口的类型，在继承接口或者实现接口时确定<br>没有指定类型，则默认为<span class="hljs-symbol">object</span><br><br>自定义泛型方法细节<br><span class="hljs-symbol">public</span> &lt;<span class="hljs-symbol">AAA</span>&gt; <span class="hljs-symbol">void</span> <span class="hljs-symbol">f</span>(<span class="hljs-symbol">AAA</span> <span class="hljs-symbol">a</span>)&#123;&#125;<br>泛型方法可以定义在泛型类中，也可以定义在普通类中<br>当泛型类被调用时类型必须被确定<br>泛型方法也可以使用泛型类中的泛型，注意区分泛型方法和方法使用泛型<br><br>泛型的继承和通配<br>泛型不允许向上向下转型（继承）<br>通配意思是：原本在使用&lt;&gt;时，泛型的类型是确定的，但现在可以通过添加修饰符来扩大其范围<br>&lt;?&gt;支持任意类型泛型  <br>&lt;? extends A&gt;支持A类以及A类的子类  <br>&lt;? <span class="hljs-keyword">super</span> A&gt;支持A类以及A类的父亲<br></code></pre></td></tr></table></figure>
<h3 id="单元测试junit">单元测试junit</h3>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">@<span class="hljs-keyword">Test</span>修饰方法<br>alt+<span class="hljs-keyword">enter</span>引入<span class="hljs-number">5.4</span><br></code></pre></td></tr></table></figure>
<h3 id="线程进程">线程进程</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java">创建线程有两种方式<br>继承Thread类，重写run方法，使用start（）运行【不调用star不会真正启动一个线程】<br><span class="hljs-keyword">package</span> thread_.simple_example;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">job1</span> <span class="hljs-variable">job1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">job1</span>();<br>        job1.start();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;asdasd&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">job1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(count&gt;=<span class="hljs-number">10</span>)<br>                <span class="hljs-keyword">break</span>;<br>            System.out.println(<span class="hljs-string">&quot;----&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            count++;<br>        &#125;<br>    &#125;<br>&#125;<br>使用jconsole查看线程情况<br>主线程（main）不会被阻塞，一个进程不会因为主线程结束便直接消亡<br>star（）方法会调用star0方法，而star0时本地方法，由JVM调用，底层是c/c++实现，star0才是真正的多线程实现方法<br><br>实现Runnable接口，重写run方法（弥补单继承带来的问题 ）<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Job2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count=<span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)&#123;<br>            <span class="hljs-keyword">if</span>(count&gt;=<span class="hljs-number">60</span>)<br>                <span class="hljs-keyword">break</span>;<br>            System.out.println(<span class="hljs-string">&quot;bbbb&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            count++;<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(job2);<br>thread.start();<br>实例化一个thred对象，传入一个实现了Runable接口的类，这里使用了设计模式（代理模式）<br>无论是使用runable接口方式创建线程还是使用Thread重写run方法创建线程本质上没有区别，底层都是run0方法。使用runable接口方式更适合多个线程共享一个资源的情况，如创建多个线程接受实现了Runable的接口实现类<br>    <br>线程的中止<br>线程完成任务后会自动退出<br>在线程中定义一个flag，使得主线程可以修改，在主线程修改该flag即可实现提前中止线程<br>     <br>线程常用方法<br>setName：设置线程名称<br>getName:返回该线程名称<br>start:使线程开始执行<br>run：调用线程对象的run方法<br>setPriority：更改线程的优先级<br>getPriority：获取线程的优先级  <br>sleep：阻塞线程<br>interrupt:中断线程，但没有真正的结束线程，常用来中断sleep，wait，join等方法<br>yield：让不一定礼让成功<br>join：假设两个线程t1 t2 ，t2调用join,代表放弃资源。插入一但成功时，则会一直持续到执行完毕<br>    <br>守护线程<br>当所有的用户线程结束，守护线程自动结束，例如垃圾回收机制就是常见的守护线程<br>在run方法中设置为无限循环，在主线程中设置为job2.setDatmon(<span class="hljs-literal">true</span>),然后再启动<br>    <br>线程的生命周期<br>使用thread.State枚举表示了线程的几种状态<br>NEW 尚未启动的线程<br>RUNNABLE 在java虚拟机中执行的线程<br>BLOCKED 被阻塞的线程<br>WAITING 等待另一个线程的线程<br>TIMED_WAITING 正在等待另一个线程执行动作达到指定等待时间的线程<br>TERMINATED 已退出的线程<br>    <br><br>互斥锁：<br>java中引入了对象互斥锁的概念，来保证共享数据操作的完整性<br>每个对象都对应于一个可称为互斥锁的标记，保证在任一时刻，只能由一个线程来访问该对象<br>同步方法（非静态）的锁可以是<span class="hljs-built_in">this</span>，也可以是其他对象<br>同步方法（静态）的锁为当前类本身<br>    <br>线程同步：保证数据在任何同一时刻，最多只有一个线程访问<br>Synchronized两种用法<br>	<span class="hljs-number">1.</span>同步代码块（优先选用）<br>    <span class="hljs-number">2.</span>在方法上使用<span class="hljs-keyword">synchronized</span><br>    <br>线程的死锁<br>多个线程都占用了对方的锁资源，导致双方都无法继续往下运行<br>    <br>释放锁的操作：<br>    <span class="hljs-number">1.</span>当前线程的同步方法，同步代码块执行结束<br>    <span class="hljs-number">2.</span>当前线程的同步方法，同步代码块遇到<span class="hljs-keyword">break</span>，<span class="hljs-keyword">return</span><br>    <span class="hljs-number">3.</span>当前线程的同步方法，同步代码块出现了未处理的异常或者Error<br>    <span class="hljs-number">4.</span>当前线程的同步方法，同步代码块中执行了线程对象的wait方法，当前线程暂停并释放锁<br>不会释放锁的操作：<br>    <span class="hljs-number">1.</span>sleep(),yield()<br>    <span class="hljs-number">2.</span>线程执行同步代码块时，其他线程调用了该线程的suspend（）方法将该线程挂起<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230306110408471.png" srcset="/img/loading.gif" lazyload
alt="image-20230306110408471" />
<figcaption aria-hidden="true">image-20230306110408471</figcaption>
</figure>
<h3 id="io流">IO流</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java">文件在程序中是以流的形式来操作的<br>流：数据在数据源（文件）和程序（内存）之间经历的路径<br>输入流：数据从数据源（文件）到程序（内存的路径）<br>输出流：数据从程序（内存）到数据源（文件）的路径<br>File的创建有三种方法（三种构造器）<br>	<span class="hljs-number">1.</span><br>	 <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(String file)</span>&#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(file);<br>        <span class="hljs-keyword">try</span> &#123;<br>            file1.createNewFile();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-number">2.</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(String floder,String file)</span>&#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(floder,file);<br>        <span class="hljs-keyword">try</span> &#123;<br>            file1.createNewFile();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>	<span class="hljs-number">3.</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">create</span><span class="hljs-params">(File parentFile,String fileName)</span>&#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(parentFile, fileName);<br>        <span class="hljs-keyword">try</span> &#123;<br>            file1.createNewFile();<br>            System.out.println(<span class="hljs-string">&quot;文件创建成功&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>常用文件操作<br>file.getName()获取文件的名字<br>file.getAbsolutepath()文件绝对路径<br>file.getParent()文件的父级别目录<br>file.length()文件的大小<br>file.exists()文件是否存在<br>file.isFile()是不是一个文件<br>file.isDirectory是不是一个目录<br>file.mkdir 创建一级目录<br>file.mkdirs创建多级目录<br>file.delete删除空目录或者文件<br>    <br>IO流原理和分类<br>java中，对于数据的输入输出以流的方式进行<br>按照操作数据的单位不同可以分为字节流（效率更低，操作二进制文件时保证无损操作）以及字符流（一个字符多少个字节要看具体的编码，效率更高）；按照数据流向可以分为输入流以及输出流；按照流的角色不同分为节点流以及处理流（包装流）<br>字节流输入流的顶级父类为InputStream，输出流的顶级父类为OutputStream<br>字符流输入流的顶级父类为Reader，输出流的顶级父类为Writer<br>Java的IO流共涉及<span class="hljs-number">40</span>多个子类，都是从上述的四个抽象基类派生出的，后续的子类名称都是以其父类名作为子类名后缀<br>    <br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307095007372.png" srcset="/img/loading.gif" lazyload
alt="image-20230307095007372" />
<figcaption aria-hidden="true">image-20230307095007372</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java">InputStream常用类<br>FileInputStream有三个常用的构造器（String name） （File file） （fdob文件描述符）<br>read() 方法每次读取一个字节，返回<span class="hljs-type">int</span>类型，读取结束时返回-<span class="hljs-number">1</span> ，碰到汉字会乱码，因此文本文件最好用字符流<br> <span class="hljs-type">String</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;C:\\Users\\zs\\Desktop\\game\\SBeacnm478.TXT&quot;</span>;<br>        FileInputStream fileInputStream=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fileInputStream= <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>            <span class="hljs-type">int</span> r_=<span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">while</span>( (r_=fileInputStream.read())!=-<span class="hljs-number">1</span>)<br>                System.out.println((<span class="hljs-type">char</span>)r_);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fileInputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>使用read(<span class="hljs-type">char</span> a[])方法，读取成功时返回实际读取的字节数，形参表明了一次读取多少个<span class="hljs-type">byte</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">byte</span> r[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">8</span>];<br>        FileInputStream fileInputStream1=<span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fileInputStream1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file);<br>            <span class="hljs-keyword">while</span>((len=fileInputStream1.read(r))!=-<span class="hljs-number">1</span>)<br>                System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(r));<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fileInputStream1.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br><br><br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307150912629.png" srcset="/img/loading.gif" lazyload
alt="image-20230307150912629" />
<figcaption aria-hidden="true">image-20230307150912629</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">FileOutputStream有二个常用的构造器（String name） （File file，<span class="hljs-type">boolean</span> append） （fdob文件描述符）<br>当需要写入的文件不存在时，会创建文件（目录需要存在），当append为<span class="hljs-literal">true</span>时，则写入文件已存在不会覆盖而是在末尾追加<br> String file=<span class="hljs-string">&quot;D:\\a.txt&quot;</span>;<br>        <span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fileOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            fileOutputStream=<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(file);<br>            <span class="hljs-comment">//写入一个字符</span><br>            fileOutputStream.write(<span class="hljs-string">&#x27;a&#x27;</span>);<br>            <span class="hljs-comment">//写入字符串</span><br>            fileOutputStream.write(<span class="hljs-string">&quot;asdasdaasd&quot;</span>.getBytes());<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fileOutputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br><br>例如输入流和输出流可以实现文件拷贝，参找use包实现的文件拷贝的练习<br>    <br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307153657851.png" srcset="/img/loading.gif" lazyload
alt="image-20230307153657851" />
<figcaption aria-hidden="true">image-20230307153657851</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307154150767.png" srcset="/img/loading.gif" lazyload
alt="image-20230307154150767" />
<figcaption aria-hidden="true">image-20230307154150767</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">字符流的操作<br>FileReader<br>	通过File对象或者传入绝对路径创建一个FileReader对象	<br>	通过read方法来实现文件的读取：<br>	重载方法有read()单个字符读取，到文件末尾返回-<span class="hljs-number">1</span><br>	read（<span class="hljs-type">char</span>[]）一次读取多个，返回读取的字符数，到末尾返回-<span class="hljs-number">1</span><br>	<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[]) <span class="hljs-type">char</span>-&gt;String,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-type">char</span>[],a,b) 指定部分转化为String<br>    <br>    <br>	<br>FileWriter<br>	通过File对象或者绝对路径来创建一个FileWriter对象，通过指定一个<span class="hljs-type">boolean</span>=True来实现文件的追加模式<br>	write(<span class="hljs-type">int</span>)写入单个字符<br>	write(<span class="hljs-type">char</span>[])写入指定数组<br>	write(<span class="hljs-type">char</span>[],a,b)写入指定部分<br>	write(string) 写入string文件<br>    write(string,a,b)写入string指定部分<br>filewrite使用后必须要关闭或者刷新（flush），否则写入不到指定的文件<br></code></pre></td></tr></table></figure>
<h4 id="节点流和处理流">节点流和处理流</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java">节点流可以从一个特定的数据读写数据，入FileReader，FileWriter<br>包装流（处理流）封装了所有的Reader子类。<br>节点流直接与数据源相连，处理流可以消除不同节点流的实现差异，也可以提供更为方便的方法来完成输入输出。<br>包装流使用了修饰器设计模式，不会与数据直接相连。<br>数据流的主要功能是（性能的提高），操作的便捷（提供了一系列便捷的方法来一次输入大批量的数据，使用更加灵活方便）<br><br>BufferReader和BufferWriter属于字符流 ，关闭时只需要关闭外层循环即可。<br><br><span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BUfferedreader</span>（<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>（filePath））;<br><span class="hljs-keyword">while</span>((line=bufferedReader.readLine())!=<span class="hljs-literal">null</span>)<br>bufferedReader.close();<br><span class="hljs-comment">//Buffer在实现添加数据时实际上是在节点流部分的构造器添加</span><br><span class="hljs-type">BufferedWriter</span> <span class="hljs-variable">bufferedWriter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedWriter</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileWriter</span>(filePath,<span class="hljs-literal">true</span>))<br>bufferedWriter.write(<span class="hljs-string">&quot;hello&quot;</span>)<br>bufferedWriter.newLine();<br>bufferedWrite.close();<br><br>BufferedInputStream 和BufferedOutputStream属于字节流 用于操作二进制文件<br>需要注意写出时要指定长度<br>    <br><br><br>    <br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307180556141.png" srcset="/img/loading.gif" lazyload
alt="image-20230307180556141" />
<figcaption aria-hidden="true">image-20230307180556141</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307180648187.png" srcset="/img/loading.gif" lazyload
alt="image-20230307180648187" />
<figcaption aria-hidden="true">image-20230307180648187</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">对象流（属于处理流）<br>将基本数据类型或者对象进行序列化（保存数据的值以及类型）或者反序列化操作（恢复数据的值以及类型）<br>需要序列化的对象必须实现Serializable（一般选这个）接口或者Externalizable（有方法）接口<br><span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath))<br><span class="hljs-comment">//数据类型一定要写清楚</span><br>o.writeInt(<span class="hljs-number">100</span>) --自动装箱<br>o.writeBoolean(<span class="hljs-literal">true</span>)<br>o.writeUTF(<span class="hljs-string">&quot;asdasd&quot;</span>)<br>o.writrObject(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-number">10</span>)) <span class="hljs-comment">//需要实现Serializable接口</span><br>    <br><span class="hljs-comment">//反序列化</span><br><span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(filePath))<br><span class="hljs-comment">//读取顺序需要和你保存数据的顺序一致,需要调用该对象时，需要确保该对象在可以引用的位置</span><br><span class="hljs-comment">//反序列化调用该对象时，要确保和序列化时的包相同</span><br>o.readInt()<br>o.readBoolean()<br>o.readUTF()<br><span class="hljs-type">Objuct</span> <span class="hljs-variable">dog</span> <span class="hljs-operator">=</span> o.readObject()<br>o.close()<br><span class="hljs-comment">//序列化时默认会把所有的属性全部序列化，除了static和transient修饰的成员</span><br><span class="hljs-comment">//序列化对象时，要求里边属性的类型也需要实现序列化接口</span><br><span class="hljs-comment">//序列化具备可继承性，父类如果实现了序列化，则其所有子类也默认实现了序列化</span><br></code></pre></td></tr></table></figure>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">标准输入输出流（）<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">in</span>(输入流：编译类型InputStream，运行类型BufferedInpoutStream，从键盘接受)<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>（输出流：编译类型PrintStream，运行类型PrintStream<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307193250756.png" srcset="/img/loading.gif" lazyload
alt="image-20230307193250756" />
<figcaption aria-hidden="true">image-20230307193250756</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307193456970.png" srcset="/img/loading.gif" lazyload
alt="image-20230307193456970" />
<figcaption aria-hidden="true">image-20230307193456970</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">转换流 字节流包装为字符流<br>字节流可以指定编码，这样可以指定读入文件的编码类型而避免乱码问题<br>InputeStreamReader（inputStream，charset） 传入一个字节流，并且指定编码方式<br>OutputeStreamReader（OutputStream，charset） 传入一个字节流，并且指定编码方式 <br>处理纯文本数据时，使用字符流效率更高，且有效解决中文问题<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307193936897.png" srcset="/img/loading.gif" lazyload
alt="image-20230307193936897" />
<figcaption aria-hidden="true">image-20230307193936897</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230307194041872.png" srcset="/img/loading.gif" lazyload
alt="image-20230307194041872" />
<figcaption aria-hidden="true">image-20230307194041872</figcaption>
</figure>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss">打印流(只有输出流没有输入流)<br>PrintStream 也可以打印到文件里 字节流<br>PrintWriter 也可以打印到文件里 字符流<br></code></pre></td></tr></table></figure>
<h3 id="反射">反射</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">前提：根据propoties文件中记录的信息，来创建一个新的类<br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties.setProperty(<span class="hljs-string">&quot;class_name&quot;</span>,<span class="hljs-string">&quot;com.zs.tools.Dog&quot;</span>);<br>properties.setProperty(<span class="hljs-string">&quot;meth&quot;</span>,<span class="hljs-string">&quot;say&quot;</span>);<br>properties.store(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(<span class="hljs-string">&quot;src\\in_.properties&quot;</span>),<span class="hljs-literal">null</span>);<br><br><span class="hljs-type">Properties</span> <span class="hljs-variable">properties1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();<br>properties1.load(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;src\\in_.properties&quot;</span>));<br><span class="hljs-type">String</span> <span class="hljs-variable">namee</span> <span class="hljs-operator">=</span> properties1.getProperty(<span class="hljs-string">&quot;class_name&quot;</span>).toString();<br><span class="hljs-type">String</span> <span class="hljs-variable">methh</span> <span class="hljs-operator">=</span> properties1.getProperty(<span class="hljs-string">&quot;meth&quot;</span>).toString();<br><br><span class="hljs-type">Class</span> <span class="hljs-variable">cls</span> <span class="hljs-operator">=</span> Class.forName(namee);<br><span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> cls.newInstance();<br><span class="hljs-type">Method</span> <span class="hljs-variable">method1</span> <span class="hljs-operator">=</span> cls.getMethod(methh);<br>method1.invoke(o);	<br><br>反射机制允许程序在执行期间，借助于其提供的API访问任何类的内部信息（成员变量，属性，构造器，方法等），并可以操作对象的属性以及方法<br><br>加载完类之后，在堆中就产生了一个class类型的对象（一个类只有一个Class对象），这个对象包含了类完整的结构信息。通过这个对象得到类的结构，这个Class对象就像一面镜子，透过这个镜子看到类的结构，所以称之为反射。<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308152710207.png" srcset="/img/loading.gif" lazyload
alt="image-20230308152710207" />
<figcaption aria-hidden="true">image-20230308152710207</figcaption>
</figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">在运行时判断任意一个对象所属的类<br>在运行时构造任意一个类的对象<br>在运行时得到任意一个类所有具有的成员变量和方法<br>在运行时调用任意一个对象的成员变量和方法<br>生成动态代理<br>java.lang.Class代表一个类，Class对象表示某个类加载后在堆中的对象<br>java.lang.reflect.Method代表类的方法<br>java.lang.reflect.Field 代表类的成员变量<br>java.lang.reflect.Constructor代表类的构造方法<br><br><span class="hljs-comment">//获取类中的字段</span><br><span class="hljs-type">Filed</span> <span class="hljs-variable">nameField</span> <span class="hljs-operator">=</span> cls.getField(<span class="hljs-string">&quot;age&quot;</span>)<br>nameField.get(o)<br><span class="hljs-comment">//获取类中的构造器</span><br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor</span> <span class="hljs-operator">=</span> cls.getConstructor() <br><span class="hljs-type">Constructor</span> <span class="hljs-variable">constructor2</span> <span class="hljs-operator">=</span> cls.getConstructor(String.class) <br><br>反射的优点和缺点<br>优点：可以动态的创建和使用对象<br>缺点：反射基本是解释执行，对执行速度有影响，可以使用需要获取的对象.setAccessible（<span class="hljs-literal">true</span>）取消访问检查提高访问效率<br><br>Class类<br>Class类对象不是<span class="hljs-keyword">new</span>出来的（<span class="hljs-type">A</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">A</span>（）），而是由系统创建的<br>对于某个类的class对象，在内存中只有一份，因为类只加载一次（老韩演示失败）<br>每个类的实例都会记得自己是由哪个class类对象创建的<br>通过class对象可以完整的得到一个类的完整结构<br>Class类对象是存放在堆的<br>类的字节码二进制数据是放在方法区的<br><br>    <br></code></pre></td></tr></table></figure>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">class</span>类常用方法<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308160614934.png" srcset="/img/loading.gif" lazyload
alt="image-20230308160614934" />
<figcaption aria-hidden="true">image-20230308160614934</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308160730014.png" srcset="/img/loading.gif" lazyload
alt="image-20230308160730014" />
<figcaption aria-hidden="true">image-20230308160730014</figcaption>
</figure>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">获取<span class="hljs-keyword">class</span>类对象的不同方法<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308161037503.png" srcset="/img/loading.gif" lazyload
alt="image-20230308161037503" />
<figcaption aria-hidden="true">image-20230308161037503</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308161147129.png" srcset="/img/loading.gif" lazyload
alt="image-20230308161147129" />
<figcaption aria-hidden="true">image-20230308161147129</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308161257802.png" srcset="/img/loading.gif" lazyload
alt="image-20230308161257802" />
<figcaption aria-hidden="true">image-20230308161257802</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308161918707.png" srcset="/img/loading.gif" lazyload
alt="image-20230308161918707" />
<figcaption aria-hidden="true">image-20230308161918707</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308162028584.png" srcset="/img/loading.gif" lazyload
alt="image-20230308162028584" />
<figcaption aria-hidden="true">image-20230308162028584</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308162121741.png" srcset="/img/loading.gif" lazyload
alt="image-20230308162121741" />
<figcaption aria-hidden="true">image-20230308162121741</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308162253838.png" srcset="/img/loading.gif" lazyload
alt="image-20230308162253838" />
<figcaption aria-hidden="true">image-20230308162253838</figcaption>
</figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">类加载<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308162800356.png" srcset="/img/loading.gif" lazyload
alt="image-20230308162800356" />
<figcaption aria-hidden="true">image-20230308162800356</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308162819032.png" srcset="/img/loading.gif" lazyload
alt="image-20230308162819032" />
<figcaption aria-hidden="true">image-20230308162819032</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308163155057.png" srcset="/img/loading.gif" lazyload
alt="image-20230308163155057" />
<figcaption aria-hidden="true">image-20230308163155057</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308163620862.png" srcset="/img/loading.gif" lazyload
alt="image-20230308163620862" />
<figcaption aria-hidden="true">image-20230308163620862</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308163811640.png" srcset="/img/loading.gif" lazyload
alt="image-20230308163811640" />
<figcaption aria-hidden="true">image-20230308163811640</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308164054801.png" srcset="/img/loading.gif" lazyload
alt="image-20230308164054801" />
<figcaption aria-hidden="true">image-20230308164054801</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308164248602.png" srcset="/img/loading.gif" lazyload
alt="image-20230308164248602" />
<figcaption aria-hidden="true">image-20230308164248602</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308164926219.png" srcset="/img/loading.gif" lazyload
alt="image-20230308164926219" />
<figcaption aria-hidden="true">image-20230308164926219</figcaption>
</figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通过反射获取类的结构信息<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308165525421.png" srcset="/img/loading.gif" lazyload
alt="image-20230308165525421" />
<figcaption aria-hidden="true">image-20230308165525421</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308165726085.png" srcset="/img/loading.gif" lazyload
alt="image-20230308165726085" />
<figcaption aria-hidden="true">image-20230308165726085</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308165903537.png" srcset="/img/loading.gif" lazyload
alt="image-20230308165903537" />
<figcaption aria-hidden="true">image-20230308165903537</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308170301832.png" srcset="/img/loading.gif" lazyload
alt="image-20230308170301832" />
<figcaption aria-hidden="true">image-20230308170301832</figcaption>
</figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通过反射创建对象<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308170544818.png" srcset="/img/loading.gif" lazyload
alt="image-20230308170544818" />
<figcaption aria-hidden="true">image-20230308170544818</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308171004686.png" srcset="/img/loading.gif" lazyload
alt="image-20230308171004686" />
<figcaption aria-hidden="true">image-20230308171004686</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308171032935.png" srcset="/img/loading.gif" lazyload
alt="image-20230308171032935" />
<figcaption aria-hidden="true">image-20230308171032935</figcaption>
</figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通过反射访问类中的成员属性<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308171242896.png" srcset="/img/loading.gif" lazyload
alt="image-20230308171242896" />
<figcaption aria-hidden="true">image-20230308171242896</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308171528597.png" srcset="/img/loading.gif" lazyload
alt="image-20230308171528597" />
<figcaption aria-hidden="true">image-20230308171528597</figcaption>
</figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">通过反射访问类中的成员方法<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308171749624.png" srcset="/img/loading.gif" lazyload
alt="image-20230308171749624" />
<figcaption aria-hidden="true">image-20230308171749624</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308171904364.png" srcset="/img/loading.gif" lazyload
alt="image-20230308171904364" />
<figcaption aria-hidden="true">image-20230308171904364</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308172021707.png" srcset="/img/loading.gif" lazyload
alt="image-20230308172021707" />
<figcaption aria-hidden="true">image-20230308172021707</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230308172100437.png" srcset="/img/loading.gif" lazyload
alt="image-20230308172100437" />
<figcaption aria-hidden="true">image-20230308172100437</figcaption>
</figure>
<h3 id="正则表达式">正则表达式</h3>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">处理文本的工具<br>用某种模式去匹配字符串的一个公式<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310131809083.png" srcset="/img/loading.gif" lazyload
alt="image-20230310131809083" />
<figcaption aria-hidden="true">image-20230310131809083</figcaption>
</figure>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">group（<span class="hljs-built_in">n</span>）代表匹配到的pattern中的第<span class="hljs-built_in">n</span>个子模式<br></code></pre></td></tr></table></figure>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ruby">元字符，匹配的模板。例如\\d代表一位数字<br>元字符分为限定符，选择匹配符，分组组合和反向引用符，特殊字符，字符匹配符，定位符<br>java中的两个\\代表其他语言中的一个转义字符\，常见的有.*+()<span class="hljs-variable">$/</span>\<span class="hljs-string">?[</span>]^&#123;&#125;<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310133924829.png" srcset="/img/loading.gif" lazyload
alt="image-20230310133924829" />
<figcaption aria-hidden="true">image-20230310133924829</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310134000533.png" srcset="/img/loading.gif" lazyload
alt="image-20230310134000533" />
<figcaption aria-hidden="true">image-20230310134000533</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310134722434.png" srcset="/img/loading.gif" lazyload
alt="image-20230310134722434" />
<figcaption aria-hidden="true">image-20230310134722434</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310134452302.png" srcset="/img/loading.gif" lazyload
alt="image-20230310134452302" />
<figcaption aria-hidden="true">image-20230310134452302</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310135016771.png" srcset="/img/loading.gif" lazyload
alt="image-20230310135016771" />
<figcaption aria-hidden="true">image-20230310135016771</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310135054751.png" srcset="/img/loading.gif" lazyload
alt="image-20230310135054751" />
<figcaption aria-hidden="true">image-20230310135054751</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310135328004.png" srcset="/img/loading.gif" lazyload
alt="image-20230310135328004" />
<figcaption aria-hidden="true">image-20230310135328004</figcaption>
</figure>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">java默认是贪婪匹配，例如<span class="hljs-string">&quot;a&#123;3,4&#125;&quot;</span>会优先匹配四个<br></code></pre></td></tr></table></figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310140455097.png" srcset="/img/loading.gif" lazyload
alt="image-20230310140455097" />
<figcaption aria-hidden="true">image-20230310140455097</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310140823243.png" srcset="/img/loading.gif" lazyload
alt="image-20230310140823243" />
<figcaption aria-hidden="true">image-20230310140823243</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310141113137.png" srcset="/img/loading.gif" lazyload
alt="image-20230310141113137" />
<figcaption aria-hidden="true">image-20230310141113137</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310141048955.png" srcset="/img/loading.gif" lazyload
alt="image-20230310141048955" />
<figcaption aria-hidden="true">image-20230310141048955</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310141549480.png" srcset="/img/loading.gif" lazyload
alt="image-20230310141549480" />
<figcaption aria-hidden="true">image-20230310141549480</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310144335070.png" srcset="/img/loading.gif" lazyload
alt="image-20230310144335070" />
<figcaption aria-hidden="true">image-20230310144335070</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310145637138.png" srcset="/img/loading.gif" lazyload
alt="image-20230310145637138" />
<figcaption aria-hidden="true">image-20230310145637138</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310145747141.png" srcset="/img/loading.gif" lazyload
alt="image-20230310145747141" />
<figcaption aria-hidden="true">image-20230310145747141</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310150027423.png" srcset="/img/loading.gif" lazyload
alt="image-20230310150027423" />
<figcaption aria-hidden="true">image-20230310150027423</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310150225585.png" srcset="/img/loading.gif" lazyload
alt="image-20230310150225585" />
<figcaption aria-hidden="true">image-20230310150225585</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310150316299.png" srcset="/img/loading.gif" lazyload
alt="image-20230310150316299" />
<figcaption aria-hidden="true">image-20230310150316299</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310150345632.png" srcset="/img/loading.gif" lazyload
alt="image-20230310150345632" />
<figcaption aria-hidden="true">image-20230310150345632</figcaption>
</figure>
<figure>
<img
src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/image-20230310150416327.png" srcset="/img/loading.gif" lazyload
alt="image-20230310150416327" />
<figcaption aria-hidden="true">image-20230310150416327</figcaption>
</figure>
<h3 id="java8新特性">java8新特性</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">Lamabda表达式<br>lambda是作为接口的实例。例如某个接口只有一个抽象方法，那就没有必要知道方法的名字了<br> -&gt; 右边就相当于重写的抽象方法的方法体，左边就是抽象方法的形参列表<br> lambda表达式的本质：作为函数式接口（只声明了一个抽象方法，该方法就叫函数式接口）的实例<br> <br>    <br> 函数式接口：<br> 函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。<br> <span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">GreetingService</span> <br>&#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">sayMessage</span><span class="hljs-params">(String message)</span>;<br>&#125;<br>使用Lambda表达式来表示该接口的一个实现<br><span class="hljs-type">GreetingService</span> <span class="hljs-variable">greetService1</span> <span class="hljs-operator">=</span> message -&gt; System.out.println(<span class="hljs-string">&quot;Hello &quot;</span> + message);<br>传统的情况再调用函数式接口时需要传入一个匿名内部类并且重写该函数式接口的方法，现在只需要使用lambda表达式即可<br>    <br><br></code></pre></td></tr></table></figure>
<h2 id="坑">坑</h2>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs abnf">jvm 内存管理：堆，栈，方法区，值拷贝，值传递，常量池<br>		java中的栈一般存放基本数据类型（局部变量）；堆存放对象，数组等；方法区：常量池【常量，字符串】，类加载信息<br>java创建对象基本流程：<br>		首先加载类信息（方法区，只加载一次），其次在堆中分配空间并进行默认初始化，然后进行显示的初始化，最后进行构造器的初始化，把对象在堆中的地址返回给对象的引用（对象名）<br>java方法调用内存简单分析： <br>		首先加载类信息，其次在堆中分配空间并进行默认初始化，然后返回对象的引用（把地址赋值给对象名），调用方法时，会单独为方法在栈中创建一个独立的空间，在其中完成计算后，return会返回到调用方法的主方法中，将值传递过去。<br><br>一个对象在jvm中的存在形式<br><br>在使用extends关键字时，需要注意到类名在前边，实例化时别把继承的父类实例化，然后调用不存在的方法<br><br>在静态主方法中，没有办法直接调用一个类的方法，需要实例化，或者将静态方法转化为非静态方法<br><br>float a <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>f <span class="hljs-operator">=</span><span class="hljs-operator">=</span> int b <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ；  float a<span class="hljs-operator">=</span><span class="hljs-number">1.1</span>f ！<span class="hljs-operator">=</span>int b <span class="hljs-operator">=</span> <span class="hljs-number">1</span>  ；float a <span class="hljs-operator">=</span> <span class="hljs-number">1.1</span>f  ，（int）a <span class="hljs-operator">=</span><span class="hljs-operator">=</span> b  ； char a <span class="hljs-operator">=</span><span class="hljs-number">12</span>，a <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-number">12</span><br><br>实例化一个对象的过程<br>	首先进行类的加载<br>		加载子类之前首先要加载父类<br>		运行完父类的静态代码块和静态变量初始化<br>		然后运行子类的静态代码块和静态变量初始化<br>	接下来开始对象的创建<br>		首先进入子类的构造器中<br>		通过super进入到父类对应的构造器<br>		将父类的普通代码块和普通变量进行初始化<br>		将子类的普通代码块和普通变量进行初始化<br>		结束<br>三元运算符会进行自动类型转换<br><br>每调用一个方法，都会在栈中分配一块空间，执行完后销毁，<br><br>.<span class="hljs-number">2</span>f会进行四舍五入<br><br>某个成员被transient修饰时不会被序列化<br><br>CRUD增删改查<br><br>哈希值不等同于hashcode（参加集合类）<br><br>别拿BufferReader ，writer操作二进制文件<br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/">#笔记</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Avaj!</div>
      <div>http://shuaizhang1998.github.io/2023/07/14/JAVA鱼皮路线/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zs</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月14日</div>
        </div>
      
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/14/java%20web/" title="Web笔记">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Web笔记</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/13/ubuntu18.04-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/" title="ubuntu18.04 搭建图床">
                        <span class="hidden-mobile">ubuntu18.04 搭建图床</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
