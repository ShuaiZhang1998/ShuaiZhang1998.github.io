

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Zs">
  <meta name="keywords" content="">
  
    <meta name="description" content="https:&#x2F;&#x2F;www.coursera.org&#x2F;specializations&#x2F;c-programming Struct 实际上在栈上创建结构体有两种写法  struct mystruct struct_name; mystruct struct;  结构体的定义则有四种风格  very simple  12345&#x2F;&#x2F; do not forget ;struct mystruct&amp;#123;">
<meta property="og:type" content="article">
<meta property="og:title" content="c&#x2F;c++">
<meta property="og:url" content="http://shuaizhang1998.github.io/2023/09/30/Introductory%20C%20Programming%20Specialization/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="https:&#x2F;&#x2F;www.coursera.org&#x2F;specializations&#x2F;c-programming Struct 实际上在栈上创建结构体有两种写法  struct mystruct struct_name; mystruct struct;  结构体的定义则有四种风格  very simple  12345&#x2F;&#x2F; do not forget ;struct mystruct&amp;#123;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322796.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319160.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319161.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322416.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322640.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319164.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319165.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319166.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322726.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319168.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322356.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322400.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322972.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322040.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319173.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322664.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322787.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322939.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322311.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322623.png">
<meta property="og:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319180.png">
<meta property="article:published_time" content="2023-09-29T17:46:18.215Z">
<meta property="article:modified_time" content="2023-10-24T05:23:33.124Z">
<meta property="article:author" content="Zs">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322796.png">
  
  
  
  <title>c/c++ - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"shuaizhang1998.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="c/c++"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-09-30 01:46" pubdate>
          2023年9月30日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          42k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          349 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">c/c++</h1>
            
            
              <div class="markdown-body">
                
                <p><a target="_blank" rel="noopener" href="https://www.coursera.org/specializations/c-programming">https://www.coursera.org/specializations/c-programming</a></p>
<h1 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h1><p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322796.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>实际上在栈上创建结构体有两种写法</p>
<ul>
<li><del>struct mystruct struct_name;</del></li>
<li>mystruct struct;</li>
</ul>
<p>结构体的定义则有四种风格</p>
<ul>
<li>very simple</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// do not forget ;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span>&#123;</span><br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> width;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ul>
<li><del>seems to normal</del></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span>&#123;</span><br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> width;<br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span> <span class="hljs-title">mystruct_</span>;</span><br><span class="hljs-comment">//usage</span><br>mystruct_ lily;<br>lily.legth = <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><del>very confused</del></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mystruct</span>&#123;</span><br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> width;<br>&#125;mystruct_;<br><span class="hljs-comment">//usage</span><br>mystruct_ lily;<br></code></pre></td></tr></table></figure>

<ul>
<li>yeah</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>&#123;</span><br>    <span class="hljs-type">int</span> length;<br>    <span class="hljs-type">int</span> width;<br>&#125;mystruct_;<br><span class="hljs-comment">//usage</span><br>mystruct_ lily;<br></code></pre></td></tr></table></figure>

<h1 id="enum"><a href="#enum" class="headerlink" title="enum"></a>enum</h1><ul>
<li>定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span>&#123;</span><br>    A,<br>    B,<br>    C<br>&#125;myenum;<br></code></pre></td></tr></table></figure>

<p>枚举类型是可以比较大小的，按照定义顺序从0至1，因此也可以通过数字来访问</p>
<ul>
<li>实例</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">myEnum_</span>&#123;</span><br>    A,<br>    B,<br>    C<br>&#125;myEnum;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    myEnum myEnum1 = (myEnum)<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">switch</span> (myEnum1) &#123;<br>        <span class="hljs-keyword">case</span> A:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> B:<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Macros"><a href="#Macros" class="headerlink" title="Macros"></a>Macros</h1><p>You must very carefully when you are using Macros</p>
<ul>
<li>优先级问题</li>
</ul>
<p>假如你定义了一个如下的宏</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> mul(x,y) x*y;</span><br></code></pre></td></tr></table></figure>

<p>第一眼看上去似乎没有什么问题，但假如参数为（2+3，3+2），则结果为 2+3*3+2；宏只会做最简单的<strong>文本替换，</strong>不规范的使用可能会带来很多问题；</p>
<p>上边的问题可以这样解决，这称之为宏的优先级问题；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> mul(x,y) (x)*(y);</span><br></code></pre></td></tr></table></figure>


<h1 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h1><p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319160.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>GCC编译文件分为四个步骤</p>
<ul>
<li>预处理</li>
</ul>
<p>这部分主要会进行宏替换，宏替换仅仅只是文本替换；此外还会执行头文件包含操作；此外会移除掉注释；这一步会生成一个filename.i的中间文件；<br>假设主文件为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 输出</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>我们包含了stdio.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _STDIO_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _STDIO_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _STDIO_H_ */</span></span><br></code></pre></td></tr></table></figure>

<p>那么第一步预处理后的文件为</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"># <span class="hljs-number">1</span> <span class="hljs-string">&quot;main.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;built-in&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;&lt;command-line&gt;&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;main.c&quot;</span><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;stdio.h&quot;</span> <span class="hljs-number">1</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _STDIO_H_</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _STDIO_H_</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stddef.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _STDIO_H_ */</span></span><br><br># <span class="hljs-number">2</span> <span class="hljs-string">&quot;main.c&quot;</span> <span class="hljs-number">2</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello, World!\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>编译阶段</li>
</ul>
<p>此阶段会把预处理的文件根据对应的平台编译为汇编代码，生成.s中间文件</p>
<ul>
<li>汇编阶段</li>
</ul>
<p>此阶段会将编译阶段生成的汇编代码翻译为机器码指令，一般为.o或者.obj的二进制文件</p>
<ul>
<li>连接阶段</li>
</ul>
<p>通常来说，一个c语言项目会包含很多源代码，也就对应了许多了.o或者是.obj文件。连接阶段把编译后的目标文件链接在一起形成可执行文件；这个阶段主要解决代码中的符号引用问题（将相应的函数和变量定义联系起来），最终的可执行文件往往没有拓展名。</p>
<p>所以编译实际上是一个合并的过程，需要注意的是，现代编译器对编译做了大量的优化，在一个大型的c语言项目中，修改某些源文件，并不会导致所有文件全部重新处理一遍。</p>
<h1 id="Make"><a href="#Make" class="headerlink" title="Make"></a>Make</h1><p>实际的c项目会包含很多的源文件，如果在每次修改源文件后，将整个工程重修编译一遍会消耗很多的时间；幸运的是如果我们保留了之前的.o文件，我们可以通过使用gcc -c指定需要被重新编译的文件，然后重新运行连接器；但这意味着手动去完成每一个需要被重新编译的文件；Make允许我们通过一个很简单的方式来重新编译对象；</p>
<p>以下是一个简单的例子，源文件仅有main.c，helper.h，helper.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;helper.h&quot;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>	<span class="hljs-comment">//printf(&quot;asdadasd    &quot;);</span><br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,<span class="hljs-number">1</span>);<br>	slove(<span class="hljs-number">2</span>);<br>	<span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> HELPER_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> HELPER_H</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">slove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;helper.h&quot;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">slove</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, a);<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">main: main.o helper.o<br>        gcc -o main main.o helper.o<br>main.o: main.c helper.h<br>        gcc -<span class="hljs-built_in">std</span>=gnu99 -pedantic -Wall -c main.c<br>helper.o: helper.c helper.h<br>        gcc -<span class="hljs-built_in">std</span>=gnu99 -pedantic -Wall -c helper.c<br></code></pre></td></tr></table></figure>

<p>这个 <code>Makefile</code> 描述了如何从源文件构建一个名为 <code>main</code> 的可执行程序。其中有几个目标、依赖项和命令。以下是详细描述：</p>
<ol>
<li><strong>目标和依赖项</strong>: <ul>
<li><code>main</code>: 这是主目标，意味着当你只输入 <code>make</code> 而不指定目标时，<code>make</code> 将尝试构建这个目标。这个目标取决于 <code>main.o</code> 和 <code>helper.o</code>，这意味着在构建 <code>main</code> 之前，它需要 <code>main.o</code> 和 <code>helper.o</code> 这两个对象文件。 </li>
<li><code>main.o</code>: 这是一个中间目标，它表示从 <code>main.c</code> 源文件编译出的对象文件。它的依赖项是 <code>main.c</code> 和 <code>helper.h</code>，所以当这两个文件中的任何一个更改时，<code>main.o</code> 将被重新编译。 </li>
<li><code>helper.o</code>: 类似地，这也是一个中间目标，表示从 <code>helper.c</code> 源文件编译出的对象文件。它依赖于 <code>helper.c</code> 和 <code>helper.h</code> 文件。</li>
</ul>
</li>
<li><strong>命令</strong>: <ul>
<li><code>gcc -o main main.o helper.o</code>: 这是链接命令，它链接 <code>main.o</code> 和 <code>helper.o</code> 对象文件来创建 <code>main</code> 可执行程序。 </li>
<li><code>gcc -std=gnu99 -pedantic -Wall -c main.c</code>: 这是编译命令，用于编译 <code>main.c</code> 并生成 <code>main.o</code> 对象文件。其中： <ul>
<li><code>-std=gnu99</code>: 使用C99标准以GNU的扩展进行编译。</li>
<li><code>-pedantic</code>: 强制遵循C标准，并对不遵循标准的代码发出警告。</li>
<li><code>-Wall</code>: 启用大多数编译器警告。</li>
<li><code>-c</code>: 仅编译，不链接。</li>
</ul>
</li>
<li><code>gcc -std=gnu99 -pedantic -Wall -c helper.c</code>: 类似地，这是编译命令，用于编译 <code>helper.c</code> 并生成 <code>helper.o</code> 对象文件。它使用了与上面相同的编译标志。</li>
</ul>
</li>
<li><strong>关系</strong>: <ul>
<li>在你运行 <code>make</code> 命令时，<code>make</code> 首先查看 <code>main</code> 目标及其依赖项。它会检查 <code>main.o</code> 和 <code>helper.o</code> 的最后修改时间与它们各自的依赖项进行比较。如果依赖项的修改时间比目标文件更新，或者目标文件不存在，<code>make</code> 就会执行相应的命令。 </li>
<li>举个例子，如果你修改了 <code>main.c</code>，当你下一次运行 <code>make</code> 时，<code>main.o</code> 和 <code>main</code> 将被重新构建，但 <code>helper.o</code> 不会，因为 <code>helper.c</code> 没有更改。</li>
</ul>
</li>
</ol>
<p>这样，<code>Makefile</code> 为你提供了一种高效的方式，只重新编译和链接那些自上次构建以来已更改的源文件，从而加速整个构建过程。</p>
<h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h2 id="Black-Box-Testing"><a href="#Black-Box-Testing" class="headerlink" title="Black Box Testing"></a>Black Box Testing</h2><ul>
<li>考虑边界条件</li>
<li>永远不要期望输入会如同你的预期</li>
<li>测试子集要覆盖尽可能多的情况</li>
</ul>
<h2 id="White-Box-Testing"><a href="#White-Box-Testing" class="headerlink" title="White Box Testing"></a>White Box Testing</h2><ul>
<li>覆盖所有路径的测试</li>
<li>走到终点的测试</li>
</ul>
<h2 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h2><ul>
<li>复杂的分支打断言测试</li>
<li>#include &lt;assert.h&gt;</li>
</ul>
<h2 id="Valgrind"><a href="#Valgrind" class="headerlink" title="Valgrind"></a>Valgrind</h2><ul>
<li>MAC不支持，用Linux打</li>
<li>valgrind .&#x2F;task</li>
</ul>
<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><ul>
<li>一个强大的开源调试软件（c\c++)</li>
<li>多平台支持</li>
<li>只调试可执行文件</li>
</ul>
<p><strong>USAGE</strong></p>
<ul>
<li>使用之前首先在Makefile中的gcc命令中添加-g将gdb嵌入到程序</li>
<li>然后通过gdb.&#x2F;main</li>
<li>打断点  break main.c:5 </li>
<li>gdb传参数 set args arg1 arg2 agr3</li>
<li>开始调试   run</li>
<li>显示当前位置附近的源码  list</li>
<li>执行一步但是不进入函数调用 next</li>
<li>执行一步并且进入函数调用 step</li>
<li>打印变量的值  print variable_name</li>
<li>到下一个断点 continue</li>
<li>查看局部变量的值 info local</li>
<li>显示堆栈区 bt</li>
<li>在循环条件中打断点 break file.c:loop_start_number   condition 1 i &#x3D;&#x3D; 1000 or (gdb) break your_file.c:line_number if i &#x3D;&#x3D; 1000</li>
<li>重定向<ul>
<li><code>./task &lt; input.txt</code></li>
<li><code>run &lt; input.txt &gt; output.txt</code>   ( gdb 中）</li>
</ul>
</li>
</ul>
<h1 id="Pointer"><a href="#Pointer" class="headerlink" title="Pointer"></a>Pointer</h1><p><strong>左值和右值 核心区别在于 是否有持久的地址</strong></p>
<ul>
<li><strong>左值实际上标识了一块地址，因此左值可以出现在赋值操作符的左边或者右边</strong></li>
<li><strong>右值则是临时的，无法标识内存位置的表达式，它往往是中间计算结果；</strong></li>
</ul>
<p>一些右值的例子：</p>
<ol>
<li><strong>字面常量</strong>：整数、浮点数、字符等字面常量通常是右值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> x = <span class="hljs-number">42</span>;     <span class="hljs-comment">// 42 是右值</span><br><span class="hljs-type">double</span> pi = <span class="hljs-number">3.14</span>; <span class="hljs-comment">// 3.14 是右值</span><br><span class="hljs-type">char</span> ch = <span class="hljs-string">&#x27;A&#x27;</span>;   <span class="hljs-comment">// &#x27;A&#x27; 是右值</span><br></code></pre></td></tr></table></figure>


<ol start="2">
<li><strong>临时对象</strong>：在表达式中创建的临时对象通常是右值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::string result = std::<span class="hljs-built_in">string</span>(<span class="hljs-string">&quot;Hello&quot;</span>) + <span class="hljs-string">&quot; World&quot;</span>; <span class="hljs-comment">// 字符串拼接的结果是右值</span><br></code></pre></td></tr></table></figure>


<ol start="3">
<li><strong>函数返回值</strong>：函数返回的临时值是右值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x; <span class="hljs-comment">// 返回值是右值</span><br>&#125;<br></code></pre></td></tr></table></figure>


<ol start="4">
<li><strong>表达式的结果</strong>：在表达式中计算的中间结果通常是右值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> sum = <span class="hljs-number">5</span> + <span class="hljs-number">3</span>; <span class="hljs-comment">// 5 + 3 的结果是右值</span><br></code></pre></td></tr></table></figure>


<ol start="5">
<li><strong>移动构造函数的参数</strong>：在使用移动语义时，传递给移动构造函数的对象通常是右值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; source = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;;<br>std::vector&lt;<span class="hljs-type">int</span>&gt; dest = std::<span class="hljs-built_in">move</span>(source); <span class="hljs-comment">// std::move(source) 返回右值</span><br></code></pre></td></tr></table></figure>


<ol start="6">
<li><strong>Lambda 表达式</strong>：Lambda 表达式可以是右值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">auto</span> lambda = [](<span class="hljs-type">int</span> x) &#123; <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span>; &#125;; <span class="hljs-comment">// lambda 表达式是右值</span><br></code></pre></td></tr></table></figure>


<ol start="7">
<li><strong>类型转换表达式</strong>：类型转换表达式通常生成右值。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">double</span> x = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">double</span>&gt;(<span class="hljs-number">5</span>); <span class="hljs-comment">// static_cast 的结果是右值</span><br></code></pre></td></tr></table></figure>

<h2 id="指针的内存布局"><a href="#指针的内存布局" class="headerlink" title="指针的内存布局"></a>指针的内存布局</h2><p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319161.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>可以看到int类型占据了4字节，也就是32个比特位</li>
<li>我们注意到x的高位为零，从低位开始使用</li>
</ul>
<p>首先，我们规定内存是从低到高排列的</p>
<p><strong>大端字节序</strong><br>**低位字节位（右）存储于较高的内存地址       **<br><strong>小端字节序（存储时从低地址向高地址存储）</strong><br>**低位字节位（右）存储于较低的内存地址     **</p>
<p>绕的丫批，所以小端字节序常用，因为低字节位（右边的字节位）从较低的内存地址开始存储。</p>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322416.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>栈在高地址，堆在低地址</li>
</ul>
<p>c语言内存布局</p>
<ul>
<li>代码区</li>
<li>静态区</li>
<li>堆区</li>
<li>栈区</li>
<li>每个进程都以为自己独占一块空间，其实并不是，这只是逻辑地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322640.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>栈只存数据，代码区只存代码</li>
<li>栈的起始地址是高于堆的启始地址的</li>
<li>栈向下增长，高位代表了最后放入的数据；而这在代码中，反应为第一行定义的变量</li>
<li>代码区向上增长，用户编写的代码从低地址开始向高地址执行</li>
<li>只要是执行顺序，一定是从低到高，所以被调用函数的返回地址会高于被调用函数存储变量的地址</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319164.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>虽然swap函数在书写过程中在主函数之前，但swap函数中的变量实际会存储在低地址，而不是高于主函数在栈中存储的变量</li>
<li>定义多个局部变量，存储规则依旧不变</li>
<li>NULL指向逻辑无效地址</li>
</ul>
<h2 id="C语言内存布局"><a href="#C语言内存布局" class="headerlink" title="C语言内存布局"></a>C语言内存布局</h2><p>首先我们讨论的内存布局是建立在虚拟内存基础之上的，每一个c进程都认为自己拥有一块独立的存储空间，而实际的物理存储空间由操作系统来决定。</p>
<p>32位的机器每次可以寻址一字节，单次最大寻址长度最大为4字节，而64位机器每次寻址一字节，单次最大寻址长度则为8字节。</p>
<p>从低地址到高地址，内存布局依次为：</p>
<ul>
<li>代码区（这部分以只读的形式存取单步操作，具体每一步到底占用了多少字节与指令集有关（但通常来说，在编译器不进行优化的情况下，++i是会优于i++的，因为i++实际上存储了两步操作 i+1 以及 i &#x3D; i + 1）</li>
</ul>
<p>所有的操作无论是主函数还是其他函数（包括静态方法），全部都存储在代码区，按照从低到高的顺序或跳跃依次执行（跳跃的原因是存在函数调用或者流程控制语句等，此外这里需要明确一点，同一个函数的相邻的操作在内存布局中是相邻的，涉及到函数调用则有可能会跳转到代码区更高的地址）</p>
<ul>
<li>数据区</li>
</ul>
<p>此处存储了静态变量和全局变量，使用const修饰的变量也存储在这里（不一定，常量区），同时数据区又分为已经初始化以及没有初始化的部分；</p>
<ul>
<li>堆区</li>
</ul>
<p>此部分存储了使用malloc分配的变量，需要手动进行管理。另外变量所占据的长度也是不一定的，特别是结构体的大小收到内存对齐机制的影响（不对齐可能需要额外的CPU时钟来访问一个变量，甚至有可能就没法正常访问）；堆区默认是向上增长的（可以向下）；</p>
<ul>
<li>栈区</li>
</ul>
<p>这个部分存储了临时变量，是一个先进先出的结构。因为空间可预测性和时间可预测性，使得栈区能够充分的利用到高速缓存，因此访问速度一般会比堆区快；栈区默认是向下增长的（可以向上），因此对于被调用函数来说，栈顶往往存储着返回调用函数的地址，而这个地址之上，从高到低则依次存储着代码定义的变量。</p>
<h2 id="void"><a href="#void" class="headerlink" title="void *"></a>void *</h2><p>这个牛逼的东西可以指向任何数据类型，除了函数以外；</p>
<h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319165.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="别名问题"><a href="#别名问题" class="headerlink" title="别名问题"></a>别名问题</h2><ul>
<li>多个指针指向同一快内存地址时</li>
<li>后续的操作可能带来一些问题</li>
</ul>
<p>首先我们给出一段常见的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> f = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> x = (<span class="hljs-type">int</span>) f;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, x);<br></code></pre></td></tr></table></figure>

<ul>
<li>将f强制转换为一个整形数字</li>
<li>赋值给x</li>
</ul>
<p>接下来是另一段代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> f = <span class="hljs-number">3.14</span>;<br><span class="hljs-type">int</span> * p = (<span class="hljs-type">int</span> *) &amp;f;  <span class="hljs-comment">// generally a bad idea!</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, *p);<br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319166.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><em>3.14 按照 IEE754 的浮点编码表示为：</em><br><em>0100 0000 0100 1000 1111 0101 1100 0011</em></p>
<ul>
<li>_高位0为符号位 _</li>
<li><em>随后的1000 0000为指数位</em></li>
<li><em>剩下的23位是尾数位</em></li>
</ul>
<p>这段代码本质上是通过<strong>解引</strong>打印出了f在IEEE754标准下的表示模式</p>
<ul>
<li>指针不要乱用</li>
<li>不同的数据的存储模式是不同的</li>
<li>指针加一代表向内存中移动一段距离，这段距离由所指向的数据类型来决定<ul>
<li>占用的字节数目不同</li>
<li>模式不同</li>
</ul>
</li>
</ul>
<h2 id="悬挂指针"><a href="#悬挂指针" class="headerlink" title="悬挂指针"></a>悬挂指针</h2><ul>
<li>指某个指向了已经销毁的堆&#x2F;栈区内存的指针</li>
<li>可能会造成数据的覆写或者一些未知的值</li>
<li>永远不要返回一个指向局部变量的指针</li>
<li>释放某块内存后，立即将该指针指向nullptr或null</li>
<li>使用指针之前永远检查是否非空</li>
</ul>
<h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><ul>
<li>c99标准允许我们动态的创建数组</li>
<li>c是不能显示的获取数组的大小的</li>
</ul>
<h1 id="String-in-c"><a href="#String-in-c" class="headerlink" title="String in c"></a>String in c</h1><h2 id="const-string"><a href="#const-string" class="headerlink" title="const string"></a>const string</h2><ul>
<li>使用指针形式创造的字符串是不允许被修改的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322726.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>如果尝试使用str[i] 或者 *(a+1)等方式修改str，则程序崩溃，因为这种方式创建的字符串存储在静态区，而存储在静态区的数据很多情况下我们会进行复用，我们不会希望修改；</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319168.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>所以在创建字符串常量时务必使用const来修饰，这样可以在编译阶段及时发现错误</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;hello&quot;</span>;<br></code></pre></td></tr></table></figure>

<h2 id="Mutable-string"><a href="#Mutable-string" class="headerlink" title="Mutable string"></a>Mutable string</h2><ul>
<li>使用[]来标记我们希望把这个字符串存到堆或者栈而不是静态区</li>
<li>如果显式定义了字符串的大小，确保你的空间够用，如果因为空间问题导致结束标志’\0’没有地方存储会导致越界访问</li>
<li>需要注意内存泄漏问题</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> *a = new <span class="hljs-type">char</span>[<span class="hljs-number">3</span>];<br>    a =<span class="hljs-string">&quot;abc&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这是一个不会报错，但是内存泄漏的例子；<br>首先在堆上分配了3个字节；<br>a指向的是堆上连续的三个字节；<br>然后a又指向了静态区；<br>这导致了之前在堆上分配的内存无法回收；</p>
<h2 id="String-Equality"><a href="#String-Equality" class="headerlink" title="String Equality"></a>String Equality</h2><ul>
<li>&#x3D;&#x3D; 比较的是两个值相不相同</li>
<li>确保使用比较函数</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322356.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="String-copy"><a href="#String-copy" class="headerlink" title="String copy"></a>String copy</h2><ul>
<li>确保用安全的函数进行字符串的拷贝</li>
<li>确保’\0’拷贝进去了</li>
<li><em>strncpy(str1,str2,num(str2)+1)</em></li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322400.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="Array-of-Strings"><a href="#Array-of-Strings" class="headerlink" title="Array of Strings"></a>Array of Strings</h2><ul>
<li>有两种实现方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * words[] = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;likes&quot;</span>, <span class="hljs-string">&quot;sleeping.&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br>	<br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(words)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>    <span class="hljs-type">char</span> words_[<span class="hljs-number">5</span>][<span class="hljs-number">10</span>] = &#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;likes&quot;</span>, <span class="hljs-string">&quot;sleeping.&quot;</span>, <span class="hljs-literal">NULL</span>&#125;;<br><br>    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-keyword">sizeof</span>(words_)&lt;&lt;<span class="hljs-built_in">endl</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第一个占用的内存更小 每一个位置存储的char* 大小为8字节</li>
<li>第二个存储的是实实在在的字符 大小为5*10</li>
</ul>
<h1 id="多维数组的内存布局"><a href="#多维数组的内存布局" class="headerlink" title="多维数组的内存布局"></a>多维数组的内存布局</h1><ul>
<li>double myMatrix[4][3]</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322972.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>逻辑上我们可以认为：</p>
<ul>
<li>首先开辟了四个内存块</li>
<li>每个内存块存储了三个double类型</li>
<li>总消耗内存位4<em>3</em>sizeof(double)</li>
</ul>
<p>实际的内存布局为</p>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322040.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>从低地址向高地址递增</li>
<li>内存是连续的</li>
<li>初始化可以回避第一维，除此之外的任意一维都不行</li>
</ul>
<p>当然也可以存储不定长的数组</p>
<ul>
<li>此时内存不一定连续</li>
<li>double * myMatrix[4] &#x3D; {row0, row1, row2, row3};</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319173.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="多维数组的传参"><a href="#多维数组的传参" class="headerlink" title="多维数组的传参"></a>多维数组的传参</h2><p>首先给出一个错误的例子</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span> ** arr,<span class="hljs-type">int</span> w,<span class="hljs-type">int</span> h)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;w;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;h;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,arr[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;&#125;;<br>    p((<span class="hljs-type">int</span>**)data,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>编译不报错</li>
<li>但会引发段错误 （访问到了无效内存）</li>
</ul>
<p>解析</p>
<ul>
<li>data是一个指针（多维数组的首地址） 指向的第一个元素是一个长度为3的int型数组的第一个元素  记为(int(*)[3])</li>
<li>p函数要求的类型是int **</li>
<li>int <strong>arr &#x3D; (int</strong>)data 在告诉编译器 从data[0][0] 读取int<em>个大小的字节 也就是把data[0][0]和data[0][1]组合在了一起（int</em>指针往往是8字节个大小)</li>
<li>访问到完全未知的内存，有可能会引发段错误</li>
</ul>
<p>更正</p>
<ul>
<li>方法一</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[][<span class="hljs-number">3</span>],<span class="hljs-type">int</span> w,<span class="hljs-type">int</span> h)</span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;w;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;h;j++)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,arr[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;&#125;;<br>    p(data,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span>  <span class="hljs-number">0</span> ;<br>&#125;<br><br><span class="hljs-comment">//其实这里的int arr[][3] 就是 (int(*)[3]) 也就是一个指向了长度为三的int型数组的指针</span><br></code></pre></td></tr></table></figure>

<ul>
<li>方法二</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span> **arr, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; h; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, arr[i][j]);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;&#125;;<br>    <span class="hljs-type">int</span> *pdata[<span class="hljs-number">3</span>] = &#123;data[<span class="hljs-number">0</span>], data[<span class="hljs-number">1</span>], data[<span class="hljs-number">2</span>]&#125;;<br>    p(pdata, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>方法三（最优雅）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">p</span><span class="hljs-params">(<span class="hljs-type">int</span> *arr, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> h)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; w; i++) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; h; j++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, arr[i * h + j]); <span class="hljs-comment">// 手动计算二维索引</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> data[<span class="hljs-number">3</span>][<span class="hljs-number">3</span>] = &#123;&#123;<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;,&#123;<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;,&#123;<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;&#125;;<br>    p(&amp;data[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], <span class="hljs-number">3</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 传入一维数组的首地址</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h1><ul>
<li>函数的名称其实就是函数指针(没有括号的情况下）</li>
<li>函数指针是实现面向对象编程的核心，但是面向对象编程往往封装了这个细节</li>
</ul>
<p>一个简单的例子，实现对不同类型的数组进行排序</p>
<ul>
<li>c中的qsort的最后一个参数就是一个函数指针<ul>
<li>这个指针 int(* compare)(const void *,const void *))</li>
<li>可以指向任意返回为int型，参数个数为两个的任意形参</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compareLong</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span> *p1,<span class="hljs-type">const</span> <span class="hljs-type">void</span> *p2)</span></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">long</span> *v1 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">long</span> *&gt;(p1);<br>    <span class="hljs-type">const</span> <span class="hljs-type">long</span> *v2 = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">long</span> *&gt;(p2);<br>    <br>    <span class="hljs-keyword">if</span> (*v1 &lt; *v2) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">if</span> (*v1 == *v2) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sortLong</span><span class="hljs-params">(<span class="hljs-type">long</span> *array,<span class="hljs-type">size_t</span> n)</span></span>&#123;<br>    <span class="hljs-built_in">qsort</span>(array,n,<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">long</span>),compareLong);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> *arr = <span class="hljs-keyword">new</span> <span class="hljs-type">long</span>[<span class="hljs-number">10</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        arr[i] = <span class="hljs-number">10</span>-i;<br>    &#125;<br>    <span class="hljs-built_in">sortLong</span>(arr,<span class="hljs-number">10</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        cout&lt;&lt;arr[i]&lt;&lt;endl;<br>    &#125;<br>    <span class="hljs-built_in">delete</span>(arr);<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h1 id="Buffer-Overflow-attack"><a href="#Buffer-Overflow-attack" class="headerlink" title="Buffer Overflow attack"></a>Buffer Overflow attack</h1><ul>
<li>never use gets()</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><p>搜索大师表示不需要学这玩意，毕竟是饭碗子，要骗分的<br>但还是看了一看</p>
<ul>
<li>尾部递归</li>
<li>头部递归</li>
<li>函数式编程（强烈推荐）？？为啥</li>
<li>相互递归</li>
</ul>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>c语言允许我们直接操作操作系统，同时也支通过标准库来与操作系统进行交互</p>
<ul>
<li>系统调用可能会出现各种各样的错误，有可能是网络错误或者是读取了不存在的文件</li>
<li>存在一个头文件来描述这些错误代码，在errorno.h文件中</li>
<li>可以在系统调用来返回这些错误代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> x = someSystemCall();<br><span class="hljs-keyword">if</span> (x != <span class="hljs-number">0</span>) &#123;<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;someSystemCall() failed!\n&quot;</span>);  <span class="hljs-comment">//may change errno</span><br>  perror(<span class="hljs-string">&quot;The error was: &quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h1><ul>
<li>main函数实际上是可以接受参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br></code></pre></td></tr></table></figure>

<ul>
<li>argc代表了字符串数组的长度</li>
<li>argv是一个字符串数组 ，存储了命令</li>
<li>还有第三个不常用的命令行参数 **envp</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322664.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>其中argv[0] 一般是没用的，一般存储的是gcc编译时取得文件名a.out</li>
<li>从第二个参数开始，我们可以动态的指定一些参数 例如.&#x2F;a a b c d</li>
</ul>
<h1 id="动态内存"><a href="#动态内存" class="headerlink" title="动态内存"></a>动态内存</h1><ul>
<li>我们无法将一个栈上的创建的数组返回，因为栈调用结束后这些变量会被销毁掉</li>
<li>通过malloc分配的内存只要不释放会一直存在</li>
</ul>
<h2 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> ** argv)</span> &#123;<br>   <span class="hljs-type">int</span> *p;<br>   p = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>));<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;not in exception&quot;</span>);<br>   <span class="hljs-keyword">return</span> EXIT_SUCCESS;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="free"><a href="#free" class="headerlink" title="free"></a>free</h2><ul>
<li>free只会释放当前指针所指向的的内存块，指针本身在退出作用域以前不会被释放掉</li>
<li>如果在这个内存块中的某些部分指向其他的内存块，则需要优先释放那些内存块</li>
<li>释放完后立即将指针置为NULL或者nullptr，避免多重释放带来的崩溃</li>
<li>不可以释放开辟地址的中间地址</li>
</ul>
<h2 id="realloc"><a href="#realloc" class="headerlink" title="realloc"></a>realloc</h2><ul>
<li>你必须假设重新分配后的空间是一块新的空间</li>
<li>realloc可以增加或者减小空间</li>
</ul>
<h2 id="calloc"><a href="#calloc" class="headerlink" title="calloc"></a>calloc</h2><ul>
<li>类似malloc，除了它会将每一个值初始化为0</li>
</ul>
<h2 id="getline"><a href="#getline" class="headerlink" title="getline"></a>getline</h2><ul>
<li>会自动动态的增大大小基于malloc和relloc</li>
<li>记得释放内存</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322787.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h2 id="堆上计算和栈上计算，哪个快？"><a href="#堆上计算和栈上计算，哪个快？" class="headerlink" title="堆上计算和栈上计算，哪个快？"></a>堆上计算和栈上计算，哪个快？</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdlib&gt;</span></span><br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> SIZE = <span class="hljs-number">5e5</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">random_access</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>        <span class="hljs-type">int</span> random_index = <span class="hljs-built_in">rand</span>() % SIZE;<br>        arr[random_index] += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sequential_access</span><span class="hljs-params">(<span class="hljs-type">int</span> arr[])</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SIZE; i++) &#123;<br>        arr[i] += <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 测量栈的性能</span><br>    <span class="hljs-type">int</span> stack_array[SIZE];<br>    std::<span class="hljs-built_in">fill</span>(stack_array, stack_array + SIZE, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">random_access</span>(stack_array);<br>    <span class="hljs-keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">auto</span> duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Random access on stack: &quot;</span> &lt;&lt; duration &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; std::endl;<br><br>    start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">sequential_access</span>(stack_array);<br>    end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sequential access on stack: &quot;</span> &lt;&lt; duration &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 测量堆的性能</span><br>    <span class="hljs-type">int</span>* heap_array = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[SIZE];<br>    std::<span class="hljs-built_in">fill</span>(heap_array, heap_array + SIZE, <span class="hljs-number">0</span>);<br><br>    start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">random_access</span>(heap_array);<br>    end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Random access on heap: &quot;</span> &lt;&lt; duration &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; std::endl;<br><br>    start = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">sequential_access</span>(heap_array);<br>    end = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    duration = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end - start).<span class="hljs-built_in">count</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Sequential access on heap: &quot;</span> &lt;&lt; duration &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">delete</span>[] heap_array;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Random access on stack: <span class="hljs-number">0</span>ms<br>Sequential access on stack: <span class="hljs-number">0</span>ms<br>Random access on heap: <span class="hljs-number">15</span>ms<br>Sequential access on heap: <span class="hljs-number">0</span>ms<br></code></pre></td></tr></table></figure>

<ul>
<li>顺序访问上，似乎没有太大差别</li>
<li>随机访问上，栈的速度明显比堆快很多</li>
<li>这个计算只是一个很大概的估算，例如编译器优化问题，冷启动问题都会带来一定的偏差。</li>
</ul>
<h1 id="Valgrind-工具"><a href="#Valgrind-工具" class="headerlink" title="Valgrind  工具"></a>Valgrind  工具</h1><ul>
<li>内存泄漏检测</li>
<li>检测那些未被初始化的值</li>
<li>检测那些错误的访问，例如返回一个悬挂指针</li>
<li>和GDB一起使用</li>
<li>与memcheck.h一起嵌入到代码中</li>
<li><a target="_blank" rel="noopener" href="https://valgrind.org/docs/manual/manual.html">https://valgrind.org/docs/manual/manual.html</a></li>
</ul>
<h1 id="大型程序设计"><a href="#大型程序设计" class="headerlink" title="大型程序设计"></a>大型程序设计</h1><h2 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h2><ul>
<li>The seven- item limit<ul>
<li>一段时间内人脑大约只能记住七件事情左右</li>
<li>你编写的代码或许在许多年以后还需要重新阅读</li>
<li>不要试图去记住你的代码，而是记住这段代码或者是函数或者是类完成了什么事</li>
</ul>
</li>
</ul>
<h2 id="分层抽象"><a href="#分层抽象" class="headerlink" title="分层抽象"></a>分层抽象</h2><ul>
<li>自下而上的设计方法<ul>
<li>很容易进行单元测试</li>
<li>但需要确保你可以正确组合功能</li>
<li>适用于探索阶段</li>
</ul>
</li>
<li>自上而下<ul>
<li>调理十分清晰</li>
<li>但测试起来比较困难</li>
</ul>
</li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a target="_blank" rel="noopener" href="http://git-scm.com/book/en/v2">http://git-scm.com/book/en/v2</a></li>
</ul>
<hr>
<h1 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h1><ul>
<li>引用类型变量不占用单独的存储空间</li>
<li>int a ;int &amp; ref &#x3D; a;</li>
</ul>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><ul>
<li>类和结构体的唯一区别就是访问控制</li>
<li>struct的成员是完全公开的</li>
<li>public 修饰的成员向外界公开</li>
<li>protected 仅仅派生类可以访问</li>
<li>private 仅仅本对象可以访问</li>
</ul>
<p>::操作符</p>
<ul>
<li>用来决定访问哪个类的哪个成员</li>
</ul>
<h1 id="构造器和构造初始化列表"><a href="#构造器和构造初始化列表" class="headerlink" title="构造器和构造初始化列表"></a>构造器和构造初始化列表</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Tool::<span class="hljs-built_in">Tool</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y):<span class="hljs-built_in">x</span>(x),<span class="hljs-built_in">y</span>(y) &#123;<br>    <span class="hljs-keyword">this</span>-&gt;x = x;<br>    <span class="hljs-keyword">this</span>-&gt;y = y;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>{}里面是构造器</li>
<li>使用：分隔的后边是初始化列表</li>
<li>构造器内的赋值会在初始化列表以后进行</li>
<li>成员初始化顺序按照成员定义顺序而不是初始化列表顺序</li>
</ul>
<h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><ul>
<li>除非你的代码中有使用动态内存分配的成员否则不用写</li>
<li>如果你的代码涉及到多态，那么你必须要把析构函数定义为虚函数</li>
</ul>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><ul>
<li>一个类只有一个虚表，存在数据区里</li>
<li>所有的对象共享一个虚表</li>
</ul>
<p>首先，要理解多态和虚函数是如何在C++中实现的，我们需要了解虚函数表（通常称为vtable）。每当有一个类定义了或继承了一个虚函数，编译器为该类生成一个虚函数表。这个表是一个函数指针数组，它指向该类为虚函数提供的实现。此外，编译器还会在每个对象的内存布局中添加一个指向其对应的vtable的指针。</p>
<p>假设我们有如下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;&#125;<br>    ~<span class="hljs-built_in">Derived</span>() <span class="hljs-keyword">override</span> &#123;&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在这里，<code>Base</code>有一个vtable，其中包含了<code>foo</code>和析构函数<code>~Base</code>的地址。类似地，<code>Derived</code>也有一个vtable，其中包含了<code>foo</code>（指向<code>Derived</code>中的实现）和析构函数<code>~Derived</code>的地址。</p>
<p>当我们通过基类指针调用虚函数时，实际上进行的操作是：</p>
<ol>
<li>获取对象的vtable指针。</li>
<li>使用该指针找到虚函数在vtable中的地址。</li>
<li>调用该地址指向的函数。</li>
</ol>
<p>现在，考虑到析构的场景。假设我们这样做：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Base* ptr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br><span class="hljs-keyword">delete</span> ptr;<br></code></pre></td></tr></table></figure>

<p>当执行<code>delete ptr</code>时，要调用哪个析构函数取决于<code>Base</code>的析构函数是否是虚函数。</p>
<ul>
<li>如果<code>~Base()</code>是虚的，<code>delete</code>操作会查找<code>ptr</code>对象的vtable，然后调用其中的析构函数地址（这实际上会是<code>~Derived()</code>，然后再是<code>~Base()</code>）。 </li>
<li>如果<code>~Base()</code>不是虚的，<code>delete</code>操作直接调用<code>~Base()</code>，而不会查找vtable。这意味着<code>~Derived()</code>永远不会被调用，可能导致资源泄露或其他问题。</li>
</ul>
<p>从内存的角度看，没有正确释放的资源可能占用大量的内存，或者导致当其他代码试图访问这些资源时产生未定义的行为。</p>
<p>所以，当我们期望通过基类指针来管理派生类对象的生命周期时，基类的析构函数必须是虚函数，以确保vtable机制能够正确调用派生类的析构函数，从而正确释放所有资源。</p>
<h2 id="free和delete"><a href="#free和delete" class="headerlink" title="free和delete"></a>free和delete</h2><ul>
<li>free是c语言中的<strong>操作符</strong><ul>
<li><strong>释放malloc或者realloc分配的内存</strong></li>
</ul>
</li>
<li>delete是c++中的<strong>操作符</strong><ul>
<li>释放通过new分配的内存</li>
<li>会执行析构函数</li>
</ul>
</li>
</ul>
<h1 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h1><ul>
<li>使用inline修饰.c文件中的函数以及.h头文件的函数</li>
<li>降低函数调用的成本 直接展开</li>
<li>尽量别用</li>
<li>只是建议，编译器不一定内联</li>
</ul>
<p>接下来是一个例子：</p>
<ul>
<li>结果<ul>
<li>不抽象为函数调用最快</li>
<li>强制使用内联其次</li>
<li>建议内联 &#x3D; 模版函数 &#x3D; 普通函数</li>
<li>调的越多，时间越慢</li>
</ul>
</li>
<li>结论<ul>
<li>函数的调用是有一定的开销的</li>
<li>在可维护性，代码体积，运行时间上不可能全部满足</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">swap_</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-type">int</span> c = a;a = b; b = c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">swap__</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a,<span class="hljs-type">int</span> &amp;b)</span></span>&#123;<br>    <span class="hljs-type">int</span> c = a;a = b; b = c;<br>&#125;<br><br><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> __attribute__((always_inline)) <span class="hljs-built_in">swap___</span>(<span class="hljs-type">int</span> &amp;a, <span class="hljs-type">int</span> &amp;b) &#123;<br>    <span class="hljs-type">int</span> c = a; a = b; b = c;<br>&#125;<br><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>    <span class="hljs-keyword">auto</span> <span class="hljs-type">begin_t</span> = <span class="hljs-built_in">getCurrentTime</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">100000</span>;i++)<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">100000</span>;j++)&#123;<br>            <span class="hljs-type">int</span> a = i;<br>            <span class="hljs-type">int</span> b = j;<br>            <span class="hljs-comment">// way 1 std::swap(a,b); 22425</span><br>            <span class="hljs-comment">// way 2 int c = a;a = b; b = c; 13031</span><br>            <span class="hljs-comment">// way 3 swap_(a,b); 23029</span><br>            <span class="hljs-comment">// way 4 swap__(a,b); 22560</span><br>            <span class="hljs-comment">// way 5 swap___(a,b); 16994</span><br>            <span class="hljs-comment">// way 6 swap_(a,b);swap__(a,b);swap___(a,b); 52389</span><br>        &#125;<br>    <span class="hljs-keyword">auto</span>  <span class="hljs-type">end_t</span> = <span class="hljs-built_in">getCurrentTime</span>();<br>    std::cout&lt;&lt;<span class="hljs-built_in">calculateTimeDifference</span>(<span class="hljs-type">begin_t</span>,<span class="hljs-type">end_t</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h1><ul>
<li>修饰变量则变量在整个生命周期以及作用域都不可修改</li>
<li>修饰成员函数则说明这个函数不会修改任何成员</li>
<li>const函数只能调用被const修饰函数</li>
<li>静态函数不能定义为const函数（静态成员函数没有this指针，const是使得普通函数无法通过this指针修改成员变量）</li>
<li>如果const修饰的函数在头文件和实现文件同时出现，确保他们都被const修饰，否则编译器将认为这是两个不同的函数</li>
</ul>
<h1 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h1><ul>
<li>被static修饰的成员单独分配内存</li>
<li>不能在类中对static修饰的对象进行初始化</li>
<li>被static修饰的方法如果访问本身的静态成员，直接使用左值就可访问</li>
<li>被static’修饰的方法如果访问非静态成员，那么需要提供一个被访问的类的引用</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322939.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul>
<li>公有继承 不改变基类的访问控制规则</li>
<li>保护继承 public 降级为 protect</li>
<li>私有继承 public protect 降级为 private</li>
<li>在派生类中调用基类的同名方法需要使用::解析 例如 Student.human::eat()</li>
<li>尽量不用多继承（包含很多基类的副本），所以要和虚继承一起用</li>
<li>派生类的构造函数调用顺序和析构函数的调用顺序是相反的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322311.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="类的赋值兼容性"><a href="#类的赋值兼容性" class="headerlink" title="类的赋值兼容性"></a>类的赋值兼容性</h1><ul>
<li>可以把派生类对象赋值给基类对象</li>
<li>可以把派生类对象的指针给基类对象</li>
</ul>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><ul>
<li>只作用于函数，而不作用于其他函数</li>
<li>使用virtur修饰函数后，指向不同派生类的指针使用同样的函数名时，将自动调用各自虚函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Some sound&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>: <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Woof!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>: <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">sound</span><span class="hljs-params">()</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;Meow!&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>基类的析构函数一般也需要被定义为虚函数，这是一个非常重要的概念，尤其是当你使用继承和动态分配内存时。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Base Constructor&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Base</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Base Destructor&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Derived</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived Constructor&quot;</span> &lt;&lt; endl; &#125;<br>    ~<span class="hljs-built_in">Derived</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Derived Destructor&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>假设我们有以下的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">Base *b = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Derived</span>();<br><span class="hljs-keyword">delete</span> b;<br></code></pre></td></tr></table></figure>

<p>我们期望两个析构函数都会被调用，因为我们首先构造了一个 <code>Derived</code> 对象（这导致两个构造函数都被调用），然后我们删除了它。但如果 <code>Base</code> 的析构函数不是 <code>virtual</code> 的，那么只有 <code>Base</code> 的析构函数会被调用。这意味着 <code>Derived</code> 的析构函数不会被调用，这可能导致资源泄漏（例如，如果 <code>Derived</code> 在其析构函数中释放了动态分配的内存或其他资源）。</p>
<p>为了解决这个问题，我们需要在 <code>Base</code> 类中将析构函数声明为 <code>virtual</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Base</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Base Constructor&quot;</span> &lt;&lt; endl; &#125;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Base</span>() &#123; cout &lt;&lt; <span class="hljs-string">&quot;Base Destructor&quot;</span> &lt;&lt; endl; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>现在，无论通过哪个类的指针删除对象，都会首先调用 <code>Derived</code> 的析构函数，然后再调用 <code>Base</code> 的析构函数。这样，任何在 <code>Derived</code> 类中分配的资源都会被正确释放。</p>
<p>声明基类的析构函数为 <code>virtual</code> 也有一些性能开销，因为这会导致编译器为该类生成一个虚函数表。但这是为了正确性而付出的必要代价。如果一个类被设计为用于派生其他类，那么它的析构函数通常应该是虚函数，以确保资源被正确管理。</p>
<ul>
<li>纯虚函数包含的类是抽象类，不能被实例化</li>
</ul>
<p>纯虚函数是一个在基类中声明但没有定义的虚函数，而是在它的派生类中定义。这为类的设计者提供了一种方法，要求任何派生类提供特定的函数实现。具有纯虚函数的类称为抽象类，不能直接创建这种类的实例。</p>
<p><strong>1. 纯虚函数的声明</strong></p>
<p>纯虚函数使用 <code>= 0</code> 在其声明中进行初始化，如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">functionName</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure>

<p><strong>2. 抽象类</strong></p>
<p>包含至少一个纯虚函数的类称为抽象类。不能创建抽象类的实例，但可以创建指向它的指针或引用。这种类的目的是为其他类提供一个基础，从这个基础上进行继承和实现。</p>
<p><strong>示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">pureVirtualFunction</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>; <span class="hljs-comment">// 纯虚函数</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcreteClass</span> : <span class="hljs-keyword">public</span> AbstractClass &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pureVirtualFunction</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 纯虚函数的实现</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>AbstractClass</code> 是一个抽象类，因为它有一个纯虚函数。你不能创建 <code>AbstractClass</code> 的实例，但可以创建 <code>ConcreteClass</code> 的实例，因为 <code>ConcreteClass</code> 提供了 <code>pureVirtualFunction</code> 的定义。</p>
<p><strong>3. 使用场景</strong></p>
<p>纯虚函数和抽象类经常用于框架设计和提供接口。例如，你可以有一个抽象基类定义所有交互式UI组件应该有的接口（如 <code>draw()</code>, <code>resize()</code> 等），然后有多个派生类为按钮、滑块、文本框等具体实现这些接口。</p>
<p><strong>4. 注意事项</strong></p>
<ul>
<li>即使抽象类不能创建实例，它仍然可以有构造函数。这些构造函数由派生类的构造函数调用。 </li>
<li>一个类可以有多个纯虚函数。 </li>
<li>一个类继承自抽象类但没有实现所有的纯虚函数，它自己也成为了一个抽象类。</li>
</ul>
<p>纯虚函数和抽象类是面向对象设计中的核心概念，使得派生类必须遵循某些特定行为，从而确保更强的类型安全和更好的代码组织。</p>
<h2 id="运行时多态"><a href="#运行时多态" class="headerlink" title="运行时多态"></a>运行时多态</h2><ul>
<li>基于虚函数</li>
</ul>
<ol>
<li>**虚表 (vtable)**：每个有虚函数的类都有一个虚表。这个虚表中存储了该类的虚函数的地址。 </li>
<li><strong>虚表指针</strong>：每个对象都有一个指向其类的虚表的指针。这是在对象的内存布局中固定的部分。 </li>
<li><strong>虚表的构成</strong>：虚表是由指针数组组成的，其中每个指针指向类中对应的虚函数的实现。 </li>
<li><strong>派生类与虚表</strong>：如果派生类重写了基类的虚函数，那么派生类的虚表中，这个函数的地址会被替换成派生类函数的地址。如果派生类增加了新的虚函数，那么这些函数的地址也会被添加到派生类的虚表中。 </li>
<li><strong>向上转型与虚函数调用</strong>：当通过基类指针（这个指针实际上指向一个派生类对象）调用虚函数时，会根据该对象的真实类型（派生类）的虚表来决定调用哪个版本的虚函数。</li>
</ol>
<h2 id="编译时多态"><a href="#编译时多态" class="headerlink" title="编译时多态"></a>编译时多态</h2><ul>
<li>模版类</li>
<li>方法的重载（编译器会把参数类型和方法名绑定在一起，形成唯一的标识符）</li>
</ul>
<h1 id="操作符的重载"><a href="#操作符的重载" class="headerlink" title="操作符的重载"></a>操作符的重载</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Vector</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">double</span> x, y;<br><br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">Vector</span>() : <span class="hljs-built_in">x</span>(<span class="hljs-number">0.0</span>), <span class="hljs-built_in">y</span>(<span class="hljs-number">0.0</span>) &#123;&#125;<br><br>    <span class="hljs-comment">// 带参数的构造函数</span><br>    <span class="hljs-built_in">Vector</span>(<span class="hljs-type">double</span> x, <span class="hljs-type">double</span> y) : <span class="hljs-built_in">x</span>(x), <span class="hljs-built_in">y</span>(y) &#123;&#125;<br><br>    <span class="hljs-comment">// 重载 + 操作符</span><br>    Vector <span class="hljs-keyword">operator</span> + (<span class="hljs-type">const</span> Vector&amp; other) <span class="hljs-type">const</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Vector</span>(x + other.x, y + other.y);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 重载 &lt;&lt; 操作符，使得我们可以直接打印 Vector 对象</span><br>std::ostream&amp; <span class="hljs-keyword">operator</span> &lt;&lt; (std::ostream&amp; out, <span class="hljs-type">const</span> Vector&amp; v) &#123;<br>    out &lt;&lt; <span class="hljs-string">&quot;(&quot;</span> &lt;&lt; v.x &lt;&lt; <span class="hljs-string">&quot;, &quot;</span> &lt;&lt; v.y &lt;&lt; <span class="hljs-string">&quot;)&quot;</span>;<br>    <span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Vector <span class="hljs-title">v1</span><span class="hljs-params">(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>)</span></span>;<br>    <span class="hljs-function">Vector <span class="hljs-title">v2</span><span class="hljs-params">(<span class="hljs-number">2.5</span>, <span class="hljs-number">3.5</span>)</span></span>;<br>    <br>    Vector v3 = v1 + v2;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;v1 = &quot;</span> &lt;&lt; v1 &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;v2 = &quot;</span> &lt;&lt; v2 &lt;&lt; std::endl;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;v1 + v2 = &quot;</span> &lt;&lt; v3 &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241322623.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p><img src="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202310241319180.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ul>
<li>抽象类不可以实例化</li>
<li>只要有一个纯虚函数那这个类就是抽象类</li>
<li>纯虚函数无论返回值是什么都用 <code>virtual return_type f() = 0</code></li>
<li>如果基类没有默认构造函数，派生类必须要显式的构造基类</li>
<li>继承了抽象类的派生类必须去实现所有<code>纯虚函数</code>，或者自己成为一个抽象类</li>
<li>涉及到纯虚函数的基类需要一个虚析构函数（删除基类指针会导致派生类无法正常被释放）</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span> <span class="hljs-comment">// 包含智能指针头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">base</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> age;<br>    string name;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">base</span>() : <span class="hljs-built_in">age</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">name</span>(<span class="hljs-string">&quot;&quot;</span>) &#123;&#125;<br>    <span class="hljs-built_in">base</span>(<span class="hljs-type">int</span> age_, string name_) : <span class="hljs-built_in">age</span>(age_), <span class="hljs-built_in">name</span>(name_) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setterAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age_)</span> </span>&#123;<br>        age = age_;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setterName</span><span class="hljs-params">(<span class="hljs-type">const</span> string&amp; name_)</span> </span>&#123;<br>        name = name_;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> age;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">exceptage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>	<span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">base</span>() = <span class="hljs-keyword">default</span>;<br><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span> : <span class="hljs-keyword">public</span> base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">student</span>(<span class="hljs-type">int</span> age_, string name_) : <span class="hljs-built_in">base</span>(age_, name_) &#123;&#125;<br>    <span class="hljs-built_in">student</span>() : <span class="hljs-built_in">base</span>() &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">say</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;age is &quot;</span> &lt;&lt; <span class="hljs-built_in">getAge</span>() &lt;&lt; endl;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">exceptage</span><span class="hljs-params">()</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">getAge</span>() + <span class="hljs-number">10</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 使用 std::unique_ptr 创建 student 对象</span><br>    <span class="hljs-comment">// unique_ptr&lt;student&gt; st = make_unique&lt;student&gt;();</span><br>    <span class="hljs-comment">// unique_ptr和单例可不是一个东西</span><br>    <span class="hljs-function">unique_ptr&lt;student&gt; <span class="hljs-title">st</span><span class="hljs-params">(<span class="hljs-keyword">new</span> student())</span></span>;<br>    <span class="hljs-function">unique_ptr&lt;student&gt; <span class="hljs-title">st2</span><span class="hljs-params">(<span class="hljs-keyword">new</span> student())</span></span>;<br>    <br>    st-&gt;<span class="hljs-built_in">setterAge</span>(<span class="hljs-number">10</span>);<br>    st-&gt;<span class="hljs-built_in">setterName</span>(<span class="hljs-string">&quot;string name_&quot;</span>);<br>    st-&gt;<span class="hljs-built_in">say</span>();<br>    cout &lt;&lt; <span class="hljs-string">&quot;ex age &quot;</span> &lt;&lt; st-&gt;<span class="hljs-built_in">exceptage</span>() &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>


<h1 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h1><ul>
<li>函数模版 ：对未知类型的参数进行操作</li>
<li>可以重载</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(T1 a, T2 b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T1, <span class="hljs-keyword">typename</span> T2, <span class="hljs-keyword">typename</span> T3&gt;<br><span class="hljs-function"><span class="hljs-keyword">auto</span> <span class="hljs-title">sum</span><span class="hljs-params">(T1 a, T2 b, T3 c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> result = <span class="hljs-built_in">sum</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">4.0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%f&quot;</span>, result);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>类模版</li>
</ul>
<p>类模板的继承与常规类的继承有很多相似之处。但是，由于模板的泛型性质，它在继承时添加了一些特定的语法和考虑因素。</p>
<p>以下是一些关于类模板继承的关键点：</p>
<ol>
<li><strong>基本继承</strong>：<br>类模板可以继承自另一个类模板，或者从一个非模板类继承。</li>
</ol>
<p>例如，假设我们有一个名为 <code>BaseBox</code> 的类模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BaseBox</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    T content;<br>    <span class="hljs-built_in">BaseBox</span>(T c) : <span class="hljs-built_in">content</span>(c) &#123;&#125;<br>    <span class="hljs-function">T <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> content; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>你可以创建一个从 <code>BaseBox</code> 继承的 <code>DerivedBox</code> 类模板：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedBox</span> : <span class="hljs-keyword">public</span> BaseBox&lt;T&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DerivedBox</span>(T c) : <span class="hljs-built_in">BaseBox</span>&lt;T&gt;(c) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showContent</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Content: &quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getContent</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>模板参数</strong>：<br>子类模板可以添加额外的模板参数或者使用基类模板的参数。例如：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">typename</span> T, <span class="hljs-keyword">typename</span> U&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedBoxWithTwoTypes</span> : <span class="hljs-keyword">public</span> BaseBox&lt;T&gt; &#123;<br>    U extraContent;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DerivedBoxWithTwoTypes</span>(T c, U e) : <span class="hljs-built_in">BaseBox</span>&lt;T&gt;(c), <span class="hljs-built_in">extraContent</span>(e) &#123;&#125;<br>    <span class="hljs-function">U <span class="hljs-title">getExtraContent</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> extraContent; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>特化</strong>：<br>你可以为继承的类模板提供特化版本，就像为常规模板提供特化版本一样：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">template</span> &lt;&gt;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DerivedBox</span>&lt;<span class="hljs-type">char</span>&gt; : <span class="hljs-keyword">public</span> BaseBox&lt;<span class="hljs-type">char</span>&gt; &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">DerivedBox</span>(<span class="hljs-type">char</span> c) : <span class="hljs-built_in">BaseBox</span>&lt;<span class="hljs-type">char</span>&gt;(c) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showASCII</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;ASCII Value: &quot;</span> &lt;&lt; <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">getContent</span>()) &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><strong>继承自非模板类</strong>：<br>类模板可以继承自非模板类。反之亦然，非模板类也可以继承自类模板的一个特定实例。</li>
</ol>
<h1 id="多线程-amp-网络"><a href="#多线程-amp-网络" class="headerlink" title="多线程 &amp; 网络"></a>多线程 &amp; 网络</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;curl/curl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;openssl/sha.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iomanip&gt;</span></span><br><br><br><span class="hljs-comment">// 回调函数，用于将数据写入输出流</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">write_data</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr, <span class="hljs-type">size_t</span> size, <span class="hljs-type">size_t</span> nmemb, <span class="hljs-type">void</span>* stream)</span> </span>&#123;<br>    std::ostringstream* output = <span class="hljs-built_in">reinterpret_cast</span>&lt;std::ostringstream*&gt;(stream);  <span class="hljs-comment">// 将void*指针转换为ostringstream*类型</span><br>    <span class="hljs-type">size_t</span> realSize = size * nmemb;  <span class="hljs-comment">// 计算真实数据的大小</span><br>    output-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">const</span> <span class="hljs-type">char</span>*&gt;(ptr), realSize);  <span class="hljs-comment">// 将数据写入输出流</span><br>    <span class="hljs-keyword">return</span> realSize;  <span class="hljs-comment">// 返回写入的数据量，用于告诉cURL我们处理了多少数据</span><br>&#125;<br><br><span class="hljs-comment">// 为输入字符串计算SHA-256哈希值</span><br><span class="hljs-function">std::string <span class="hljs-title">sha256</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; data)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> hash[SHA256_DIGEST_LENGTH];  <span class="hljs-comment">// 存储计算出的哈希值的数组</span><br>    SHA256_CTX sha256;  <span class="hljs-comment">// SHA-256结构体，用于保存哈希的上下文信息</span><br>    <span class="hljs-built_in">SHA256_Init</span>(&amp;sha256);  <span class="hljs-comment">// 初始化SHA-256上下文</span><br>    <span class="hljs-built_in">SHA256_Update</span>(&amp;sha256, data.<span class="hljs-built_in">c_str</span>(), data.<span class="hljs-built_in">size</span>());  <span class="hljs-comment">// 更新SHA-256上下文以处理输入数据</span><br>    <span class="hljs-built_in">SHA256_Final</span>(hash, &amp;sha256);  <span class="hljs-comment">// 结束哈希计算并存储结果</span><br>    std::stringstream ss;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; SHA256_DIGEST_LENGTH; i++) &#123;<br>        ss &lt;&lt; std::hex &lt;&lt; std::<span class="hljs-built_in">setw</span>(<span class="hljs-number">2</span>) &lt;&lt; std::<span class="hljs-built_in">setfill</span>(<span class="hljs-string">&#x27;0&#x27;</span>) &lt;&lt; (<span class="hljs-type">int</span>)hash[i];  <span class="hljs-comment">// 将哈希值转换为十六进制字符串</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> ss.<span class="hljs-built_in">str</span>();<br>&#125;<br><br><span class="hljs-comment">// 下载指定URL的一部分数据段，并将数据写入输出流</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">download_file_segment</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url, <span class="hljs-type">long</span> start, <span class="hljs-type">long</span> end, std::ostringstream&amp; output)</span> </span>&#123;<br>    CURL* curl = <span class="hljs-built_in">curl_easy_init</span>();  <span class="hljs-comment">// 初始化cURL句柄</span><br>    <span class="hljs-keyword">if</span> (curl) &#123;<br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_URL, url.<span class="hljs-built_in">c_str</span>());  <span class="hljs-comment">// 设置要下载的URL</span><br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEFUNCTION, write_data);  <span class="hljs-comment">// 设置数据写入的回调函数</span><br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEDATA, &amp;output);  <span class="hljs-comment">// 设置回调函数的输出流参数</span><br><br>        <span class="hljs-type">char</span> range[<span class="hljs-number">100</span>];  <span class="hljs-comment">// 存储要下载的数据范围的字符串</span><br>        <span class="hljs-built_in">sprintf</span>(range, <span class="hljs-string">&quot;%ld-%ld&quot;</span>, start, end);  <span class="hljs-comment">// 格式化范围字符串</span><br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_RANGE, range);  <span class="hljs-comment">// 设置要下载的数据范围</span><br><br>        <span class="hljs-built_in">curl_easy_perform</span>(curl);  <span class="hljs-comment">// 执行cURL操作，开始下载</span><br>        <span class="hljs-built_in">curl_easy_cleanup</span>(curl);  <span class="hljs-comment">// 清理并释放cURL句柄</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">server_supports_ranges</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; url)</span> </span>&#123;<br>    <span class="hljs-type">bool</span> supports_ranges = <span class="hljs-literal">false</span>;<br><br>    CURL* curl = <span class="hljs-built_in">curl_easy_init</span>();<br>    <span class="hljs-keyword">if</span> (curl) &#123;<br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_URL, url.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_HEADER, <span class="hljs-number">1</span>); <span class="hljs-comment">// 只获取头部信息</span><br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_NOBODY, <span class="hljs-number">1</span>); <span class="hljs-comment">// 不需要体部数据</span><br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_RANGE, <span class="hljs-string">&quot;0-1&quot;</span>); <span class="hljs-comment">// 请求文件的前两个字节</span><br><br>        std::ostringstream output;<br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEFUNCTION, write_data);<br>        <span class="hljs-built_in">curl_easy_setopt</span>(curl, CURLOPT_WRITEDATA, &amp;output);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">curl_easy_perform</span>(curl) == CURLE_OK) &#123;<br>            <span class="hljs-comment">// 检查输出是否包含 &quot;Accept-Ranges: bytes&quot;</span><br>            std::string header_data = output.<span class="hljs-built_in">str</span>();<br>            <span class="hljs-keyword">if</span> (header_data.<span class="hljs-built_in">find</span>(<span class="hljs-string">&quot;Accept-Ranges: bytes&quot;</span>) != std::string::npos) &#123;<br>                supports_ranges = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-built_in">curl_easy_cleanup</span>(curl);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> supports_ranges;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string url = <span class="hljs-string">&quot;http://speedtest.ftp.otenet.gr/files/test1Gb.db&quot;</span>;  <span class="hljs-comment">// 设置要下载的文件的URL</span><br>    <span class="hljs-type">long</span> file_size = <span class="hljs-number">1L</span> * <span class="hljs-number">1024L</span> * <span class="hljs-number">1024L</span> * <span class="hljs-number">1024L</span>;  <span class="hljs-comment">// 设置文件的大小</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">server_supports_ranges</span>(url)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Server supports range requests!&quot;</span> &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Server does NOT support range requests.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <span class="hljs-comment">// 结束程序</span><br>    &#125;<br><br><br>    <span class="hljs-comment">// 对于1到4个线程，下载文件并计算下载时间和文件的SHA-256哈希值</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num_threads = <span class="hljs-number">8</span>; num_threads &lt;= <span class="hljs-number">16</span>; ++num_threads) &#123;<br>        <span class="hljs-type">long</span> segment_size = file_size / num_threads;  <span class="hljs-comment">// 计算每个线程应下载的数据段的大小</span><br><br>        <span class="hljs-keyword">auto</span> start_time = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();  <span class="hljs-comment">// 记录下载开始的时间</span><br><br>        std::vector&lt;std::thread&gt; threads;  <span class="hljs-comment">// 用于保存所有线程的vector</span><br>        <span class="hljs-function">std::vector&lt;std::ostringstream&gt; <span class="hljs-title">outputs</span><span class="hljs-params">(num_threads)</span></span>;  <span class="hljs-comment">// 用于保存每个线程下载数据的vector</span><br><br>        <span class="hljs-comment">// 启动所有线程来并行下载文件的不同部分</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; ++i) &#123;<br>            <span class="hljs-type">long</span> start = i * segment_size;  <span class="hljs-comment">// 计算数据段的开始位置</span><br>            <span class="hljs-type">long</span> end = (i == num_threads - <span class="hljs-number">1</span>) ? file_size - <span class="hljs-number">1</span> : start + segment_size - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 计算数据段的结束位置</span><br>            threads.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(download_file_segment, url, start, end, std::<span class="hljs-built_in">ref</span>(outputs[i])));  <span class="hljs-comment">// 启动一个新线程来下载该数据段</span><br>        &#125;<br><br>        <span class="hljs-comment">// 等待所有线程完成下载</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; th : threads) &#123;<br>            th.<span class="hljs-built_in">join</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">auto</span> end_time = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();  <span class="hljs-comment">// 记录下载结束的时间</span><br>        <span class="hljs-keyword">auto</span> elapsed_time = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end_time - start_time).<span class="hljs-built_in">count</span>();  <span class="hljs-comment">// 计算下载所花费的时间</span><br><br>        std::ostringstream combinedOutput;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; output : outputs) &#123;<br>            combinedOutput &lt;&lt; output.<span class="hljs-built_in">str</span>();  <span class="hljs-comment">// 将所有线程下载的数据组合成一个单一的输出流</span><br>        &#125;<br><br>        std::string hashValue = <span class="hljs-built_in">sha256</span>(combinedOutput.<span class="hljs-built_in">str</span>());  <span class="hljs-comment">// 计算下载的文件的SHA-256哈希值</span><br><br>        <span class="hljs-comment">// 打印线程数、下载时间和文件的SHA-256哈希值</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Threads: &quot;</span> &lt;&lt; num_threads &lt;&lt; <span class="hljs-string">&quot;, Time: &quot;</span> &lt;&lt; elapsed_time &lt;&lt; <span class="hljs-string">&quot;ms, Hash: &quot;</span> &lt;&lt; hashValue &lt;&lt; std::endl;<br>    &#125;<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * out</span><br><span class="hljs-comment"> * Threads: 1, Time: 199383ms, Hash: 49bc20df15e412a64472421e13fe86ff1c5165e18b2afccf160d4dc19fe68a14</span><br><span class="hljs-comment"> * Threads: 2, Time: 121071ms, Hash: 49bc20df15e412a64472421e13fe86ff1c5165e18b2afccf160d4dc19fe68a14</span><br><span class="hljs-comment"> * Threads: 3, Time: 120341ms, Hash: 49bc20df15e412a64472421e13fe86ff1c5165e18b2afccf160d4dc19fe68a14</span><br><span class="hljs-comment"> * Threads: 4, Time: 105299ms, Hash: 49bc20df15e412a64472421e13fe86ff1c5165e18b2afccf160d4dc19fe68a14</span><br><span class="hljs-comment"> * -----</span><br><span class="hljs-comment"> * Threads: 8, Time: 99205ms, Hash: 49bc20df15e412a64472421e13fe86ff1c5165e18b2afccf160d4dc19fe68a14</span><br><span class="hljs-comment"> * Threads: 9, Time: 101934ms, Hash: 49bc20df15e412a64472421e13fe86ff1c5165e18b2afccf160d4dc19fe68a14</span><br><span class="hljs-comment"> */</span><br><br><br></code></pre></td></tr></table></figure>

<h1 id="thread"><a href="#thread" class="headerlink" title="thread"></a>thread</h1><p><code>&lt;thread&gt;</code> 是 C11 中引入的头文件，它提供了对线程的基础支持。在之前的 C 版本中，多线程编程通常依赖于第三方库或平台特定的API。C++11 的目标之一是引入并发和多线程编程的标准支持，从而使多线程编程更容易且跨平台。</p>
<h2 id="来源："><a href="#来源：" class="headerlink" title="来源："></a>来源：</h2><p>线程库的设计基于 Boost.Thread 库，它在 C++11 被标准化之前为多线程编程提供了一个高层次的接口。</p>
<h2 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h2><ol>
<li><strong>创建线程</strong>：</li>
</ol>
<p>你可以使用 <code>std::thread</code> 类来创建并启动一个线程：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionToRunInThread</span><span class="hljs-params">()</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">myThread</span><span class="hljs-params">(functionToRunInThread)</span></span>; <span class="hljs-comment">// 创建并启动线程</span><br><br>    myThread.<span class="hljs-built_in">join</span>();  <span class="hljs-comment">// 等待线程完成</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li><strong>传递参数给线程函数</strong>：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">functionWithArgs</span><span class="hljs-params">(<span class="hljs-type">int</span> x, std::string s)</span> </span>&#123;<br>    std::cout &lt;&lt; s &lt;&lt; x &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">myThread</span><span class="hljs-params">(functionWithArgs, <span class="hljs-number">42</span>, <span class="hljs-string">&quot;Number: &quot;</span>)</span></span>;<br><br>    myThread.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Lambda 表达式</strong>：</li>
</ol>
<p>你还可以使用 lambda 表达式作为线程函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::thread <span class="hljs-title">myThread</span><span class="hljs-params">([]() &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">        std::cout &lt;&lt; <span class="hljs-string">&quot;Hello from thread!&quot;</span> &lt;&lt; std::endl;</span></span><br><span class="hljs-params"><span class="hljs-function">    &#125;)</span></span>;<br><br>    myThread.<span class="hljs-built_in">join</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li><strong>线程管理</strong>：</li>
</ol>
<ul>
<li><code>myThread.join();</code>：等待线程完成其执行。 </li>
<li><code>myThread.detach();</code>：允许线程自主运行，不需要在主线程中等待它完成。</li>
</ul>
<p>注意：一个线程对象只能 <code>join()</code> 一次或 <code>detach()</code> 一次。尝试多次这样做将导致程序错误。</p>
<ol start="5">
<li><strong>线程ID</strong>：</li>
</ol>
<p>每个线程都有一个唯一的线程ID，你可以这样获取：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::thread::id this_id = std::this_thread::<span class="hljs-built_in">get_id</span>();<br></code></pre></td></tr></table></figure>

<ol start="6">
<li><strong>其他线程相关的工具</strong>：</li>
</ol>
<p><code>&lt;thread&gt;</code> 头文件只是 C++ 标准库并发设施的冰山一角。还有其他许多头文件和类，如 <code>&lt;mutex&gt;</code>, <code>&lt;condition_variable&gt;</code>, <code>&lt;future&gt;</code> 等，为并发编程提供了丰富的功能。</p>
<p>总之，C11 的 <code>&lt;thread&gt;</code> 库为 C 程序员提供了一个标准、跨平台的方式来进行多线程编程。但要编写正确且高效的多线程程序，仍需要深入理解并发编程的复杂性和挑战。</p>
<ul>
<li>优化哈德玛积</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;chrono&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;thread&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; v;<br><span class="hljs-keyword">typedef</span> std::vector&lt;std::thread&gt; array;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cal</span><span class="hljs-params">(v&amp; A, v&amp; B, v&amp; R, <span class="hljs-type">int</span> start_row = <span class="hljs-number">0</span>, <span class="hljs-type">int</span> num_row = <span class="hljs-number">-1</span>)</span>  </span>&#123;<br>    <span class="hljs-keyword">if</span> (num_row == <span class="hljs-number">-1</span>) &#123;<br>        num_row = A.<span class="hljs-built_in">size</span>(); <span class="hljs-comment">// for single threaded version</span><br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = start_row; i &lt; start_row + num_row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; A[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>(); j++) &#123;<br>            R[i][j] = A[i][j] * B[i][j];<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function">v <span class="hljs-title">generate_random_matrix</span><span class="hljs-params">(<span class="hljs-type">int</span> rows, <span class="hljs-type">int</span> cols)</span> </span>&#123;<br>    std::random_device rd;<br>    <span class="hljs-function">std::mt19937 <span class="hljs-title">gen</span><span class="hljs-params">(rd())</span></span>;<br>    std::uniform_int_distribution&lt;&gt; <span class="hljs-built_in">dis</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>);<br><br>    <span class="hljs-function">v <span class="hljs-title">matrix</span><span class="hljs-params">(rows, std::vector&lt;<span class="hljs-type">int</span>&gt;(cols))</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; cols; j++) &#123;<br>            matrix[i][j] = <span class="hljs-built_in">dis</span>(gen);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> matrix;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> rows = <span class="hljs-number">10000</span>;<br>    <span class="hljs-type">int</span> cols = <span class="hljs-number">10000</span>;<br><br>    v A = <span class="hljs-built_in">generate_random_matrix</span>(rows, cols);<br>    v B = <span class="hljs-built_in">generate_random_matrix</span>(rows, cols);<br>    <span class="hljs-function">v <span class="hljs-title">R</span><span class="hljs-params">(rows, std::vector&lt;<span class="hljs-type">int</span>&gt;(cols))</span></span>;<br><br>    <span class="hljs-comment">// Single-threaded version</span><br>    <span class="hljs-keyword">auto</span> start_single = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-built_in">cal</span>(A, B, R);<br>    <span class="hljs-keyword">auto</span> end_single = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">auto</span> duration_single = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end_single - start_single);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Single-threaded time taken: &quot;</span> &lt;&lt; duration_single.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// Multi-threaded version</span><br>    <span class="hljs-keyword">auto</span> start_multi = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br><br>    <span class="hljs-type">int</span> num_threads = std::thread::<span class="hljs-built_in">hardware_concurrency</span>();<br>    array threads;<br><br>    <span class="hljs-type">int</span> rows_per_thread = rows / num_threads;<br>    <span class="hljs-type">int</span> remaining_rows = rows % num_threads;<br>    <span class="hljs-type">int</span> start_row = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; num_threads; i++) &#123;<br>        <span class="hljs-type">int</span> num_rows = rows_per_thread + (i &lt; remaining_rows ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        threads.<span class="hljs-built_in">push_back</span>(std::<span class="hljs-built_in">thread</span>(cal, std::<span class="hljs-built_in">ref</span>(A), std::<span class="hljs-built_in">ref</span>(B), std::<span class="hljs-built_in">ref</span>(R), start_row, num_rows));<br>        start_row += num_rows;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (std::thread&amp; t : threads) &#123;<br>        t.<span class="hljs-built_in">join</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">auto</span> end_multi = std::chrono::high_resolution_clock::<span class="hljs-built_in">now</span>();<br>    <span class="hljs-keyword">auto</span> duration_multi = std::chrono::<span class="hljs-built_in">duration_cast</span>&lt;std::chrono::milliseconds&gt;(end_multi - start_multi);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Multi-threaded time taken: &quot;</span> &lt;&lt; duration_multi.<span class="hljs-built_in">count</span>() &lt;&lt; <span class="hljs-string">&quot;ms&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>当然可以，这是一个更完善、格式化和修正后的<code>unique_ptr</code>笔记：</p>
<hr>
<h1 id="智能指针-unique-ptr"><a href="#智能指针-unique-ptr" class="headerlink" title="智能指针 - unique_ptr"></a>智能指针 - <code>unique_ptr</code></h1><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">5</span>])</span></span>;<br>    <span class="hljs-function">std::unique_ptr&lt;<span class="hljs-type">int</span>[]&gt; <span class="hljs-title">ptr2</span><span class="hljs-params">(std::move(ptr))</span></span>;<br>    <br>    <span class="hljs-comment">// 注意：这段代码并不会抛出异常，而是直接中断</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        ptr[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        ptr[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span>;<br>    &#125; <span class="hljs-built_in">catch</span> (std::exception&amp; e) &#123;<br>        std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>();<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;int&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul>
<li><code>unique_ptr</code>同一时间只允许一个指针指向某块内存。</li>
<li><code>unique_ptr</code>重载了赋值操作符，但只接受右值引用。你不能直接将一个<code>unique_ptr</code>赋给另一个，但可以使用<code>std::move</code>。</li>
<li>如果你将原始指针赋予智能指针管理，建议将原始指针置为nullptr，以避免不小心使用它。</li>
</ul>
<h2 id="指针概念"><a href="#指针概念" class="headerlink" title="指针概念"></a>指针概念</h2><ul>
<li><strong>野指针</strong>: 一个不再指向有效对象的指针。可能是因为它从未被初始化，或者它原本指向的对象已经被删除。</li>
<li><strong>悬挂指针</strong>: 指向已经释放的内存的指针。</li>
</ul>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>以下示例显示了<code>unique_ptr</code>如何帮助避免内存泄漏。</p>
<p><strong>示例1: 使用析构函数释放内存</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    B* b;<br><br>    ~<span class="hljs-built_in">A</span>() &#123;<br>        <span class="hljs-keyword">delete</span> b;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;析构&quot;</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *a = <span class="hljs-keyword">new</span> A;<br>    B *b = <span class="hljs-keyword">new</span> B;<br>    a-&gt;b = b;<br>    <span class="hljs-function">unique_ptr&lt;A&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(a)</span></span>;<br>    ptr.<span class="hljs-built_in">reset</span>(); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>示例2: 使用智能指针</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">B</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    unique_ptr&lt;B&gt; b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    A *a = <span class="hljs-keyword">new</span> A;<br>    B *b = <span class="hljs-keyword">new</span> B;<br>    a-&gt;b = <span class="hljs-built_in">unique_ptr</span>&lt;B&gt;(b);<br>    <span class="hljs-function">unique_ptr&lt;A&gt; <span class="hljs-title">ptr</span><span class="hljs-params">(a)</span></span>; <br>    ptr.<span class="hljs-built_in">reset</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="工厂函数"><a href="#工厂函数" class="headerlink" title="工厂函数"></a>工厂函数</h2><p><code>unique_ptr</code>常用作工厂函数的返回类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">School</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> num_teacher;<br>    string school_name;<br><br>    <span class="hljs-built_in">School</span>() &#123;&#125;<br>    <span class="hljs-built_in">School</span>(<span class="hljs-type">int</span> a, string b): <span class="hljs-built_in">num_teacher</span>(a), <span class="hljs-built_in">school_name</span>(b) &#123;&#125;<br>    ~<span class="hljs-built_in">School</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function">unique_ptr&lt;School&gt; <span class="hljs-title">build_school</span><span class="hljs-params">(<span class="hljs-type">int</span> teacher, string name, <span class="hljs-type">bool</span> use_make)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(use_make) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">make_unique</span>&lt;School&gt;(teacher, name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">unique_ptr</span>&lt;School&gt;(<span class="hljs-keyword">new</span> <span class="hljs-built_in">School</span>(teacher, name));<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">auto</span> p1 = <span class="hljs-built_in">build_school</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">auto</span> p2 = <span class="hljs-built_in">build_school</span>(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><ul>
<li>考虑学习<code>unique_ptr</code>的其他方法，如<code>reset()</code>, <code>get()</code>, <code>release()</code>等。</li>
<li>探索<code>unique_ptr</code>如何与自定义删除器配合使用。</li>
</ul>
<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shallow</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Shallow</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value)) &#123; &#125;<br><br>    <span class="hljs-comment">// 默认复制构造函数是浅拷贝</span><br>    <span class="hljs-built_in">Shallow</span>(<span class="hljs-type">const</span> Shallow&amp; other) : <span class="hljs-built_in">data</span>(other.data) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Data: &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Shallow</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Shallow <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    Shallow obj2 = obj1; <span class="hljs-comment">// 使用浅拷贝</span><br><br>    obj1.<span class="hljs-built_in">print</span>();<br>    obj2.<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Deep</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* data;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Deep</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(value)) &#123; &#125;<br><br>    <span class="hljs-comment">// 自定义复制构造函数实现深拷贝</span><br>    <span class="hljs-built_in">Deep</span>(<span class="hljs-type">const</span> Deep&amp; other) : <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*(other.data))) &#123; &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Data: &quot;</span> &lt;&lt; *data &lt;&lt; std::endl;<br>    &#125;<br><br>    ~<span class="hljs-built_in">Deep</span>() &#123;<br>        <span class="hljs-keyword">delete</span> data;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">Deep <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">5</span>)</span></span>;<br>    Deep obj2 = obj1; <span class="hljs-comment">// 使用深拷贝</span><br><br>    obj1.<span class="hljs-built_in">print</span>();<br>    obj2.<span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述例子中，我们可以看到对于浅拷贝，当<code>obj1</code>和<code>obj2</code>被销毁时，它们的析构函数都会尝试删除同一个内存地址，这会导致程序崩溃。而深拷贝的例子中，由于<code>obj1</code>和<code>obj2</code>持有不同的内存地址，所以不存在此问题。</p>
<h1 id="内存对齐"><a href="#内存对齐" class="headerlink" title="内存对齐"></a>内存对齐</h1><h2 id="为什么需要内存对齐？"><a href="#为什么需要内存对齐？" class="headerlink" title="为什么需要内存对齐？"></a>为什么需要内存对齐？</h2><ul>
<li>cpu从内存中读取内容并不是随意的，受制于一个读取粒度的影响；</li>
</ul>
<p>假如一个int型变量从第一个字节开始存储，那么为了读取这个变量，cpu需要通过两次访存来获取这个变量；但如果这个变量在0这个位置存储，那么只需要一次访存就可以获得这个变量的值</p>
<h2 id="怎么对齐，以结构体为例"><a href="#怎么对齐，以结构体为例" class="headerlink" title="怎么对齐，以结构体为例"></a>怎么对齐，以结构体为例</h2><ul>
<li>确保当前成员变量全部都在<code>k*sizeof(current_var)</code>上就行</li>
<li>最后结构体必须是结构体最大成员变量的整数倍</li>
</ul>
<h1 id="const和static"><a href="#const和static" class="headerlink" title="const和static"></a>const和static</h1><ul>
<li>保持状态的持久性</li>
</ul>
<h1 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h1><p>STL有三个大的概念</p>
<ul>
<li>容器</li>
</ul>
<p>实际上就是模版类（泛型编程），可以存储不同的数据类型</p>
<ul>
<li><p>算法</p>
<pre><code class="hljs">无关于容器的实现 一些共用的算法
</code></pre>
</li>
<li><p>迭代器</p>
</li>
</ul>
<p>STL主要由以下几个部分组成：</p>
<ol>
<li><strong>容器（Containers）</strong>：<br>这些是用于存储数据的模板类。主要的容器可以分为以下几类： <ul>
<li>顺序容器：<code>vector</code>、<code>deque</code>、<code>list</code>、<code>forward_list</code>、<code>array</code>、<code>string</code></li>
<li>关联容器：<code>set</code>、<code>multiset</code>、<code>map</code>、<code>multimap</code></li>
<li>无序关联容器：<code>unordered_set</code>、<code>unordered_multiset</code>、<code>unordered_map</code>、<code>unordered_multimap</code></li>
<li>容器适配器：<code>stack</code>、<code>queue</code>、<code>priority_queue</code></li>
</ul>
</li>
<li><strong>算法（Algorithms）</strong>：<br>STL提供了一系列算法，这些算法主要是对容器进行操作，如查找、排序、复制、删除等。主要算法包括： <ul>
<li>非修改性算法：如<code>find</code>、<code>count</code>、<code>max_element</code>、<code>min_element</code></li>
<li>修改性算法：如<code>copy</code>、<code>move</code>、<code>replace</code>、<code>shuffle</code></li>
<li>排序算法：如<code>sort</code>、<code>partial_sort</code>、<code>nth_element</code></li>
<li>有序区间的算法：如<code>lower_bound</code>、<code>upper_bound</code>、<code>equal_range</code></li>
<li>数值算法：如<code>iota</code>、<code>accumulate</code>、<code>adjacent_difference</code></li>
</ul>
</li>
<li><strong>迭代器（Iterators）</strong>：<br>迭代器是连接容器与算法的桥梁，允许以统一的方式访问容器的元素。根据功能和用途，迭代器可分为以下几类： <ul>
<li>输入迭代器</li>
<li>输出迭代器</li>
<li>前向迭代器</li>
<li>双向迭代器</li>
<li>随机访问迭代器</li>
</ul>
</li>
<li><strong>功能对象（Function Objects）</strong>：<br>这些是定义了<code>operator()</code>的对象，也叫做仿函数。STL中包含了一系列预定义的功能对象，如<code>less</code>、<code>greater</code>、<code>plus</code>、<code>minus</code>等。 </li>
<li><strong>适配器（Adaptors）</strong>：<br>适配器允许更改某些容器、迭代器或仿函数的行为。常见的适配器有：<code>stack</code>、<code>queue</code>、<code>priority_queue</code>、<code>reverse_iterator</code>、<code>insert_iterator</code>。 </li>
<li><strong>内存分配器（Allocators）</strong>：<br>分配器是用于管理STL容器内存的对象。默认分配器是<code>std::allocator</code>，但用户可以自定义分配器满足特定的内存管理需求。 </li>
<li><strong>异常（Exceptions）</strong>：<br>当STL中的函数或方法不能完成其正常操作时，它们可能会抛出异常。</li>
</ol>
<p>STL的优势在于它的模板化和数据结构与算法的分离。这意味着开发者可以用相似的方式对待不同的数据结构，并且可以在各种数据结构上使用通用的算法。这增加了代码的可复用性，并减少了实现相同功能时的代码量。</p>
<p>要使用STL，通常需要包含相应的头文件，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br></code></pre></td></tr></table></figure>

<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><ul>
<li>动态数组，支持自定义类型和基本数据类型</li>
<li>支持顺序访问</li>
<li>基于RAII定义一个使用到堆内存的资源</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by 张帅 on 2023/10/8.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> TEST_RESOURCE_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TEST_RESOURCE_H</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Resource</span>&#123;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> *data;<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Resource</span>(<span class="hljs-type">int</span> n);<br>~<span class="hljs-built_in">Resource</span>();<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">multiply</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//拷贝函数</span><br><span class="hljs-built_in">Resource</span>(<span class="hljs-type">const</span> Resource&amp; other) : <span class="hljs-built_in">len</span>(other.len), <span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[other.len]) &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;copy construct func&quot;</span>&lt;&lt;std::endl;<br>    std::<span class="hljs-built_in">copy</span>(other.data, other.data + len, data);<br>&#125;<br><span class="hljs-comment">// 移动构造函数 move操作 移动后原有的资源被置为空 &amp;&amp;代表右值引用</span><br><span class="hljs-built_in">Resource</span>(Resource&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">data</span>(other.data), <span class="hljs-built_in">len</span>(other.len) &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;move construct fun&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-comment">//确保other析构时不会造成双删问题</span><br>    other.data = <span class="hljs-literal">nullptr</span>;<br>    other.len = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//移动复制运算符 例如r1=r2 把r1释放掉，把r2给r1，r2本身的引用也失效</span><br>Resource&amp; <span class="hljs-keyword">operator</span>=(Resource&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;move copy func&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>        <span class="hljs-keyword">delete</span>[] data;<br><br>        data = other.data;<br>        len = other.len;<br><br>        other.data = <span class="hljs-literal">nullptr</span>;<br>        other.len = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">//TEST_RESOURCE_H</span></span><br><br></code></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//</span><br><span class="hljs-comment">// Created by 张帅 on 2023/10/8.</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Resource.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;iostream&quot;</span></span><br><br>Resource::<span class="hljs-built_in">Resource</span>(<span class="hljs-type">int</span> n) :<span class="hljs-built_in">data</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[n]),<span class="hljs-built_in">len</span>(n) &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;successful gen data with &quot;</span>&lt;&lt;n&lt;&lt;<span class="hljs-string">&quot; block!&quot;</span>&lt;&lt;std::endl;<br>&#125;<br><br>Resource::~<span class="hljs-built_in">Resource</span>() &#123;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;successful delete data with &quot;</span>&lt;&lt;len&lt;&lt;<span class="hljs-string">&quot; block!&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">delete</span> [] data;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Resource::multiply</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> sum = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)&#123;<br>        sum *= data[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>


<ul>
<li>main函数</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;Resource.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::vector&lt;Resource&gt;vc;<br>    vc.<span class="hljs-built_in">reserve</span>(<span class="hljs-number">10</span>);<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;start 1 !&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">10</span>;i++)&#123;<br>        <span class="hljs-comment">//vc.emplace_back(Resource(i));</span><br>        <span class="hljs-comment">//vc.emplace_back(i);</span><br>        <span class="hljs-comment">//vc.push_back(Resource(i));</span><br>        <span class="hljs-comment">//vc.push_back(i);</span><br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;end start 1 !&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-comment">//std::vector&lt;Resource&gt;copy = std::move(vc);</span><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;start 2 !&quot;</span>&lt;&lt;std::endl;<br>    std::vector&lt;Resource&gt;copy = vc;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;start 2 !&quot;</span>&lt;&lt;std::endl;<br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;start del !&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        vc.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;end start del !&quot;</span>&lt;&lt;std::endl;<br><br><br>    std::cout&lt;&lt;<span class="hljs-string">&quot;start del copy!&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>        copy.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;end del copy!&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<ul>
<li>当17行代码被注释掉，15行代码没有被注释掉时，会引发中断</li>
</ul>
<p>原因是因为move操作实际上已经把资源交给了<code>copy</code>来管理，此时的<code>vec</code>已经为空了，下边相当于对一个空的vec进行操作</p>
<p>当使用9时<code>vc.emplace_back(Resource(i))</code>，输出如下</p>
<ul>
<li>为什么emplace没有发挥作用呢？为什么会出现析构呢？</li>
<li>emplace_back 在接受构造器的参数时才会直接在vector中构造对象</li>
<li>而此时相当于给了emplace_back 一个右值 会触发拷贝操作</li>
<li>在右值的前提下 如果有移动拷贝的实现 那么优先使用移动拷贝 如果没有 则使用拷贝构造函数</li>
<li>左值则优先使用拷贝构造函数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs bash">/Users/zs/CLionProjects/Test/cmake-build-debug/Test<br>start 1 !<br>successful gen data with 1 block! <br>move construct fun <span class="hljs-comment"># 移动拷贝函数被调用</span><br>successful delete data with 0 block! <br>successful gen data with 2 block!<br>move construct fun<br>successful delete data with 0 block!<br>successful gen data with 3 block!<br>move construct fun<br>successful delete data with 0 block!<br>successful gen data with 4 block!<br>move construct fun<br>successful delete data with 0 block!<br>successful gen data with 5 block!<br>move construct fun<br>successful delete data with 0 block!<br>successful gen data with 6 block!<br>move construct fun<br>successful delete data with 0 block!<br>successful gen data with 7 block!<br>move construct fun<br>successful delete data with 0 block!<br>successful gen data with 8 block!<br>move construct fun<br>successful delete data with 0 block!<br>successful gen data with 9 block!<br>move construct fun<br>successful delete data with 0 block!<br>successful gen data with 10 block!<br>move construct fun<br>successful delete data with 0 block!<br>end start 1 !<br>start 2 !<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>start 2 !<br>start del !<br>successful delete data with 10 block!<br>successful delete data with 9 block!<br>successful delete data with 8 block!<br>successful delete data with 7 block!<br>successful delete data with 6 block!<br>successful delete data with 5 block!<br>successful delete data with 4 block!<br>successful delete data with 3 block!<br>successful delete data with 2 block!<br>successful delete data with 1 block!<br>end start del !<br>start del copy!<br>successful delete data with 10 block!<br>successful delete data with 9 block!<br>successful delete data with 8 block!<br>successful delete data with 7 block!<br>successful delete data with 6 block!<br>successful delete data with 5 block!<br>successful delete data with 4 block!<br>successful delete data with 3 block!<br>successful delete data with 2 block!<br>successful delete data with 1 block!<br>end del copy!<br><br>Process finished with <span class="hljs-built_in">exit</span> code 0<br></code></pre></td></tr></table></figure>

<p> 因此直接把构造器参数给emplace_back则不会出现多余的析构</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs bash">/Users/zs/CLionProjects/Test/cmake-build-debug/Test<br>start 1 !<br>successful gen data with 1 block!<br>successful gen data with 2 block!<br>successful gen data with 3 block!<br>successful gen data with 4 block!<br>successful gen data with 5 block!<br>successful gen data with 6 block!<br>successful gen data with 7 block!<br>successful gen data with 8 block!<br>successful gen data with 9 block!<br>successful gen data with 10 block!<br>end start 1 !<br>start 2 !<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>copy construct func<br>start 2 !<br>start del !<br>successful delete data with 10 block!<br>successful delete data with 9 block!<br>successful delete data with 8 block!<br>successful delete data with 7 block!<br>successful delete data with 6 block!<br>successful delete data with 5 block!<br>successful delete data with 4 block!<br>successful delete data with 3 block!<br>successful delete data with 2 block!<br>successful delete data with 1 block!<br>end start del !<br>start del copy!<br>successful delete data with 10 block!<br>successful delete data with 9 block!<br>successful delete data with 8 block!<br>successful delete data with 7 block!<br>successful delete data with 6 block!<br>successful delete data with 5 block!<br>successful delete data with 4 block!<br>successful delete data with 3 block!<br>successful delete data with 2 block!<br>successful delete data with 1 block!<br>end del copy!<br><br>Process finished with <span class="hljs-built_in">exit</span> code 0<br><br></code></pre></td></tr></table></figure>

<ul>
<li>而push_back则会构造一个对象，然后放到vector里，因此必然会有一次拷贝</li>
<li>是移动拷贝还是构造器拷贝要看传入的元素是左值类型还是右值类型</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%AC%94%E8%AE%B0/">#笔记</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>c/c++</div>
      <div>http://shuaizhang1998.github.io/2023/09/30/Introductory C Programming Specialization/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Zs</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年9月30日</div>
        </div>
      
      
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/08/19/%E9%80%9A%E8%AE%AF%E5%8D%8F%E8%AE%AE/" title="通讯协议">
                        <span class="hidden-mobile">通讯协议</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
