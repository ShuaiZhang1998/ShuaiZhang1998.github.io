<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ubuntu18.04 搭建图床</title>
    <link href="/2023/07/13/ubuntu18.04-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/"/>
    <url>/2023/07/13/ubuntu18.04-%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>本来想着拿雨雀当图床使，github是正常加载的，但很不幸的，个人博客是不行的，大致检索了一下，要备案<del>你可真甜蜜的是个小机灵鬼啊</del></p><h2 id="步骤">步骤</h2><ul><li>下载PicGo</li><li>配置PicGo上传服务</li></ul><h1 id="下载picgo">下载PicGo</h1><p>地址：https://github.com/Molunerfinn/PicGo/releases</p><p>安装后出现了App损坏的提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo xattr -d com.apple.quarantine <span class="hljs-string">&quot;/Applications/PicGo.app&quot;</span><br></code></pre></td></tr></table></figure><p>这条命令的作用是删除应用程序的 "com.apple.quarantine"扩展属性，以便绕过 macOS 的安全限制。在 macOS上，当你下载并安装一个应用程序时，系统会自动为该应用程序添加"com.apple.quarantine"扩展属性，以确保应用程序的来源可信。如果你信任该应用程序，但是系统仍然给出警告，你可以使用这个命令来删除该扩展属性。请注意，使用这个命令需要管理员权限（sudo），并且需要替换命令中的"/Applications/PicGo.app"为你要删除扩展属性的应用程序的路径。确保你了解应用程序的来源，并且信任该应用程序，因为删除扩展属性可能会带来安全风险。</p><h1 id="配置picgo上传服务">配置PicGo上传服务</h1><h2 id="使用github">使用Github</h2><p>主要参照这篇文章：https://zhuanlan.zhihu.com/p/553533337</p><ul><li>创建一个新的仓库</li><li>设置开发者key</li><li>填信息即可</li></ul><p><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131431872.png" /></p><p><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/block/DALL.png" /></p><p>typora可以设置图床服务</p><h2 id="使用个人服务器">使用个人服务器</h2><p>github很简单了，还免费，为啥还要搞捏，这要讨论到一片有趣的博文了。</p><p><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/block/20230713092541.png" /></p><p>基本上要做两件事</p><ul><li><p>配置图片存储服务端</p></li><li><p>配置PicGo配置文件</p><h2 id="图片存储服务器端">图片存储服务器端</h2><p>想象一下别人家的图床开头一般都是http://啥的，很明显所谓的图床服务其实就是架设了一个<strong>web服务器</strong>。因此我们需要做两件事情</p><ul><li><p>创建一个物理存储目录</p></li><li><p>使用Nginx做一个路径转发</p><h3 id="物理存储目录的创建">物理存储目录的创建</h3><p>别在root用户里搞，只有root账户的话创建一个新的用户&lt;username&gt;，放到sudo组里,然后登陆这个用户开始下一步；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo usermod -aG sudo &lt;username&gt;<br></code></pre></td></tr></table></figure><p>创建实际存储文件的文件夹，一般就是在你home/user下创建；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir /home/zs/blog/BlogImage/img2<br>chown -R zs:zs blog<br>chmod -R 777 blog<br></code></pre></td></tr></table></figure><h3 id="使用nginx做路径转发">使用Nginx做路径转发</h3><p>坑主要就在这了，很多博客都假定你是有域名和ssl的，但我觉得大多数人应该没兴趣去备案啥的...</p><p>这个部分也有两部组成</p><ul><li><p>安装Nginx</p></li><li><p>修改配置文件</p><h4 id="安装nginx">安装Nginx</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ubuntu 18.04哈</span><br>sudo apt update<br>sudo apt install nginx<br></code></pre></td></tr></table></figure><p>安装完后会自启动，直接开始下一步，修改配置文件</p><h4 id="修改配置文件">修改配置文件</h4><p><del>我们没有域名，没有ssl，配置起来很简单。</del></p><p>它的逻辑就是当你请求http://host/figname时，Nginx会进行重定向，并返回给你服务器中/home/zs/blog/BlogImage/img2/figname的资源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/nginx/nginx.conf<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在http块里加一个server块</span><br>server &#123;<br>                listen 80;<br>                server_name x.x.x.x;<br>                location / &#123; <br>                        alias /home/zs/blog/BlogImage/img2/;<br>                        autoindex on;<br>                        autoindex_exact_size off;<br>                &#125;<br>        &#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="配置picgo配置文件">配置PicGo配置文件</h1><p>具体而言你需要准备如下一个json。如果你和我一样没有域名，那我觉得这件事情，泰酷辣！</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">&quot;pool1&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;http://x.x.x.x&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/&#123;fullName&#125;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;uploadPath&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/home/zs/blog/BlogImage/img2/&#123;fullName&#125;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;host&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;x.x.x.x&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;username&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;--&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;password&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;--&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>环境配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>导致师弟被喷的比赛小项目</title>
    <link href="/2023/06/25/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84AI%E6%AF%94%E8%B5%9B/"/>
    <url>/2023/06/25/%E8%96%9B%E5%AE%9A%E8%B0%94%E7%9A%84AI%E6%AF%94%E8%B5%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>学校这次似乎承办省人工智能大赛，本来这种勾儿东西我一贯不感兴趣，然鹅老师非要我们碰一碰，所以我们就碰了一碰，然后师弟答辩被一条老狗喷了，老狗说了一句很有水平的话，<del>“人家准确率都是90好几，你们七十八是个啥玩意？,就这也好意思来参加比赛啊？”</del>我初衷就是想玩一波视觉角度的few-shoot，那确实我们就训练了一轮得到一个78的top1验准率挺低的，你说的都对。也怪我不该让师弟一个人去答辩，毕竟代码是我一拍脑袋写的。本着虚心请教的想法看了看这位某防科大的高知的学术成果，一堆EI，挺厉害的，为了不被毕业卡到，拿我当时投CCFB失败的一篇文章混了个EI我谴责了自己好久，也不知道这位佬是个啥情况。</p><h1 id="答辩前一天给师弟画的图">答辩前一天给师弟画的图</h1><p>1.这个项目在做什么？</p><p>根据图片判断肺炎严重程度</p><p>2.怎么量化一个人肺炎严不严重</p><p>病灶的数量+肉眼不可见<strong>某种抽象特征</strong></p><p>3.MAE流程（预训练+训练分类器）</p><p>3.1<strong>预训练</strong>时结构为ENCODER+DECODER，通过一张图片的<strong>随机子块</strong>重建<strong>整张图片</strong></p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131601385.jpeg"alt="IMG_C4753C658AE6-1" /><figcaption aria-hidden="true">IMG_C4753C658AE6-1</figcaption></figure><p>ENCODER<strong>只接受</strong>图片的<strong>随机子块</strong>，所以ENCODER可以训练的很大。</p><p>DECODER<strong>只接受</strong>ENCODER的输出，DECODER会输出一个和输入<strong>一摸一样大小</strong>的输出，这个输出按照如下方式构建：</p><ul><li>按照输入随机子块的位置，把ENCODER对应的输出放上去（两块粉的）</li><li>其余灰色的位置，初始化一块变量，复制到所有其他位置（10块灰的）</li></ul><p>最后计算DECODER的输出和ENCODER的输入之间的均方误差MSE</p><p>3.2<strong>训练分类器</strong>时只要ENCODER，然后在后边加个全连接</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131601246.jpeg"alt="IMG_8409BB4122B8-1" /><figcaption aria-hidden="true">IMG_8409BB4122B8-1</figcaption></figure><p>4.我们做了什么</p><p>4.1收集肺炎数据集，对肺炎数据集进行大小的调整</p><p>4.2构建MAE模型，加载在imagenet上预训练的<strong>编码器</strong>权重，自己构造了一个小的解码器，并在肺炎数据集上进行了微调</p><p>4.3拿掉解码器，添加分类器，只训练一次（单张3090训练MAE非常慢，尽管MAE相较于传统的模型已经很小了）</p><p>4.4在训练集以及测试集上达到了很好的准确率</p><p>5.详细的结构</p><p>说白了就是transformer堆叠而成的编码器和解码器</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131601749.png"alt="image-20230625222951972" /><figcaption aria-hidden="true">image-20230625222951972</figcaption></figure><p>一摸一样，一点不带差的，这个InputEmbedding接受的就是那两块粉的，位置编码就是ViT的位置编码，他要问问位置编码，你就说是ViT架构的位置编码就行，他在问咋实现的，你就说用可学习的变量和随机子块相加。</p><p>那一块一块粉的，叫patches，就这么切的。一张图有由三个通道组成，说白了就每个图像的通道（矩阵）扣一块出来，所以一个patches的大小就是n*m*3,一般n和m相等。然后在reshape成一个（n*m*3/k,k）的向量组，标准化一下，就可以直接扔到transformer里边了。</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131602215.jpeg"alt="IMG_C3BE92416F0F-1" /><figcaption aria-hidden="true">IMG_C3BE92416F0F-1</figcaption></figure><h1 id="代码">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 载入需要的库 </span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> ViTImageProcessor, ViTModel,AutoFeatureExtractor,ViTMAEForPreTraining<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoImageProcessor, ResNetForImageClassification<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> ViTForImageClassification<br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch.utils.data <span class="hljs-keyword">as</span> data<br><span class="hljs-keyword">import</span> torchvision.transforms <span class="hljs-keyword">as</span> transforms<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> AdamW<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> get_scheduler<br><span class="hljs-keyword">from</span> tqdm.auto <span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-comment"># 至今也不理解为啥装两块不一样的卡 用3090</span><br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>) <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)<br>os.environ[<span class="hljs-string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>] = <span class="hljs-string">&quot;0&quot;</span><br>train = <span class="hljs-string">&quot;/home/temp2/train&quot;</span><br>test = <span class="hljs-string">&quot;/home/temp2/test&quot;</span><br>LABEL = <span class="hljs-string">&quot;/home/temp2/train.csv&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 数据集是图片，封装成dataset</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomImageDataset</span>(data.Dataset):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, root_dir, transform=<span class="hljs-literal">None</span></span>):<br>        self.root_dir = root_dir<br>        self.transform = transform<br>        self.image_paths = []<br>        labEl = pd.read_csv(LABEL,header=<span class="hljs-literal">None</span>)<br>        <br>        self.my_dict = &#123;k: v <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(<span class="hljs-built_in">list</span>(labEl[<span class="hljs-number">0</span>]), <span class="hljs-built_in">list</span>(labEl[<span class="hljs-number">1</span>]))&#125;<br>        <span class="hljs-keyword">for</span> subdir, _, files <span class="hljs-keyword">in</span> os.walk(root_dir):<br>            <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> files:<br>                <span class="hljs-keyword">if</span> file.endswith(<span class="hljs-string">&#x27;.jpg&#x27;</span>) <span class="hljs-keyword">or</span> file.endswith(<span class="hljs-string">&#x27;.png&#x27;</span>):<br>                    self.image_paths.append(os.path.join(subdir, file))<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.image_paths)<br><span class="hljs-comment"># 这数据也挺搞得，放一个目录里，标签也没给，不然不需要自定义Dataset类的    </span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, index</span>):<br>        image_path = self.image_paths[index]<br>        label = os.path.basename(image_path)<br>        label = self.my_dict[<span class="hljs-built_in">int</span>(label[:-<span class="hljs-number">4</span>])]<br>        image = Image.<span class="hljs-built_in">open</span>(image_path).convert(<span class="hljs-string">&#x27;RGB&#x27;</span>)<br>        <span class="hljs-keyword">if</span> self.transform <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            image = self.transform(image)<br>        <span class="hljs-keyword">return</span> image, label<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">Dir</span>):<br>    <span class="hljs-comment"># Define the root directory of the custom image dataset</span><br>    root_dir = Dir<br>    <span class="hljs-comment"># Create a CustomImageDataset object</span><br>    <span class="hljs-comment"># 按照VIT的标准化范式调整</span><br>    custom_dataset = CustomImageDataset(root_dir, transform=transforms.Compose([<br>        transforms.Resize((<span class="hljs-number">224</span>, <span class="hljs-number">224</span>)),<br>        <span class="hljs-comment">#transforms.CenterCrop(224),</span><br>        transforms.ToTensor(),<br>        transforms.Normalize((<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>), (<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>))<br>    ]))<br><br><span class="hljs-comment"># Use DataLoader to load the custom image dataset</span><br>    dataloader = data.DataLoader(custom_dataset, batch_size=<span class="hljs-number">32</span>, shuffle=<span class="hljs-literal">True</span>, num_workers=<span class="hljs-number">4</span>)<br>    <span class="hljs-keyword">return</span> dataloader<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">processor = ViTImageProcessor.from_pretrained(<span class="hljs-string">&#x27;facebook/vit-mae-base&#x27;</span>)<br>model = ViTForImageClassification.from_pretrained(<span class="hljs-string">&#x27;facebook/vit-mae-base&#x27;</span>,num_labels=<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># 当时做了下梦</span><br><span class="hljs-comment"># processor = ViTImageProcessor.from_pretrained(&#x27;google/vit-base-patch16-224-in21k&#x27;)</span><br><span class="hljs-comment"># model = ViTModel.from_pretrained(&#x27;google/vit-base-patch16-224-in21k&#x27;,num_labels=5)</span><br><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">dataloader = get_data(test)<br>optimizer = AdamW(model.parameters(), lr=<span class="hljs-number">0.001</span>)<br>num_epochs = <span class="hljs-number">1</span><br><span class="hljs-comment"># 一轮咱也要预热哈哈哈，其实没用</span><br>num_training_steps = num_epochs * <span class="hljs-built_in">len</span>(dataloader)<br>lr_scheduler = get_scheduler(     name=<span class="hljs-string">&quot;linear&quot;</span>, optimizer=optimizer, num_warmup_steps=<span class="hljs-number">0</span>, num_training_steps=num_training_steps<br>)<br>model.train()<br>model.to(device)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">model = model.to(device)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> batch,label <span class="hljs-keyword">in</span> dataloader:<br>       <span class="hljs-comment"># print(batch)</span><br>        batch = batch.to(device)<br>        label = label.to(device)<br>        outputs=model(batch)<br>        loss = F.cross_entropy(outputs[<span class="hljs-string">&#x27;logits&#x27;</span>], label)<br>        loss.backward()<br>        optimizer.step()<br>        lr_scheduler.step()<br>        optimizer.zero_grad()<br>PATH = <span class="hljs-string">&quot;mae_1_epoch&quot;</span><br>torch.save(model.state_dict(), PATH)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 一轮也有好坏～</span><br>PATH = <span class="hljs-string">&quot;mae_1_epoch_best&quot;</span><br>model.load_state_dict(torch.load(PATH))<br>device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>model.to(device)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment"># 为了装skl我还重新整了个镜像，自从推出运维后天知道宿主机经历了什么</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> confusion_matrix, accuracy_score, precision_score, recall_score, f1_score<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate</span>(<span class="hljs-params">model, dataloader</span>):<br>    <span class="hljs-comment"># 设置模型为评估模式</span><br>    model.<span class="hljs-built_in">eval</span>()<br>    model.to(device)<br>    <span class="hljs-comment"># 定义损失函数</span><br>    criterion = F.cross_entropy<br>    <span class="hljs-comment"># 定义记录变量</span><br>    predictions = []<br>    targets = []<br>    losses = []<br>    <span class="hljs-comment"># 遍历数据集</span><br>    <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> dataloader:<br>        <span class="hljs-comment"># 将数据加载到设备上</span><br>        images, labels = images.to(device), labels.to(device)<br>        <span class="hljs-comment"># 前向计算</span><br>        outputs = model(images)<br>        loss = criterion(outputs[<span class="hljs-string">&#x27;logits&#x27;</span>], labels)<br>        <span class="hljs-comment"># 记录损失和预测结果</span><br>        losses.append(loss.item())<br>        predictions.append(torch.argmax(outputs[<span class="hljs-string">&#x27;logits&#x27;</span>], dim=<span class="hljs-number">1</span>).cpu().numpy())<br>        targets.append(labels.cpu().numpy())<br>    <span class="hljs-comment"># 计算各项指标</span><br>    predictions = np.concatenate(predictions)<br>    targets = np.concatenate(targets)<br>    acc = accuracy_score(targets, predictions)<br>    precision = precision_score(targets, predictions, average=<span class="hljs-string">&#x27;macro&#x27;</span>)<br>    recall = recall_score(targets, predictions, average=<span class="hljs-string">&#x27;macro&#x27;</span>)<br>    f1 = f1_score(targets, predictions, average=<span class="hljs-string">&#x27;macro&#x27;</span>)<br>    cm = confusion_matrix(targets, predictions)<br>    <span class="hljs-comment"># 输出结果</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Loss: &#123;:.5f&#125;, Accuracy: &#123;:.5f&#125;, Precision: &#123;:.5f&#125;, Recall: &#123;:.5f&#125;, F1: &#123;:.5f&#125;&quot;</span>.<span class="hljs-built_in">format</span>(<br>        np.mean(losses), acc, precision, recall, f1))<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Confusion Matrix:&quot;</span>)<br>    <span class="hljs-built_in">print</span>(cm)<br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131611773.png" /></p><h1 id="总结">总结</h1><p>老狗必炸</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim远程拷贝</title>
    <link href="/2023/06/20/vim%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D/"/>
    <url>/2023/06/20/vim%E8%BF%9C%E7%A8%8B%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>最近由于在写cs144的lab一直在和vim打交道，然后就诞生出了一个莫名其妙的需求，如何从服务器的vim中复制到我本地的剪贴板上？然后我搜索到了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ggvG+y<br></code></pre></td></tr></table></figure><p>没错，这东西根本没用啊，它是复制到了服务器本地的寄存器上...然后发现了这篇神奇的文章</p><p>https://flogx.com/post/vim-remote-copy/</p><h2 id="修改本机ssh设置">修改本机ssh设置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim ~/.ssh/config<br></code></pre></td></tr></table></figure><p>然后添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Host *<br>    RemoteForward 22222 127.0.0.1:22222<br></code></pre></td></tr></table></figure><p>**这段配置的意义是使用 SSH 登录任何主机时（Host *），将主机本地的22222 端口（RemoteForward 22222）映射到远程主机的 127.0.0.1:22222地址上。**</p><h2 id="修改服务器的vim配置文件">修改服务器的Vim配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ~<br>vim .vimrc<br></code></pre></td></tr></table></figure><p>然后添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">function! s:send2net()<br>    let ch = ch_open(&#x27;127.0.0.1:22222&#x27;)<br>    if ch_status(ch) != &quot;open&quot;<br>        echomsg &quot;Failed to open channel, status = &quot; .. ch_status(sh)<br>    endif<br>    call ch_sendraw(ch, getreg(&#x27;&quot;&#x27;))<br>endfunction<br><br>augroup send2net<br>    au!<br>    au TextYankPost * if v:event.operator ==# &#x27;y&#x27; | call s:send2net() | endif<br>augroup END<br></code></pre></td></tr></table></figure><p><strong>这段配置的意义是在触发vim的y（复制）操作时，将内容发送到本地的22222端口，在前边我们已经将本机和服务器的22222端口进行了绑定。</strong></p><h2 id="配置mac系统">配置mac系统</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat &gt; $HOME/Library/LaunchAgents/pbcopy.plist &lt;&lt; END<br></code></pre></td></tr></table></figure><p>添加如下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE plist PUBLIC &quot;-//Apple Computer//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;<br>&lt;plist version=&quot;1.0&quot;&gt;<br>    &lt;dict&gt;<br>        &lt;key&gt;Label&lt;/key&gt;<br>            &lt;string&gt;localhost.pbcopy&lt;/string&gt;<br>        &lt;key&gt;ProgramArguments&lt;/key&gt;<br>        &lt;array&gt;<br>            &lt;string&gt;/usr/bin/pbcopy&lt;/string&gt;<br>        &lt;/array&gt;<br>        &lt;key&gt;inetdCompatibility&lt;/key&gt;<br>        &lt;dict&gt;<br>            &lt;key&gt;Wait&lt;/key&gt;<br>            &lt;false/&gt;<br>        &lt;/dict&gt;<br>        &lt;key&gt;Sockets&lt;/key&gt;<br>        &lt;dict&gt;<br>            &lt;key&gt;Listeners&lt;/key&gt;<br>            &lt;dict&gt;<br>                &lt;key&gt;SockServiceName&lt;/key&gt;<br>                &lt;string&gt;22222&lt;/string&gt;<br>                &lt;key&gt;SockNodeName&lt;/key&gt;<br>                &lt;string&gt;127.0.0.1&lt;/string&gt;<br>            &lt;/dict&gt;<br>        &lt;/dict&gt;<br>    &lt;/dict&gt;<br>&lt;/plist&gt;<br>END<br></code></pre></td></tr></table></figure><p>加载配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">launchctl load -w $HOME/Library/LaunchAgents/pbcopy.plist<br></code></pre></td></tr></table></figure><p>检查配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">launchctl list | grep localhost.pbcopy<br></code></pre></td></tr></table></figure><p><strong>这段配置的意义就是监听本地22222端口的链接，并把数据复制到剪贴板中（pbcopy）。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GPT2的心情好不好呢？</title>
    <link href="/2023/06/04/bad_boy_gpt/"/>
    <url>/2023/06/04/bad_boy_gpt/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>到现在为止许多人已经体验到ChatGPT的强大威力了，它有非常多的缺点，例如幻觉，今天在写简历的时候，我想检查一下自己论文标题的拼写是否正确，<del>补全和竞赛这个单词我经常搞混...</del>，于是我话费了我宝贵的数十个tokens输入了我论文的名称：singlecell imputation via adaptive matrixcompletion，然后它对我进行了以下的回复：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gauss">单细胞测序数据中存在许多缺失值，这对下游分析和解释造成了很大的困难。为了解决这个问题，研究人员提出了一种称为自适应矩阵完成（Adaptive <span class="hljs-keyword">Matrix</span> Completion）的方法，用于单细胞数据的缺失值填充。<br><br>自适应矩阵完成方法是一种基于矩阵分解的方法，它使用低秩矩阵分解来对单细胞数据进行建模。该方法首先利用已知数据来训练一个低秩矩阵模型，然后使用该模型来推断未知的数据点。该方法还使用自适应权重来调整矩阵分解模型，以适应不同的细胞和基因之间的差异。<br><br>具体来说，该方法为每个基因和每个单元格计算一组权重，这些权重可以反映该基因或单元格与其他基因或单元格之间的相关性。然后，这些权重被用于调整矩阵分解模型，以更好地适应数据的不同特征。<br><br>该方法在多个真实数据集上进行了测试，并与其他现有方法进行了比较。结果表明，自适应矩阵完成方法在单细胞数据的缺失值填充方面表现出色，并且可以提高下游分析的准确性和可靠性。<br></code></pre></td></tr></table></figure><p>如果不了解的人呢，可能会被忽悠到了，但是我的方法和矩阵分解压根就没有关系，但你说它完全bullshit，也不是，为啥呢？首先矩阵完成这个任务我觉得做信号处理或者服务推荐的人应该并不陌生，例如Netflix曾经花了一百万悬赏那些能够解决他们推荐问题的人，当年的冠军算法中就有矩阵分解的影子。矩阵补全框架中<strong>确实有</strong>一种<strong>基于矩阵分解</strong>的<strong>矩阵完成算法</strong>。自适应权重也是瞎扯吗？也不是，那我的论文确实和自适应参数有关系，也确实用了自适应权重调整模型，不过不是基于矩阵分解的就对了...具体来说这部分呢，嗯...，一股浓浓的的scImpute（NC的文章，感兴趣谷歌学术搜索，scRNA-seqscImpute）的味道，最后一段呢，太熟悉了。</p><p>所以他是<strong>瞎扯</strong>吗？我倾向于不是，如果你对某个领域有比较深入的了解的话，实际上它还是可以为你带来很多帮助的。但如果你对某个领域完全未知，那确实很容易被带跑偏了。所以重点的就来了，ChatGPT在初始训练阶段还是沿用了GPT2的方案，吃了大量的数据，所以我们其实可以把ChatGPT看成一个对世界所有文字信息<del>（期待那一天的到来）</del>的压缩模型，在不进行promote以及使用HMRF进行有害性的控制前，你给定一段输入，那么它会返回给你最能匹配训练数据分布的一组输出。<strong>有趣的终于来了</strong></p><h1 id="我对你好你会对我好吗">我对你好，你会对我好吗？</h1><p>在这里我们设计一个场景，我们不断的对GPT2说你好，GPT2的回答，是消极占比多呢？</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-number">1</span>.CV hugging <span class="hljs-built_in">face</span>中GPT2以及随便一个用于情绪文本分类的模型<br><span class="hljs-number">2</span>.不断的对GPT2说你好<br><span class="hljs-number">3</span>.记录GPT的回答，分数，以及是积极还是消极<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline, set_seed<br>set_seed(<span class="hljs-number">3</span>)<br>classifier = pipeline(<span class="hljs-string">&quot;sentiment-analysis&quot;</span>)<br>generator = pipeline(<span class="hljs-string">&#x27;text-generation&#x27;</span>, model=<span class="hljs-string">&#x27;gpt2&#x27;</span>)<br>res = []<br>num_p = <span class="hljs-number">0</span><br>num_n = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ans:<br>    ansers = <span class="hljs-built_in">str</span>(i[<span class="hljs-string">&#x27;generated_text&#x27;</span>])<br>    label  = classifier(ansers)<br>    res.append([label[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;label&#x27;</span>],ansers])<br>    <span class="hljs-keyword">if</span>(label[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;label&#x27;</span>]==<span class="hljs-string">&#x27;POSITIVE&#x27;</span>):<br>        num_p = num_p +  <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span>(label[<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;label&#x27;</span>]==<span class="hljs-string">&#x27;NEGATIVE&#x27;</span>):<br>        num_n = num_n +  <span class="hljs-number">1</span> <br><span class="hljs-built_in">print</span>(num_n/(num_p+num_n))<br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131515262.png" /></p><p>啊这<sub>看来它的情绪不太好啊，众所周知深度学习的基石是随机数种子</sub>~，那么我们来测试下1-100的随机数种子吧</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> norm<br>plt.title(<span class="hljs-string">&#x27;Probability with different seed&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;seed&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Probability&#x27;</span>)<br>x = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>)<br>pdf = norm.pdf(x, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>cdf = norm.cdf(x, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>plt.plot(x, res, label=<span class="hljs-string">&#x27;n/(p+n)&#x27;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131516851.png" /></p><p>嗯，说实话这个图看起来还是有点问题的，来画个小提琴看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> sns<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data = np.asarray(res)<br>sns.violinplot(y=data)<br>plt.xlabel(<span class="hljs-string">&#x27;Distribution&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;n/(p+n)&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Violin Plot&#x27;</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><p><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131516422.png" /></p><p>所以我们基本可以说，GPT2的心情似乎不太好哦～不过其实有个问题在这里，就是我们的分类器到底会把什么样的样本看作是Positive，什么样的样本看作Negative的呢？后边慢慢再继续研究～</p><h1 id="我对你不好你会对我好吗">我对你不好，你会对我好吗？</h1><p><del>如果我说了一些不太好的话，那么阁下又当如何应对呢？</del>问题来了，说啥呢？说这两句话，第二句我就....直接给出小提琴图吧。</p><p>1.you are not cool !</p><p>2.F###</p><p><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131517043.png" /></p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131517382.png"alt="image-20230606160231718" /><figcaption aria-hidden="true">image-20230606160231718</figcaption></figure><p>那么均值已经在0.8了，所以你说了不那么cool的话，那么大概率不会得到太好的回复<del>（你会被喷回去）</del>。所以当我们对GPT2打招呼时，平均来说有<strong>42%</strong>的概率会得到一些算法认为不那么“积极”的回复；那么如果你直接告诉GPT2它不裤的话，<strong>80%</strong>的概率会被GPT2“友好”的回复，但你如果直接喷它，诶？<strong>67%</strong>的概率得到Negative的回答，这就很魔性了<del>舔狗一无所有？</del>。这其实告诉我们，为什么GPT4.0要在甚至会降低模型在评估任务上的效能的前提下，还要花那么多功夫做有害性控制。虽然不知道原因，但GPT系列起码是2来说，确实不那么正能量。<del>都和你说你好了，你还要PUA我！</del></p><h1 id="gpt2用了什么数据训练">GPT2用了什么数据训练？</h1><p>先把huggingface中的话复制下来：</p><p>The OpenAI team wanted to train this model on a corpus as large aspossible. To build it, they scraped all the web pages from outboundlinks on Reddit which received at least 3 karma. Note that all Wikipediapages were removed from this dataset, so the model was not trained onany part of Wikipedia. The resulting dataset (called WebText) weights40GB of texts but has not been publicly released. You can find a list ofthe top 1,000 domains present in WebText here.</p><p>所以GPT2的训练数据主要是从reddit上爬下来的，要求Karma值在3以上的帖子才会被纳入训练。我们去看看论文中怎么写的</p><p>The resulting dataset, WebText, contains the text subset of these 45million links. To extract the text from HTML responses we use acombination of the Dragnet (Peters &amp; Lecocq, 2013) and Newspaper1content extractors. All re- sults presented in this paper use apreliminary version of WebText which does not include links createdafter Dec 2017 and which after de-duplication and some heuristic basedcleaning contains slightly over 8 million documents for a total of 40 GBof text.</p><p>和huggingface上的描述差不多，爬下来的数据还做了一些清理，约800万个文档，40GB的文本，换算过来每一万个文档有0.05个GB，每一个文档52MB，如果使用unicode编码的话，一个字4Bytes，一个文档大约一千万字，这还是挺恐怖的...星辰变大概是200万字，一个文档大约等于5本小说，八百万乘以500...</p><h1 id="总结">总结</h1><p>我们的提问其实可以不严谨的分为三种情绪。</p><ul><li>态度良好的试探性语句</li><li>不太礼貌的批判性语句</li><li>带有极强攻击性的语句</li></ul><p>三者所得到的回复被判定为消极性回复的比例分别是：40%，80%，67%。假如我们是个贪心的人，希望尽可能多的得到别人积极的回复。我们有时候会态度良好的对他人进行试探，我们有时候会不太礼貌的对他人进行批判，心情比较糟糕的时候会对他人进行攻击，为了最大化我们的目标，我们要尽可能多的以礼待人，或者需要让别人意识到我们具有极强的攻击性，以及尽可能不要<del>阴阳怪气别人</del>。</p><p>做个彬彬有礼的人，必要时刻要亮出你自己的爪牙，与你无关的事不要乱掺和。</p>]]></content>
    
    
    
    <tags>
      
      <tag>头脑风暴</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>力扣</title>
    <link href="/2023/06/02/%E5%8A%9B%E6%89%A3/"/>
    <url>/2023/06/02/%E5%8A%9B%E6%89%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p>leetcode会自动清除提交过的代码<del>看看人家洛谷，一年前的还留着呢</del>，对于我这个资深bug师来说那可是毁灭性的。开始记录吧，以后开三个帖子，一个挂leetcode，一个挂洛谷，一个挂PAT吧。</p><h2 id="最长的回文子串">最长的回文子串</h2><p>给你一个字符串 <code>s</code>，找到 <code>s</code>中最长的回文子串。</p><p>如果字符串的反序与原始字符串相同，则该字符串称为回文字符串。</p><p><strong>示例 1：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;babad&quot;<br>输出：&quot;bab&quot;<br>解释：&quot;aba&quot; 同样是符合题意的答案。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">输入：s = &quot;cbbd&quot;<br>输出：&quot;bb&quot;<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><h3 id="分析">分析</h3><p>看到这个数据范围我上来想都没想直接暴力，然后挂了，嗯。枚举回文子串的长度，枚举回文子串的开头，然后再判断是不是回文，记录最大结果。这道题有一种很巧妙<del>不想看</del>的做法，那么给出正解。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">//枚举每个可能会回文子串的中心点【当回文子串是偶数时枚举的是中心没有元素的位置】</span><br>    <span class="hljs-comment">//向两边展开，记录最大长度</span><br>    <span class="hljs-comment">//维护一个最大长度，更大时替换子串，子串为从【i-（len-1）/2，len】 </span><br>    <span class="hljs-function">string <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s.<span class="hljs-built_in">size</span>()==<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> s;<br>    <span class="hljs-type">short</span> max_len = <span class="hljs-number">-1</span>;<br>    string res = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;s.<span class="hljs-built_in">size</span>();++i)&#123;<br>        <span class="hljs-type">short</span> len1 = <span class="hljs-built_in">num</span>(s,i,i); <br>        <span class="hljs-type">short</span> len2 = <span class="hljs-built_in">num</span>(s,i,i+<span class="hljs-number">1</span>);<br>        <span class="hljs-type">short</span> len = <span class="hljs-built_in">max</span>(len1,len2);<br>        <span class="hljs-keyword">if</span>(len&gt;max_len)&#123;<br>            res = s.<span class="hljs-built_in">substr</span>(i-(len<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>,len);<br>            max_len = len;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">short</span> <span class="hljs-title">num</span><span class="hljs-params">(string s,<span class="hljs-type">short</span> l,<span class="hljs-type">short</span> r)</span></span>&#123;<br>        <span class="hljs-keyword">while</span>(l&gt;=<span class="hljs-number">0</span> &amp;&amp; r&lt;s.<span class="hljs-built_in">size</span>()&amp;&amp;s[l]==s[r])&#123;<br>            l--;<br>            r++;<br>        &#125;<br>        <span class="hljs-keyword">return</span> r-l<span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>这道题比较抽象的地方应该就在于回文子串的长度是偶数了吧，其<spanclass="math inline">\(len1 = num(s,i,i)\)</span>比较好理解，对<spanclass="math inline">\(i\)</span>两边进行扩散，可以求出以<spanclass="math inline">\(i\)</span>为中心的最长回文子串长度，而且这个数一定是个奇数，假设对于某个位置<spanclass="math inline">\(i\)</span>满足了条件，并且迭代了<spanclass="math inline">\(k\)</span>次，那么$ l = i-k ,r = i+k,r-l-1 = 2k -1<span class="math inline">\(，导致这种方式只能得到以\)</span>i<spanclass="math inline">\(为中心的**最长奇数回文子串**。所以我们还需要考虑到以\)</span>i<spanclass="math inline">\(和\)</span>i+1<spanclass="math inline">\(为中心的**最长偶数回文子串**，可以通过\)</span>len2=num(s,i,i+1)<spanclass="math inline">\(的方式来得到，那么套用上边的计算方法可以得到\)</span>r-l-1= 2k<spanclass="math inline">\(。那么我们只需要比较两种方案的长度，维护一个最大长度\)</span>max_len<spanclass="math inline">\(，当前情况更大时对字符串作截取就可以。那么这就涉及到了两种情况，怎么根据\)</span>i<spanclass="math inline">\(和\)</span>max_len$来确定这个回文子串呢？</p><p>我们使用<spanclass="math inline">\(substr(start，end)\)</span>函数来对字符串进行截断，需要注意的是<spanclass="math inline">\(substr\)</span>函数是属于左闭右开的形式，也就是<spanclass="math inline">\(start\)</span>位置的串会被取到，而<spanclass="math inline">\(end\)</span>位置的串不会被取到。在这个前提下我们考虑这个问题，当<spanclass="math inline">\(max\_len\)</span>为奇数时，<spanclass="math inline">\(i\)</span>代表了当前结果的中心位置，串的长度是<spanclass="math inline">\(max\_len\)</span>，所以我们需要向<spanclass="math inline">\(i\)</span>所在的位置向左偏移<spanclass="math inline">\((max\_len-1)/2\)</span> 个位置，向右偏移<spanclass="math inline">\((max\_len-1)/2\)</span> 个位置。</p><p>当<span class="math inline">\(max\_len\)</span>为偶数时，假如<spanclass="math inline">\(i\)</span>此时位于会文子串中间不存在的位置记为<spanclass="math inline">\(i*\)</span>，那么我们需要向左以及向右移动<spanclass="math inline">\((max\_len)/2\)</span>个位置，因为这个位置不存在，所以我们只能把<spanclass="math inline">\(i\)</span>放在<spanclass="math inline">\(i*\)</span>偏左或者偏右的位置，一般我们习惯于放在偏左的位置，因为这个位置的索引等<spanclass="math inline">\(max\_len/2\)</span>，所以我们需要向左移动<spanclass="math inline">\((max\_len-1)/2\)</span> 个位置，向右移动<spanclass="math inline">\((max\_len)/2\)</span> 个位置。</p><p>因为我们实际上枚举的是以<spanclass="math inline">\(i\)</span>为中心向左右拓展的会文子串，因此靠右的位置我们只需要令其为会文子串的长度<spanclass="math inline">\(max\_le n\)</span>就好。为什么是<spanclass="math inline">\(max\_len\)</span>而不需要减1呢，索引是从0开始的啊。因为substr采用的是左闭右开的形式，右边多一个位置没关系～</p><h3 id="总结">总结</h3><h2 id="下一个排列">下一个排列</h2><p>整数数组的一个 <strong>排列</strong>就是将其所有成员以序列或线性顺序排列。</p><ul><li>例如，<code>arr = [1,2,3]</code> ，以下这些都可以视作<code>arr</code>的排列：<code>[1,2,3]</code>、<code>[1,3,2]</code>、<code>[3,1,2]</code>、<code>[2,3,1]</code>。</li></ul><p>整数数组的 <strong>下一个排列</strong>是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的<strong>下一个排列</strong>就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</p><ul><li>例如，<code>arr = [1,2,3]</code> 的下一个排列是 <code>[1,3,2]</code>。</li><li>类似地，<code>arr = [2,3,1]</code> 的下一个排列是<code>[3,1,2]</code> 。</li><li>而 <code>arr = [3,2,1]</code> 的下一个排列是 <code>[1,2,3]</code>，因为 <code>[3,2,1]</code> 不存在一个字典序更大的排列。</li></ul><p>给你一个整数数组 <code>nums</code> ，找出 <code>nums</code>的下一个排列。</p><p>必须 <ahref="https://baike.baidu.com/item/原地算法"><strong>原地</strong></a>修改，只允许使用额外常数空间。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：nums = [1,2,3]<br>输出：[1,3,2]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：nums = [3,2,1]<br>输出：[1,2,3]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">输入：nums = [1,1,5]<br>输出：[1,5,1]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="分析-1">分析</h3><p>这个问题首先要清楚什么是<strong>字典序，</strong>现在我们有一个字符串，['1','2','3']。那么它的字典序实际上是一个整数序列[49，50，51]。这道题实际叙述的并不好，其实就是：</p><p>**需要找到一个比当前字符串更大的典序$ S* <spanclass="math inline">\(，而不存在任何一个字典序满足比原字典序更大而比\)</span>S*<span class="math inline">\(更小的字典序\)</span>^{sub}$。**</p><p>那么我们该如何找到这样的<spanclass="math inline">\(S*\)</span>呢？，假如题目要求的不是我们对<spanclass="math inline">\(nums\)</span>排序的话，我们只需要把<spanclass="math inline">\(nums\)</span>看作一个整数，然后加1就是要求的结果。然而题目要求我们通过对<spanclass="math inline">\(nums\)</span>排序来使得找到字典序<spanclass="math inline">\(S*\)</span>。</p><p>为了使得字典序变高，很明显我们需要把某一位置的元素变为字典序更大的元素，而这个操作只能通过交换来完成。我们把交换的元素记作<spanclass="math inline">\(A[L],A[R]\)</span>，为了满足条件<spanclass="math inline">\(^{sub}\)</span>，我们需要<spanclass="math inline">\(R\)</span>尽可能的大，同时我们希望<spanclass="math inline">\(A[L]\)</span>恰好小于<spanclass="math inline">\(A[R]\)</span>，交换完成后我们要令<spanclass="math inline">\(A[L]&#39;\)</span>之后的位置升序（使得交换后的大序列更小）。</p><p>首先寻找<spanclass="math inline">\(A[L]\)</span>,从后向前扫描，只要满足<spanclass="math inline">\(A[i]&lt;A[i+1]\)</span>时，我们便找到了<spanclass="math inline">\(A[L]\)</span>的位置，且<spanclass="math inline">\(i\)</span>之后的位置一定是递增的。</p><p>接下来寻找<spanclass="math inline">\(A[R]\)</span>,从后向前找到第一个大于<spanclass="math inline">\(A[L]\)</span>的元素</p><p>交换两者，并令<spanclass="math inline">\(A[L]\)</span>之后的位置递增。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>       <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>       <span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>,r=<span class="hljs-number">-1</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>           <span class="hljs-keyword">if</span>(nums[i]&lt;nums[i+<span class="hljs-number">1</span>])&#123;<br>               l = i;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(l==<span class="hljs-number">-1</span>)&#123;<br>           <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>(),nums.<span class="hljs-built_in">end</span>());<br>           <span class="hljs-keyword">return</span> ;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-1</span>;i&gt;l;i--)&#123;<br>           <span class="hljs-keyword">if</span>(nums[i]&gt;nums[l])&#123;<br>               r = i;<br>               <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-built_in">swap</span>(nums[l],nums[r]);<br>       <span class="hljs-comment">//sort(nums.begin()+l+1,nums.end());</span><br>       <span class="hljs-built_in">reverse</span>(nums.<span class="hljs-built_in">begin</span>() + l + <span class="hljs-number">1</span>, nums.<span class="hljs-built_in">end</span>());<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结-1">总结</h3>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>huggingface之transformers</title>
    <link href="/2023/05/30/huggingface%E4%B9%8Btransformers/"/>
    <url>/2023/05/30/huggingface%E4%B9%8Btransformers/</url>
    
    <content type="html"><![CDATA[<h1 id="transformers库">Transformers库</h1><p><strong>前言</strong>：</p><p>Hugging Face是一个人工智能与自然语言处理技术公司，成立于2016年，总部位于美国纽约。该公司已经成为业内知名的开源机器学习工具和数据集库的提供者之一，提供了很多用于自然语言处理（NLP）的工具和模型，例如BERT、GPT 等，这些工具都是基于 PyTorch框架实现的。<del>Tensorflow亡了</del></p><p><strong>doc</strong>：https://huggingface.co/docs/transformers/installation</p><h1 id="安装conda">安装conda</h1><p>没什么特别的，下载完后直接bash就好，安装完成后需要运行一下condainit，版本是conda 4.10.3</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./conda init <br></code></pre></td></tr></table></figure><p>主要有个挺搞笑的，yes完后，直接没配置，所以就有了上边一步</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs livescript">installation finished.<br>Do you wish the installer <span class="hljs-keyword">to</span> initialize Anaconda3<br><span class="hljs-keyword">by</span> running conda init? [<span class="hljs-literal">yes</span>|<span class="hljs-literal">no</span>]<br>[<span class="hljs-literal">no</span>] &gt;&gt;&gt; <span class="hljs-literal">yes</span><br></code></pre></td></tr></table></figure><h1 id="安装transformers">安装transformers</h1><p>首先搞个虚拟环境吧，python3.8吧，3.6感觉太低了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">conda create -n transformer python=3.8<br><span class="hljs-comment"># 别忘了激活...</span><br>conda activate transformer<br></code></pre></td></tr></table></figure><p>然后直接pip安装就好</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install transformers<br></code></pre></td></tr></table></figure><p>然后torch装一下就好(tensorflowGPU支持太恶心了，再见)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">conda</span> install pytorch==<span class="hljs-number">1</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">14</span>.<span class="hljs-number">1</span> torchaudio==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">1</span> pytorch-cuda=<span class="hljs-number">11</span>.<span class="hljs-number">7</span> -c pytorch -c nvidia<br></code></pre></td></tr></table></figure><h1 id="pipeline">pipeline()</h1><p>用一种非常简单的方式来使用预训练模型</p><p>NLP相关的任务：<strong>文本分类</strong>，<strong>文本生成</strong>...</p><p>图像相关的任务：<strong>分类</strong>，<strong>分割</strong>...</p><p>音频类任务:<strong>文本识别</strong></p><p>多模态：<strong>看图输出文字</strong></p><p>完整的模型库在这里：https://huggingface.co/models</p><table><thead><tr class="header"><th><strong>Task</strong></th><th><strong>Description</strong></th><th><strong>Modality</strong></th><th><strong>Pipeline identifier</strong></th></tr></thead><tbody><tr class="odd"><td>Text classification</td><td>assign a label to a given sequence of text</td><td>NLP</td><td>pipeline(task=“sentiment-analysis”)</td></tr><tr class="even"><td>Text generation</td><td>generate text given a prompt</td><td>NLP</td><td>pipeline(task=“text-generation”)</td></tr><tr class="odd"><td>Summarization</td><td>generate a summary of a sequence of text or document</td><td>NLP</td><td>pipeline(task=“summarization”)</td></tr><tr class="even"><td>Image classification</td><td>assign a label to an image</td><td>Computer vision</td><td>pipeline(task=“image-classification”)</td></tr><tr class="odd"><td>Image segmentation</td><td>assign a label to each individual pixel of an image (supportssemantic, panoptic, and instance segmentation)</td><td>Computer vision</td><td>pipeline(task=“image-segmentation”)</td></tr><tr class="even"><td>Object detection</td><td>predict the bounding boxes and classes of objects in an image</td><td>Computer vision</td><td>pipeline(task=“object-detection”)</td></tr><tr class="odd"><td>Audio classification</td><td>assign a label to some audio data</td><td>Audio</td><td>pipeline(task=“audio-classification”)</td></tr><tr class="even"><td>Automatic speech recognition</td><td>transcribe speech into text</td><td>Audio</td><td>pipeline(task=“automatic-speech-recognition”)</td></tr><tr class="odd"><td>Visual question answering</td><td>answer a question about the image, given an image and aquestion</td><td>Multimodal</td><td>pipeline(task=“vqa”)</td></tr><tr class="even"><td>Document question answering</td><td>answer a question about a document, given an image and aquestion</td><td>Multimodal</td><td>pipeline(task=“document-question-answering”)</td></tr><tr class="odd"><td>Image captioning</td><td>generate a caption for a given image</td><td>Multimodal</td><td>pipeline(task=“image-to-text”)</td></tr></tbody></table><p>以下是一个简单的文本分类demo,<del>连续进行反转</del>,可以看到它似乎真的可以了解一些语境。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 运行之前需要安装一个库</span><br>!pip install chardet <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> pipeline<br><span class="hljs-meta">&gt;&gt;&gt; </span>classifier = pipeline(<span class="hljs-string">&quot;sentiment-analysis&quot;</span>)<br><span class="hljs-meta">&gt;&gt;&gt; </span>classifier(<span class="hljs-string">&quot;We are very happy to show you the 🤗 Transformers library.&quot;</span>)<br>[&#123;<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9997795224189758</span>&#125;]<br><span class="hljs-meta">&gt;&gt;&gt; </span>classifier(<span class="hljs-string">&quot;what the fuck&quot;</span>)<br>[&#123;<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;NEGATIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9966359734535217</span>&#125;]<br><span class="hljs-meta">&gt;&gt;&gt; </span>classifier(<span class="hljs-string">&quot;what the fuck,it it beautiful!&quot;</span>)<br>[&#123;<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9991146922111511</span>&#125;]<br><span class="hljs-meta">&gt;&gt;&gt; </span>classifier(<span class="hljs-string">&quot;what the fuck,it is sucked!&quot;</span>)<br>[&#123;<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;NEGATIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9997245669364929</span>&#125;]<br><span class="hljs-meta">&gt;&gt;&gt; </span>classifier(<span class="hljs-string">&quot;what the fuck,it is sucked,but i loved it!&quot;</span>)<br>[&#123;<span class="hljs-string">&#x27;label&#x27;</span>: <span class="hljs-string">&#x27;POSITIVE&#x27;</span>, <span class="hljs-string">&#x27;score&#x27;</span>: <span class="hljs-number">0.9997512698173523</span>&#125;]<br></code></pre></td></tr></table></figure><h1 id="fine-tune">Fine-tune</h1><p>有三种方法对sota模型进行微调<del>（他们还是很推荐自家的轮子的）</del></p><ul><li>Fine-tune a pretrained model with 🤗 Transformers <ahref="https://huggingface.co/docs/transformers/v4.29.1/en/main_classes/trainer#transformers.Trainer">Trainer</a>.</li><li>Fine-tune a pretrained model in TensorFlow with Keras.</li><li>Fine-tune a pretrained model in native PyTorch</li></ul><p>那么微调之前肯定是需要做数据预处理的了</p><h2 id="data-process">Data Process</h2><p>首先安一个加载数据的库，这玩意应该就类似tf.datasets之类的吧</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install datasets<br></code></pre></td></tr></table></figure><h3 id="tokenizer">Tokenizer</h3><p>用于处理文本的一个对象，内置了许多东西。最基础的功能就是把tokens转化为数值，然后再转化为tensor。</p><p><ahref="https://huggingface.co/docs/transformers/main_classes/tokenizer">tokenizer</a>最主要的作用就是可以吧文本<strong>对应</strong>转化为模型的输入，Transformer基础架构接受的数据是向量组，也就是矩阵，<spanclass="math inline">\(attention = \frac{K^TQ}{\sqrtk}V\)</span>，其中的<spanclass="math inline">\(K,Q,V\)</span>都是把输入做了线性变换得到的。这里涉及到一个<strong>词嵌入</strong>的问题。</p><p><strong>词嵌入：字符串很明显是没有矩阵乘法这种东西的，词嵌入就是把NLP领域最细分数据单位词量化为数值类型的方法，通常来说是一个数值向量，现在一些的成熟方案解决了许多问题，例如高维，词之间相似关系，还需要把词嵌入转换为原本的tokens等。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 能够将词转化为bert标准的tokenizer</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>)<br><span class="hljs-comment"># 模型存储在~/.cache/huggingface/下</span><br><span class="hljs-comment"># 多句话的话，传入一个list</span><br>encoded_input = tokenizer(<span class="hljs-string">&quot;Do not meddle in the affairs of wizards, for they are subtle and quick to anger.&quot;</span>)<br><span class="hljs-built_in">print</span>(encoded_input)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># input_ids 每个词的字典序</span><br><span class="hljs-comment"># token_type_ids 区分一个 batch 中的两个序列，例如同时输入了问题和回答的序列</span><br><span class="hljs-comment"># attention_mask 处理数据集时需要对句子进行填充，1代表是非填充部分</span><br>&#123;<span class="hljs-string">&#x27;input_ids&#x27;</span>: [<span class="hljs-number">101</span>, <span class="hljs-number">2079</span>, <span class="hljs-number">2025</span>, <span class="hljs-number">19960</span>, <span class="hljs-number">10362</span>, <span class="hljs-number">1999</span>, <span class="hljs-number">1996</span>, <span class="hljs-number">3821</span>, <span class="hljs-number">1997</span>, <span class="hljs-number">16657</span>, <span class="hljs-number">1010</span>, <span class="hljs-number">2005</span>, <span class="hljs-number">2027</span>, <span class="hljs-number">2024</span>, <span class="hljs-number">11259</span>, <span class="hljs-number">1998</span>, <span class="hljs-number">4248</span>, <span class="hljs-number">2000</span>, <span class="hljs-number">4963</span>, <span class="hljs-number">1012</span>, <span class="hljs-number">102</span>], <br> <span class="hljs-string">&#x27;token_type_ids&#x27;</span>: [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>], <br> <span class="hljs-string">&#x27;attention_mask&#x27;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 根据索引还原为原本的句子，可以看到tokenizer添加了两个特殊字符</span><br><span class="hljs-comment"># [CLS] 分词器 [SEP] 分割符</span><br>tokenizer.decode(encoded_input[<span class="hljs-string">&quot;input_ids&quot;</span>])<br>&gt;&gt;&gt;<span class="hljs-string">&#x27;[CLS] Do not meddle in the affairs of wizards, for they are subtle and quick to anger. [SEP]&#x27;</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对句子进行padding,按照最长长度进行填充</span><br>batch_sentences = [<br><span class="hljs-meta">... </span>    <span class="hljs-string">&quot;But what about second breakfast?&quot;</span>,<br><span class="hljs-meta">... </span>    <span class="hljs-string">&quot;Don&#x27;t think he knows about second breakfast, Pip.&quot;</span>,<br><span class="hljs-meta">... </span>    <span class="hljs-string">&quot;What about elevensies?&quot;</span>,<br><span class="hljs-meta">... </span>]<br><span class="hljs-meta">&gt;&gt;&gt; </span>encoded_input = tokenizer(batch_sentences, padding=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 对句子进行切割，使得适应模型可以容纳的最大长度</span><br>encoded_input = tokenizer(batch_sentences, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>)<br><span class="hljs-comment"># padding和turncation更为详细的用法</span><br></code></pre></td></tr></table></figure><p><ahref="https://huggingface.co/docs/transformers/pad_truncation">Paddingand truncation</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 最终版本，转换为Pytorch 的 tensor</span><br>encoded_input = tokenizer(batch_sentences, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)<br><span class="hljs-comment"># 转换为tensorflow 的 tensor</span><br>encoded_input = tokenizer(batch_sentences, padding=<span class="hljs-literal">True</span>, truncation=<span class="hljs-literal">True</span>, return_tensors=<span class="hljs-string">&quot;tf&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="fine-tune-toy">Fine-tune toy</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 1. 载入数据集</span><br><span class="hljs-comment"># pip install cchardet</span><br><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">&quot;CUDA_VISIBLE_DEVICES&quot;</span>] = <span class="hljs-string">&quot;0&quot;</span><br><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset<br>dataset = load_dataset(<span class="hljs-string">&quot;yelp_review_full&quot;</span>)<br><span class="hljs-comment"># 2.使用AutoTokenizer 对数据进行处理</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>)<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tokenize_function</span>(<span class="hljs-params">examples</span>):<br>  <span class="hljs-keyword">return</span> tokenizer(examples[<span class="hljs-string">&quot;text&quot;</span>], padding=<span class="hljs-string">&quot;max_length&quot;</span>, truncation=<span class="hljs-literal">True</span>)<br>tokenized_datasets = dataset.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment">## 划分一下数据集</span><br>small_train_dataset = tokenized_datasets[<span class="hljs-string">&quot;train&quot;</span>].shuffle(seed=<span class="hljs-number">42</span>).select(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))<br>small_eval_dataset = tokenized_datasets[<span class="hljs-string">&quot;test&quot;</span>].shuffle(seed=<span class="hljs-number">42</span>).select(<span class="hljs-built_in">range</span>(<span class="hljs-number">1000</span>))<br><span class="hljs-comment"># 3.引入分类模型</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForSequenceClassification<br>model = AutoModelForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;bert-base-cased&quot;</span>, num_labels=<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 4.设置超参数</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> TrainingArguments<br>training_args = TrainingArguments(output_dir=<span class="hljs-string">&quot;test_trainer&quot;</span>,num_train_epochs=<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 5.定义评估过程</span><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> evaluate<br>metric = evaluate.load(<span class="hljs-string">&quot;accuracy&quot;</span>)<br><span class="hljs-comment">## 把模型输出转化为真正的标签，transformers所有的模型返回的都是logits，未经归一化的实数向量</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">compute_metrics</span>(<span class="hljs-params">eval_pred</span>):<br>    logits, labels = eval_pred<br>    predictions = np.argmax(logits, axis=-<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">return</span> metric.compute(predictions=predictions, references=labels)<br><span class="hljs-comment"># 6.引入trainer并训练，transformers库提供的训练类，不需要自己编写实例循环</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> Trainer<br>trainer = Trainer(<br>    model=model,<br>    args=training_args,<br>    train_dataset=small_train_dataset,<br>    eval_dataset=small_eval_dataset,<br>    compute_metrics=compute_metrics,<br>)<br>trainer.train()<br></code></pre></td></tr></table></figure><p>至此为止我们简单的了解了基于Transformers库进行fine-tune的过程。工具为我们提供了很多的便利的同时，实际上也封装了很多细节，例如Tokenizer其实为我们做了许多的事情，从分词，到映射的保留，到使用何种方法进行词嵌入等。实际上我也很迷惘，作为一个算法工程师，我们要巨细无遗的了解这些吗？那么作为一个后端工程师，我们是否又真的有必要去了解到Java中的Map什么时候触发红黑树这类问题吗？希望未来的我能够好好的想清楚自己想要什么，以及好好的重述自己的问题。</p>]]></content>
    
    
    
    <tags>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器Mysql安装（apt好坑）</title>
    <link href="/2023/04/22/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88mysql%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/04/22/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%89%88mysql%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p><strong>Ubuntu</strong>: 18.04</p><p><strong>问题</strong>：直接输入sudo apt installmysql-server安装的mysql5.x的版本</p><p><strong>完全卸载MySQL</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get autoremove --purge mysql-server<br>sudo apt-get remove mysql-server<br>sudo apt-get autoremove mysql-server<br>sudo apt-get remove mysql-common<br>dpkg -l |grep ^rc|awk ‘&#123;print $2&#125;’ |sudo xargs dpkg -P<br></code></pre></td></tr></table></figure><p><strong>更新</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get upgrade<br></code></pre></td></tr></table></figure><p><strong>下载</strong></p><p>https://dev.mysql.com/downloads/</p><p>找到communityserver，选择好版本点小企鹅<del>逆天真的，找半天</del>下载deb，传输到服务器上</p><p>逆天操作：回车会一直卡，全选ok</p><p><strong>更新</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get update<br>sudo apt-get install mysql-server <br><span class="hljs-meta prompt_"># </span><span class="language-bash">加密方式用传统</span><br></code></pre></td></tr></table></figure><p><strong>其他操作</strong></p><p><strong>放行3306端口</strong> <del>不愧是云耀裸机</del></p><p><strong>登陆数据库</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">use mysql;<br><span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>,host <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> host = &quot;%&quot; <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span> = &quot;root&quot;;<br>flush <span class="hljs-keyword">privileges</span>;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>杂项</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql笔记</title>
    <link href="/2023/03/29/Mysql/"/>
    <url>/2023/03/29/Mysql/</url>
    
    <content type="html"><![CDATA[<p>既然解决了图床问题，那就把笔记搬一搬吧～</p><h1 id="mysql">Mysql</h1><p>MySql是关系型数据库，又多张互相连接的二维表组成的数据库</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131521443.png"alt="image-20230313160826461" /><figcaption aria-hidden="true">image-20230313160826461</figcaption></figure><h2 id="sql通用语法">SQL通用语法</h2><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131522225.png"alt="image-20230313161021759" /><figcaption aria-hidden="true">image-20230313161021759</figcaption></figure><h2 id="sql分类">SQL分类</h2><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131522918.png"alt="image-20230313161203704" /><figcaption aria-hidden="true">image-20230313161203704</figcaption></figure><h3 id="ddl语言">DDL语言</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 展示所有数据库<br><span class="hljs-keyword">SHOW</span> DATABASES;<br># 查询当前数据库<br><span class="hljs-keyword">SELECT</span> DATABASE();<br># 创建数据库<br><span class="hljs-keyword">CREATE</span> DATABASE IF <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span> MYDATABSE <span class="hljs-keyword">DEFAULT</span> CHARSET utf8mb4 <span class="hljs-keyword">COLLATE</span> 排序规则;<br># 删除数据库<br><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> MYDATABSE;<br># 使用数据库<br>USE MYDATABASE;<br><br># 查询当前数据库所有表<span class="hljs-comment">--需要先进入某个数据库</span><br><span class="hljs-keyword">SHOW</span> TABLES;<br># 查询表结构<br><span class="hljs-keyword">DESC</span> 表名;<br># 查询指定表的建表语句<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名;<br><br>#建表语句<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名(<br>name <span class="hljs-type">INT</span> COMMENT <span class="hljs-string">&#x27;名字&#x27;</span>,<br>age <span class="hljs-type">INT</span> COMMENT ‘年龄’) COMMENT <span class="hljs-string">&#x27;用户表&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>DDL表数据类型</strong></p><p>数值类型，字符串类型，日期时间类型</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131522842.png"alt="image-20230313162833695" /><figcaption aria-hidden="true">image-20230313162833695</figcaption></figure><p>默认是有符号数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">age TINYINT UNSIGNED<br>score <span class="hljs-keyword">double</span>(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131523670.png"alt="image-20230313163251268" /><figcaption aria-hidden="true">image-20230313163251268</figcaption></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-type">char</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">--性能高   不足的位置会使用空格补齐</span><br><span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)<span class="hljs-comment">--性能低，在使用时需要计算长度 存多少占多少空间</span><br><br><span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>) <span class="hljs-comment">--用户名 更适合使用其存储，因为位数是未知的</span><br><span class="hljs-type">char</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">--性别 更适合使用其存储，因为位数是固定的</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131523370.png"alt="image-20230313163834904" /><figcaption aria-hidden="true">image-20230313163834904</figcaption></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">最后一个不太常用<br></code></pre></td></tr></table></figure><p><strong>对表字段进行修改以及修改表名</strong></p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131523162.png"alt="image-20230313165414005" /><figcaption aria-hidden="true">image-20230313165414005</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131524384.png"alt="image-20230313165427697" /><figcaption aria-hidden="true">image-20230313165427697</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131524475.png"alt="image-20230313165439807" /><figcaption aria-hidden="true">image-20230313165439807</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131525069.png"alt="image-20230313165516777" /><figcaption aria-hidden="true">image-20230313165516777</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131524102.png"alt="image-20230313165536837" /><figcaption aria-hidden="true">image-20230313165536837</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131524624.png"alt="image-20230313165602784" /><figcaption aria-hidden="true">image-20230313165602784</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131524921.png"alt="image-20230313165651749" /><figcaption aria-hidden="true">image-20230313165651749</figcaption></figure><h3 id="dml语言">DML语言</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131525632.png"alt="image-20230313170203733" /><figcaption aria-hidden="true">image-20230313170203733</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131525337.png"alt="image-20230313170349992" /><figcaption aria-hidden="true">image-20230313170349992</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131525223.png"alt="image-20230313170439656" /><figcaption aria-hidden="true">image-20230313170439656</figcaption></figure><h3 id="dql语句">DQL语句</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131526982.png"alt="image-20230313170812430" /><figcaption aria-hidden="true">image-20230313170812430</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131526805.png"alt="image-20230313182101046" /><figcaption aria-hidden="true">image-20230313182101046</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131526419.png"alt="image-20230313182302311" /><figcaption aria-hidden="true">image-20230313182302311</figcaption></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-comment">--不空</span><br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131526055.png"alt="image-20230313182815300" /><figcaption aria-hidden="true">image-20230313182815300</figcaption></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-literal">null</span>是不会被聚合函数计算的<br></code></pre></td></tr></table></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131527738.png"alt="image-20230313183603511" /><figcaption aria-hidden="true">image-20230313183603511</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131527385.png"alt="image-20230313183401961" /><figcaption aria-hidden="true">image-20230313183401961</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131527790.png"alt="image-20230313183753038" /><figcaption aria-hidden="true">image-20230313183753038</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131528934.png"alt="image-20230313184130884" /><figcaption aria-hidden="true">image-20230313184130884</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131528673.png"alt="image-20230313184431291" /><figcaption aria-hidden="true">image-20230313184431291</figcaption></figure><h3 id="dcl语句">DCL语句</h3><p>用来管理哪些用户可以访问哪些数据库的权限。</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131528653.png"alt="image-20230314132612320" /><figcaption aria-hidden="true">image-20230314132612320</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131528237.png"alt="image-20230314132634430" /><figcaption aria-hidden="true">image-20230314132634430</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131528635.png"alt="image-20230314132946733" /><figcaption aria-hidden="true">image-20230314132946733</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131528466.png"alt="image-20230314133053891" /><figcaption aria-hidden="true">image-20230314133053891</figcaption></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">需要指定所有数据库的所有表时使用<span class="hljs-strong">*.*</span><br>多个权限使用,分隔<br></code></pre></td></tr></table></figure><h2 id="函数">函数</h2><h3 id="字符串函数">字符串函数</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131529320.png"alt="image-20230314133452136" /><figcaption aria-hidden="true">image-20230314133452136</figcaption></figure><h3 id="数值函数">数值函数</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131529111.png"alt="image-20230314133834871" /><figcaption aria-hidden="true">image-20230314133834871</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131529239.png"alt="image-20230314134027636" /><figcaption aria-hidden="true">image-20230314134027636</figcaption></figure><h3 id="日期函数">日期函数</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131529001.png"alt="image-20230314134222466" /><figcaption aria-hidden="true">image-20230314134222466</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131529855.png"alt="image-20230314134424145" /><figcaption aria-hidden="true">image-20230314134424145</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131529115.png"alt="image-20230314134554989" /><figcaption aria-hidden="true">image-20230314134554989</figcaption></figure><h3 id="流程函数">流程函数</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131531885.png"alt="image-20230314134800556" /><figcaption aria-hidden="true">image-20230314134800556</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131531438.png"alt="image-20230314135000775" /><figcaption aria-hidden="true">image-20230314135000775</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131531980.png"alt="image-20230314135130951" /><figcaption aria-hidden="true">image-20230314135130951</figcaption></figure><h2 id="约束">约束</h2><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131531734.png"alt="image-20230314152119360" /><figcaption aria-hidden="true">image-20230314152119360</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131532200.png"alt="image-20230314152250885" /><figcaption aria-hidden="true">image-20230314152250885</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131533132.png"alt="image-20230314152326651" /><figcaption aria-hidden="true">image-20230314152326651</figcaption></figure><h3 id="外键约束">外键约束</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131534131.png"alt="image-20230314152907470" /><figcaption aria-hidden="true">image-20230314152907470</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131534296.png"alt="image-20230314153149516" /><figcaption aria-hidden="true">image-20230314153149516</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131534617.png"alt="image-20230314153448986" /><figcaption aria-hidden="true">image-20230314153448986</figcaption></figure><h2 id="多表查询">多表查询</h2><h3 id="多表关系">多表关系</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131534093.png"alt="image-20230314153903452" /><figcaption aria-hidden="true">image-20230314153903452</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131534509.png"alt="image-20230314154012864" /><figcaption aria-hidden="true">image-20230314154012864</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131535059.png"alt="image-20230314154211394" /><figcaption aria-hidden="true">image-20230314154211394</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131535702.png"alt="image-20230314154338690" /><figcaption aria-hidden="true">image-20230314154338690</figcaption></figure><h3 id="多表查询-1">多表查询</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131535225.png"alt="image-20230314154612572" /><figcaption aria-hidden="true">image-20230314154612572</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131535729.png"alt="image-20230314154838956" /><figcaption aria-hidden="true">image-20230314154838956</figcaption></figure><h3 id="内连接">内连接</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131535244.png"alt="image-20230314154951114" /><figcaption aria-hidden="true">image-20230314154951114</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131536905.png"alt="image-20230314155100394" /><figcaption aria-hidden="true">image-20230314155100394</figcaption></figure><h3 id="外连接">外连接</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131536624.png"alt="image-20230314155206451" /><figcaption aria-hidden="true">image-20230314155206451</figcaption></figure><h3 id="自连接">自连接</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131536073.png"alt="image-20230315124336169" /><figcaption aria-hidden="true">image-20230315124336169</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131536004.png"alt="image-20230315124554907" /><figcaption aria-hidden="true">image-20230315124554907</figcaption></figure><h3 id="联合查询">联合查询</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131537528.png"alt="image-20230315124920355" /><figcaption aria-hidden="true">image-20230315124920355</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131537754.png"alt="image-20230315124644081" /><figcaption aria-hidden="true">image-20230315124644081</figcaption></figure><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">去掉<span class="hljs-keyword">all</span>关键字可以实现去重<br>要求两个查询的字段列表一致<br></code></pre></td></tr></table></figure><h3 id="子查询">子查询</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131537842.png"alt="image-20230315125057468" /><figcaption aria-hidden="true">image-20230315125057468</figcaption></figure><h4 id="标量子查询">标量子查询</h4><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131537673.png"alt="image-20230315125349350" /><figcaption aria-hidden="true">image-20230315125349350</figcaption></figure><figure><imgsrc="/Users/zs/Library/Application%20Support/typora-user-images/image-20230315125418893.png"alt="image-20230315125418893" /><figcaption aria-hidden="true">image-20230315125418893</figcaption></figure><figure><imgsrc="/Users/zs/Library/Application%20Support/typora-user-images/image-20230315125426094.png"alt="image-20230315125426094" /><figcaption aria-hidden="true">image-20230315125426094</figcaption></figure><h4 id="列子查询">列子查询</h4><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131538505.png"alt="image-20230315130443380" /><figcaption aria-hidden="true">image-20230315130443380</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131538454.png"alt="image-20230315130549346" /><figcaption aria-hidden="true">image-20230315130549346</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131538770.png"alt="image-20230315130641950" /><figcaption aria-hidden="true">image-20230315130641950</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131538536.png"alt="image-20230315130758476" /><figcaption aria-hidden="true">image-20230315130758476</figcaption></figure><h4 id="行子查询">行子查询</h4><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131538894.png"alt="image-20230315130848904" /><figcaption aria-hidden="true">image-20230315130848904</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131539386.png"alt="image-20230315130957824" /><figcaption aria-hidden="true">image-20230315130957824</figcaption></figure><h4 id="表子查询">表子查询</h4><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131539572.png"alt="image-20230315131037508" /><figcaption aria-hidden="true">image-20230315131037508</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131539109.png"alt="image-20230315131901050" /><figcaption aria-hidden="true">image-20230315131901050</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131539408.png"alt="image-20230315131931799" /><figcaption aria-hidden="true">image-20230315131931799</figcaption></figure><h3 id="事务">事务</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131539934.png"alt="image-20230315132302069" /><figcaption aria-hidden="true">image-20230315132302069</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131540105.png"alt="image-20230315132442715" /><figcaption aria-hidden="true">image-20230315132442715</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131540919.png"alt="image-20230315132656710" /><figcaption aria-hidden="true">image-20230315132656710</figcaption></figure><h4 id="事务的四大特性">事务的四大特性</h4><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131540405.png"alt="image-20230315132909165" /><figcaption aria-hidden="true">image-20230315132909165</figcaption></figure><h4 id="并发事务引发的问题">并发事务引发的问题</h4><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131540909.png"alt="image-20230315132950947" /><figcaption aria-hidden="true">image-20230315132950947</figcaption></figure><h4 id="事务隔离级别">事务隔离级别</h4><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131540410.png"alt="image-20230315133738335" /><figcaption aria-hidden="true">image-20230315133738335</figcaption></figure><h2 id="mysql-存储引擎">MYSQL 存储引擎</h2><p>mysql的体系结构分为：</p><ul><li>连接层（用户权限校验，最大链接数的）</li><li>服务层（DML，DDL语句，查询优化器）</li><li>引擎层（5以后的版本InnoDB为默认版本，<strong>索引</strong>在该层实现）</li><li>存储层（实际的存储）</li></ul><p>存储引擎是存储数据，建立索引，更新/查询数据技术的实现方式，存储引擎基于表而不是库，也可以称为表类型。</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131541524.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131541588.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="innodb引擎">InnoDB引擎</h3><p>兼顾高性能和高可靠性，支持事务，行级锁，外健。每一张使用InnDOB引擎存储的表都对应一个xxx.ibd文件。每个文件存储了表的结构，数据，和索引。</p><p>InnoDB的存储结构为表空间--段--页（一条一条数据）--行</p><h3 id="myisam引擎">MYISAM引擎</h3><p>MySql早期默认引擎，不支持事务，外健；支持行锁不支持列锁，访问速度快。</p><h3 id="memory存储引擎">Memory存储引擎</h3><p>访问速度快，支持哈希索引，但受断电影响。</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131541224.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="存储引擎的选择">存储引擎的选择</h3><p>选InnoDB，MEMORY存储引擎的场景使用Redis可以很好的替代；MyISAM存储引擎的使用场景一般被芒果DB来替代。</p><h2 id="索引">索引</h2><p>优点：提高查找速度，降低IO，提高排序效率</p><p>缺点：空间，降低增删改的效率</p><h3 id="索引的数据结构">索引的数据结构</h3><p>MySql的索引在存储引擎层实现，不同的存储引擎有不同的结构。常见的是B+树，哈希索引，R-tree空间索引（地理空间数据），Full-text（全文索引，和ES一个性质）</p><h3 id="b树索引">B+树索引</h3><p>B树的引入，红黑树在面对数据量较大时仍然存在树的深度较深的情况，因此引入了B树。B树一个节点允许存在多个子节点。</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131541759.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>B+树是在B树的基础之上，做了两点改进</p><ul><li>所有元素都出现在叶子节点</li><li>叶子节点通过一条链表连接</li></ul><p>mysql在B+树之上又多维护了一个指针，指向相邻叶子节点</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131542038.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="hash索引">hash索引</h3><p>查询效率高，但是不支持范围查询，也没法利用索引进行排序。</p><h3 id="索引分类">索引分类</h3><p>有四种常见的索引</p><ul><li>主键索引：自动创建，一张表只能有一个，primary关键字指定</li><li>唯一索引：使用unique关键字创建</li><li>常规索引：可以有多个</li><li>全文索引：查找文本中的关键词，而不是比较索引中的值，可以有多个，fulltext</li></ul><p>在Innodb中索引又分为两种不同的类型，分别是聚集索引以及二级索引</p><ul><li>聚集索引：必须有，默认主健，没有主键就默认使用unqiue修饰的键，也没有就默认为行号。</li><li>二级索引：可以有可以没有</li></ul><p>聚集索引的叶子节点挂了完整的一行数据，二级索引的节点则挂了作为二级索引的键值</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131542173.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="索引的操作语法">索引的操作语法</h3><ul><li>索引的创建语法</li></ul><p>create [unique,fulltext] index on table(col_name1,col_name2...);</p><ul><li>索引的查看</li></ul><p>show index from table;</p><ul><li>索引的删除</li></ul><p>​ drop index ind1 on table;</p><h3 id="sql性能分析">SQL性能分析</h3><ul><li>SQL执行频率 查看增删改查在该数据库的频率</li></ul><p>show global status like "Com_______";</p><p>​ 如果发现查询请求占大部分，则需要考虑做SQL优化；</p><ul><li>开启慢查询日志(重启失效)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//慢查询是否开启</span><br>show variables like <span class="hljs-string">&quot;slow_query_log&quot;</span>;<br><span class="hljs-comment">//多长的查询时间会记录为慢查询</span><br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;long_query_time&#x27;</span>;<br><span class="hljs-comment">//修改该查询时间</span><br>SET GLOBAL long_query_time = <span class="hljs-number">2</span>;<br><span class="hljs-comment">//输出日志目录</span><br>SHOW VARIABLES LIKE <span class="hljs-string">&#x27;slow_query_log_file&#x27;</span>;<br></code></pre></td></tr></table></figure><ul><li>profile 查看SQL时间都耗费到哪里了(重启失效)</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//是否支持profile</span><br>select @@have_profiling;<br><span class="hljs-comment">//是否开启profile</span><br>select @@profiling;<br><span class="hljs-comment">//开启</span><br>set profiling = <span class="hljs-number">1</span>;<br><span class="hljs-comment">//查看当前回话所有sql时间</span><br>show profiles;<br><span class="hljs-comment">//查询某条查询记录详细时间消耗</span><br>show profile <span class="hljs-keyword">for</span> query <span class="hljs-number">6</span>;<br><span class="hljs-comment">//查询某条记录cpu详细时间消耗</span><br>show profile cpu <span class="hljs-keyword">for</span> query <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><ul><li>explain查询sql语句的执行计划</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">explain + 具体的sql语句;<br></code></pre></td></tr></table></figure><p>id:值越大越先执行，值相同从上到下。</p><p>type:表示连接类型，性能从好到差排序为(NULL,ystem,const，eq_ref,ref,range,index,all)</p><p>possible_key:这张表可能用的索引</p><p>key:实际使用的索引</p><p>rows:mysql认为必须要执行查询的行数，是一个估计值</p><p>filtered:表示返回结果的行数占需读取行数的百分比，越大越好</p><h3 id="索引使用原则">索引使用原则</h3><ul><li>最左前缀法则：在索引了多列的情况下（联合索引），如果希望索引生效，则联合索引最左边的字段必须存在；如果某个索引字段被跳过，则后边的部分失效。</li><li>范围查询：在联合索引的条件下，如果出现了&lt; or &gt;的范围索引，则排在该字段后边的索引失效；可以使用&gt;= ,&lt;=规避</li><li>索引列运算：对索引列运算（例如使用substring查询手机号码结尾为15的用户）会导致索引失效</li><li>查询字符串不加''会导致索引失效</li><li>模糊查询时，如果对字段尾进行模糊匹配索引不会失效，如果对头部进行了模糊匹配，索引会失效</li><li>or连接时，如果条件列有任意一方没有索引的话，则索引失效</li><li>数据分布影响：如果mysql判断走索引更慢，则不会走索引（例如查询全表）</li><li>查询时尽量使用覆盖索引（查询使用了索引，且返回的列都在索引中)</li><li>对于使用varchar或者text类型的字段使用前缀索引 create index idx_nameon stduent(name(n));</li><li>创建联合索引时要考虑创建顺序，使用频率高的应该在最左边；联合索引的key存储了所有的字段</li></ul><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131542722.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h3 id="sql提示">SQL提示</h3><p>建议/强制 优化器使用什么样的索引</p><ul><li>use index()</li><li>ignore index()</li><li>force index()</li></ul><p>select * from student use index(_idx) where xx;</p><p>前两种形式MYSQL优化器有可能选择不执行</p><h3 id="sql优化">SQL优化</h3><h4 id="insert-优化">INSERT 优化</h4><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131542704.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>一次性加载100万数据</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131542170.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131543486.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="主键优化">主键优化</h4><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131545924.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>1.在满足业务需求的情况下，尽量降低主键长度（二级索引会存储主键）</p><p>2.插入数据时尽量顺序插入（避免页分裂情况）</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131544553.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131544106.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131544850.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>3.主键尽量选择自增主键 ，业务尽量避免对主键的修改</p><h4 id="order-by优化">ORDER BY优化</h4><p>OEDERBY有两种情况，一种是扫描出所有的需要的数据，然后在缓冲区排序；另一种直接通过索引顺序返回。</p><ul><li>尽量使用覆盖索引</li></ul><h4 id="group-by优化">GROUP BY优化</h4><p>使用索引</p><h4 id="limit-分页查询优化">Limit 分页查询优化</h4><p>随着起始页的增大，分页查询会越来越慢</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131544658.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="count优化">COUNT优化</h4><p>COUNT就是很耗时，如果实在要优化的话结合redis进行优化。</p><h4 id="updata优化">UPDATA优化</h4><p>更新数据时更新的条件一定要有索引，如果更新的字段没有加索引的话，则会将整个表锁住，在事务提交以前其他对该表的索引都将被阻塞。</p><h3 id="mysql锁">MYSQL锁</h3><p>mysql有三种锁</p><ul><li>行锁</li><li>表锁</li><li>全局锁</li></ul><h4 id="全局锁">全局锁</h4><p>加完锁之后整个数据库处于只读状态，DML，DDL语句，事务全部都会被阻塞。例如备份整个数据库。</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131544989.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131544653.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><h4 id="表级锁">表级锁</h4><ul><li>表锁</li></ul><p>又分为表读锁以及表写锁；</p><p>表写锁会允许当前客户端对表进行读和写，并阻塞其他客户端对表的读和写</p><p>表读锁回允许当前客户端对表进行读，但是不允许写，并阻塞其他客户端的写</p><p>表锁的语法</p><p>lock table user read/write</p><p>unlock table</p><ul><li>元数据锁</li></ul><p>元数据就是指的表结构；当表上存在活动的事务时会自动对表加上共享读/写锁，两者任一都会阻塞alter语句；直到事务提交完毕后，锁会自动释放。</p><ul><li>意向锁</li></ul><p>假如某张表的行已经存在了锁，这时候如果另一个客户端要加表锁，需要对每一行的数据判断是否存在锁，是否可以上表锁，这<strong>很浪费时间</strong>；在执行select（lockin shardmodel），insert，update，delete语句时会自动对表加上共享锁；直接通过意向锁来判断是否可以加表锁；</p><p>意向锁分为两种，意向共享锁（select），意向拍他锁；</p><ul><li>意向共享锁：与表读锁兼容，与表写锁互斥；</li><li>意向排它锁：与表读锁，写锁都互斥；</li></ul><h4 id="行锁">行锁</h4><p>MYSQL支持四种隔离级别：</p><p>MySQL支持四种隔离级别，分别是：</p><ol type="1"><li>读未提交（ReadUncommitted）：最低的隔离级别，允许一个事务读取另一个事务未提交的数据。这种隔离级别可能会导致脏读（DirtyRead）和不可重复读（Non-repeatable Read）问题。</li><li>读已提交（ReadCommitted）：允许一个事务只能读取另一个事务已提交的数据。这种隔离级别可以避免脏读，但仍然可能出现不可重复读和幻读（PhantomRead）问题。</li><li>可重复读（RepeatableRead）：保证在同一个事务中多次读取同一数据时，结果始终一致。在这个级别下，MySQL使用锁来避免不可重复读和幻读问题。</li><li>串行化（Serializable）：最高的隔离级别，通过强制事务串行执行来避免并发问题。在这个级别下，MySQL会对所有读取的数据进行加锁，避免任何并发问题。</li></ol><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131543787.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131543956.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131543885.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131543070.png"alt="img" /><figcaption aria-hidden="true">img</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软件测试笔记</title>
    <link href="/2023/03/29/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/"/>
    <url>/2023/03/29/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="软件测试">软件测试</h1><h2 id="测试标准">测试标准</h2><p><strong>国际标准 IOS25010</strong></p><p><strong>国内标准</strong> GBT20438 <strong>GBT18905</strong></p><p>两个主要标准</p><h2 id="测试基本要求">测试基本要求</h2><p>1.外观界面测试（风格，错位，界面效果等）</p><p>2.易用性测试（是否符合正常用户的需求）</p><p>3.兼容性测试（例如网站在各种浏览器的兼容性，ios不同的版本，win10，win10...，安卓版本等）</p><p>4.安全性测试（防止用户介入的部分，或者是正常的部分）</p><p>5.性能测试（）</p><p>6.功能测试（功能是否正常运行）</p><h2 id="bug来源">bug来源</h2><p>虫子。。。</p><h1 id="测试与开发模型">测试与开发模型</h1><h2 id="测试的工作流程">测试的工作流程</h2><h3 id="需求分析">1 .需求分析</h3><p>阅读需求文档,分析需求的点（也是需要测试的点），参与需求评审（是否满足正常的需要），快速熟悉项目。</p><h3 id="制定测试计划和测试方案">2.制定测试计划和测试方案</h3><p>测试计划：测试整个项目的总体规划，如测试的范围，进度的安排，人力物力的安排，整体的测试策略，风险评估于规避</p><p>测试方案：被测试的目标，选取什么测试工具（工具环境），测试的方法，测试的重点（28 原则，少数功能被用户使用）。</p><h3 id="测试用例设计">3.测试用例设计</h3><p>（）</p><h3 id="测试用例执行">4.测试用例执行</h3><p>执行测试用例</p><h3 id="评估阶段-测试报告">5.评估阶段 测试报告</h3><p>3 4反复运行后，写出测试报告</p><h1 id="开发模型">开发模型</h1><h2 id="瀑布模型">瀑布模型</h2><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131629899.png"alt="image-20221014150847695" /><figcaption aria-hidden="true">image-20221014150847695</figcaption></figure><p>1.阶段之间必须按顺序来</p><p>2.推迟实现</p><p>3.每一个阶段完成都可进行质量检查</p><p>总结：瀑布模型是文档驱动的模型（每个阶段完成都有文档以及检查），按照既定的规则约束在实现上比较简单，在成本上显著降低。</p><h3 id="优点">优点：</h3><p>每个阶段都有检查点，当前阶段完成不需要考虑前一个阶段。</p><p>可在迭代模型应用瀑布模型（迭代模型见后）</p><h3 id="缺点">缺点：</h3><p>不符合需求模糊且经常变动的系统</p><p>由于需要较长的交付时间，可能会对用户的新人造成影响</p><p>灵活度比较低</p><h2 id="增量模型">增量模型</h2><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131630481.png"alt="image-20221014152425744" /><figcaption aria-hidden="true">image-20221014152425744</figcaption></figure><p>每次只开发一个小功能，每个功能阶段顺序。避免了瀑布模型的缺点。</p><h2 id="快速原型">快速原型</h2><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131630020.png"alt="image-20221014152808936" /><figcaption aria-hidden="true">image-20221014152808936</figcaption></figure><h3 id="优点-1">优点</h3><p>克服瀑布模型的缺点，减少由于软件需求不明确带来的开发风险，适合不能确切定义需求的软件系统的开发。</p><h3 id="缺点-1">缺点</h3><p>产品质量低</p><h2 id="其他模型">其他模型</h2><h3 id="螺旋开发模型">螺旋开发模型</h3><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131630523.png"alt="image-20221014153142105" /><figcaption aria-hidden="true">image-20221014153142105</figcaption></figure><h3 id="迭代开发模型">迭代开发模型</h3><h3 id="敏捷开发模型">敏捷开发模型</h3><p>简单设计，快速设计</p><h1 id="测试模型">测试模型</h1><h2 id="v模型">V模型</h2><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131630023.png"alt="image-20221014153541831" /><figcaption aria-hidden="true">image-20221014153541831</figcaption></figure><h3 id="缺点-2">缺点：</h3><p>测试介入的较晚，从编码阶段才开始介入，使得一些前期的缺陷无法发现和修改，测试与开发串行，总用时较长。</p><h2 id="w模型双v模型">W模型（双V模型）</h2><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131630716.png"alt="image-20221014153910302" /><figcaption aria-hidden="true">image-20221014153910302</figcaption></figure><p>从开发最开始，软件测试便介入其中。</p><h3 id="优点-2">优点</h3><p>测试伴随软件整个生命周期</p><h3 id="缺点-3">缺点</h3><p>对需求和测试技术要求高 适用于大型中型企业</p><h1 id="软件测试的分类">软件测试的分类</h1><h2 id="按照测试开发的阶段">按照测试（开发）的阶段</h2><p>​<strong>单元测试</strong>：编码完成后，主要测试模块，类，函数，方法（开发人员和白盒测试人员参与）</p><p>​<strong>集成测试</strong>：在单元测试完成后，主要测试模块和模块之间的内容（开发人员和白盒测试人员参与）</p><p>​<strong>系统测试</strong>：集成测试之后，测试整个程序，软件，app，系统，网站（开发人员，白盒黑盒测试人员）</p><p>​<strong>验收（交付测试）</strong>：系统测试之后，测试整个项目（部分用户，以及测试人员测试）</p><p>分为α测试（小规模人员内测）以及β测试（大规模公测）</p><h2 id="是否覆盖源码">是否覆盖源码</h2><p>​ <strong>黑盒测试</strong>：不覆盖，</p><p>​功能测试（UI测试【界面测试】，业务测试【狭义的功能测试】，文档测试【文档对不对，逻辑清晰，错别字】，易用性测试【是不是满足用户的正常的思维逻辑】，安装和卸载测试，兼容性测试【浏览器测试，平台测试，本身的兼容性{老版本是否能正常兼容新版本内容}，数据兼容性{不同平台数据是否兼容}】）</p><p>​性能测试（一般性能测试【响应速度，对资源的利用{CPU占用率，GPU使用率，内存占有率}】，稳定性测试【服务器稳定性，程序稳定性】，负载测试{例如高并发的负载}，压力测试{例如多少的高并发不会使得程序崩溃}）</p><p><strong>白盒测试</strong>：覆盖</p><p>语句覆盖：每个语句都会被执行一次</p><p>判断覆盖：确保每个判断条件都会执行一次</p><p>条件覆盖：每个条件都会执行一次</p><p>路径覆盖：代码每个分支都会走到</p><p><strong>灰盒测试</strong>：</p><p>​ 除了关心输入输出之外，考虑程序运行的状态</p><h2 id="是否运行">是否运行</h2><p>​<strong>静态测试</strong>：测试程序结构，逻辑，过程，接口是否正常，代码的风格是否符合</p><p>​ <strong>动态测试：</strong></p><h2 id="是否自动化">是否自动化</h2><p>​ <strong>手工测试：</strong>点点点</p><p>​ <strong>自动化测试：</strong></p><h2 id="按照地域测试">按照地域测试</h2><p>​ <strong>本地化测试</strong>：</p><p>​ <strong>国际化测试</strong>：</p><h2 id="其他测试分类">其他测试分类</h2><p>​ <strong>回归测试</strong>：打回去，拿过来，再测试</p><p>​<strong>冒烟测试</strong>（硬件测试词语）：基本功能，基本的模块是否能正常运行</p><p>​<strong>随机测试</strong>：monkey测试，乱jb点，看看程序有没有问题</p><p>​ <strong>探索测试</strong>：</p><h1 id="测试用例的设计">测试用例的设计</h1><h2 id="测试用例定义">测试用例定义</h2><p>测试用例又叫testcase，由测试输入，执行条件，以及预期结果组成，以便测试某个程序路径或核实是否满足某个特定需求。为了确保这个功能，模块，函数返回一个合法的结果。</p><h2 id="测试用例的特性">测试用例的特性</h2><p><strong>有效性：</strong>能够被使用，且不同人员测试结果应该是一致的</p><p><strong>可复用性</strong>：良好的测试用例具有可重复使用的功能，如回归测试</p><p><strong>易组织性</strong>：好的测试用例会分门别类地提供给测试人员参考和使用</p><p><strong>可评估性</strong>：从测试管理的角度，测试用例地通过率和软件缺陷数目的数量是软件产品质量好坏的测试标准。</p><h2 id="测试用例的要素">测试用例的要素</h2><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131630415.png"alt="image-20221017162718401" /><figcaption aria-hidden="true">image-20221017162718401</figcaption></figure><p><strong>测试用例编号：</strong>不可重复，方便后续查找该用例，由<strong>字符</strong>和<strong>数字</strong>组成的<strong>字符串</strong></p><p><strong>测试项目：</strong>属于哪个项目，哪个需求，哪个模块，哪个单元等</p><p><strong>条件：</strong>执行用例所需的条件 ？</p><p><strong>测试输入</strong>：来源有手工，数据库等。</p><p><strong>预期输出</strong>：包括预期输出结果，返回值内容，界面响应结果等。</p><p><strong>操作步骤</strong>：<strong>必须十分详细</strong>，测试人员可以根据该步骤完成测试用例的执行</p><p><strong>测试用例标题</strong>：不可重复，对测试用例简单描述。</p><p><strong>级别</strong>：高级别（核心业务，重要特性，使用频率高），中级别，低级别（非核心，不太重要，使用频率低）</p><p><strong>其他建议添加要素：</strong>用例的设计者，用例设计日期，对应开发人员，测试结果，测试类型（功能，性能，压力等）</p><h2 id="测试用例设计原则">测试用例设计原则</h2><p><strong>明确性:</strong>测试用例的测试结果是唯一的，不可使用含糊用词</p><p><strong>代表性</strong>：功能相似的用例进行合并</p><p><strong>间接性</strong>：使用陈述性语句，一句话直指问题核心，不要用浮夸的修辞手法。</p><h2 id="测试用例的设计原则">测试用例的设计原则</h2><h3 id="等价类划分法">等价类划分法</h3><p>把所有可能输入的数据划分成若干部分，每一部分选取有代表性的数据作为测试用例。</p><p><strong>过程为1.划分等价类</strong>（列出等价类表）2.<strong>选取测试用例</strong>。</p><p>等价类划分法把不能穷举的测试合理分类，保证设计出的测试用例具有<strong>完整性</strong>和<strong>代表性</strong>。</p><p>等价类划分为有效等价类和无效等价类，前者用于保证程序的基本功能完整，后者使得程序对于输入健壮。</p><p>等价类划分法案例：QQ登录</p><p>条件划分：qq号为6-10位</p><p>qq号码只接受整数，不能以0开头。</p><p>有效等价类： 【6，7，8，9，10】位数字（不以0开头）</p><p>无效等级类：【特殊符号，大写字母，小写字母，字符，以及组合】</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131630399.png"alt="image-20221021164346807" /><figcaption aria-hidden="true">image-20221021164346807</figcaption></figure><h3id="边界值法于等价类划分法密切相关">边界值法（于等价类划分法密切相关）</h3><p>测试输入取边界以及边界加减1</p><h3 id="因果图法">因果图法</h3><p>适合于检查程序<strong>输入条件各种组合</strong>的情况</p><p>例如充值系统，不同面值的组合输入，对应不同结果的输出。</p><p>等价类划分法和边界值法着重考虑输入条件，但没有考虑输入条件的各种组合情况，由于我们不可能考虑所有输入条件的组合(<spanclass="math inline">\(2^n-1\)</span>),所以需要用到<strong>因果图模型（逻辑模型）</strong></p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131631352.png"alt="image-20221121185053006" /><figcaption aria-hidden="true">image-20221121185053006</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131631750.png"alt="image-20221121185221311" /><figcaption aria-hidden="true">image-20221121185221311</figcaption></figure><p><strong>因果图案例</strong></p><p>1.找出所有原因，找出所有结果。</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131631999.png"alt="image-20221201160040404" /><figcaption aria-hidden="true">image-20221201160040404</figcaption></figure><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131631115.png"alt="image-20221201160455925" /><figcaption aria-hidden="true">image-20221201160455925</figcaption></figure><p>输入条件：【50元，100元，选择充值50元，选择充值100元】</p><p>输出条件（结果）：【完成充值后退卡，提示充值成功，提示错误，找零】</p><p>2.明确所有输入条件，输出条件之间的制约关系（哪些条件可以组合在一起，哪些条件不可以组合在一起）{是否可以同时出现或者不可同时出现需要结合系统需求来实现}</p><p>输入不可组合【（1，2），（3，4）】</p><p>输入可组合【（1，3），（1，4），（2，3），（2，4）】</p><p>单独条件【1，2，3，4】</p><p>输出不可组合【（1，3），（1，4）】</p><p>输出可组合【（1，2），，（2，3），（2，4），（3，4）】</p><p>单独条件【3，4】</p><p>3.根据制约关系绘图</p><p>xxxxxx</p><p>4.制作判定表</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131631366.png"alt="image-20221201163735428" /><figcaption aria-hidden="true">image-20221201163735428</figcaption></figure><p>5.编写测试用例</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131631965.png"alt="image-20221201163943896" /><figcaption aria-hidden="true">image-20221201163943896</figcaption></figure><h3 id="判定表法">判定表法</h3><p>与因果图类似，把复杂问题按照各种可能情况一一列举出来，简明而已于理解，避免遗漏。</p><p>案例：</p><figure><imgsrc="https://raw.githubusercontent.com/ShuaiZhang1998/figure/main/figure/202307131631183.png"alt="image-20230125105126583" /><figcaption aria-hidden="true">image-20230125105126583</figcaption></figure><h3 id="正交表法">正交表法</h3><p>用最少的测试过程获得最大的测试覆盖率。</p><p>当选项过多时，因为组合数的复杂度为幂次方，不可能在有限的时间和空间内获取到所有组合情况。因此采用正交表法。</p><p>正交实验：实际上就是一种随机采样策略，存在一些工具可以方便生成正交实验表。</p><h3 id="场景法">场景法</h3><p>从起点开始，通过一系列操作步骤（事件）达成某一结果，到终点的过程测试。场景法主要用于<strong>“冒烟测试”</strong>（基本功能是否完善）。</p><p>通过场景测试后，再通过其他方法进行更为细腻的测试。</p>]]></content>
    
    
    
    <tags>
      
      <tag>笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>灌水思路</title>
    <link href="/2023/03/13/idea/"/>
    <url>/2023/03/13/idea/</url>
    
    <content type="html"><![CDATA[<p><span class="math inline">\(y = ||UV-X||^*\)</span></p><p><span class="math inline">\(s.t. X_\omega=A_\omega\)</span></p><p>使用两个低秩矩阵UV逼近满足使得满足约束条件具备最低秩的X矩阵</p><p>其实有两个算法</p><ol type="1"><li></li></ol><p><span class="math inline">\(min_x\ ||X||^*\)</span></p><p><span class="math inline">\(s.t. X_\omega=A_\omega\)</span></p><ol start="2" type="1"><li></li></ol><p><span class="math inline">\(min_{u,v}||A-U^TV||_F\)</span></p><p>为什么当时说不好</p><p>（1）单独的两个都凸，放一起非凸</p><p>（2）算法(1)的精度比（2）高不少，放在一起有点以次充好的感觉</p><p>上边的讨论没有考虑实际的测序数据存在的一些问题，因此在多种评估指标以及多种数据的背景下，我的实验中，（1）（2）谁好有一定的规律，（1）值准确，（2）聚类效果好。</p><p>两种算法都为经典的矩阵补全算法，某些约束都收敛到最优解<spanclass="math inline">\(X_*\)</span>。然而我直观的感受来说，在数据未知的情况下，似乎有个挺均衡的的解介于两个算法的解之间。</p><p><span class="math inline">\(y = ||X||_*+||U^TV-A||_F\)</span></p><p><span class="math inline">\(s.t. X_{\Omega}=A_{\Omega}\)</span></p><p>这个问题形式也没啥用，各自求各自的，目标是希望两个解产生一定交互。然而我不太可能严谨的提出某种度量距离满足我直观的感觉。所以我给出如下的感觉式子</p><p><span class="math inline">\(y =\alpha_1||X||_*+\alpha_2||U^TV-A||_F+dis(X,U^TV)\)</span></p><p>测试下图片</p><figure><img src="../img/DALL.png" alt="DALL" /><figcaption aria-hidden="true">DALL</figcaption></figure><p>真的鶸智啊...时好时坏的，以后抽时间搞个图床算了...</p><figure><imgsrc="https://s.yimg.com/os/creatr-uploaded-images/2022-12/0e33a550-85f9-11ed-bb6f-a3c383de69f0"alt="YAYA" /><figcaption aria-hidden="true">YAYA</figcaption></figure>]]></content>
    
    
    
    <tags>
      
      <tag>灌水</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT记录</title>
    <link href="/2023/03/01/PAT/"/>
    <url>/2023/03/01/PAT/</url>
    
    <content type="html"><![CDATA[<h1 id="字符串1001">字符串1001</h1><p>Calculate <em>a</em>+<em>b</em> and output the sum in standard format-- that is, the digits must be separated into groups of three by commasunless there are less than four digits).</p><h3 id="input-specification">Input Specification:</h3><p>Each input file contains one test case. Each case contains a pair ofintegers <em>a</em> and <em>b</em> where <spanclass="math inline">\(10^{-6}&lt;=a,b&lt;=10^{6}\)</span> . The numbersare separated by a space.</p><h3 id="output-specification">Output Specification:</h3><p>For each test case, you should output the sum of <em>a</em> and<em>b</em> in one line. The sum must be written in the standardformat.</p><h3 id="sample-input">Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">-1000000 9<br></code></pre></td></tr></table></figure><h3 id="sample-output">Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">-999,991<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a,b,c;<br>cin&gt;&gt;a&gt;&gt;b;<br>c = a+b;<br>string num = <span class="hljs-built_in">to_string</span>(c);<br>string res;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=num.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>,j=<span class="hljs-number">0</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br><span class="hljs-comment">//num是倒着枚举的，而结果方向与枚举方向相反，在一个空串上不断从左边添加</span><br><span class="hljs-comment">//       1 2 3 4【】 </span><br>res = num[i]+res;<br>++j;<br><span class="hljs-comment">//满足三个条件加逗号，已经有了三个数字，正数时不能是最后一位，负数时前一位不能为‘-’。</span><br><span class="hljs-keyword">if</span>(j%<span class="hljs-number">3</span>==<span class="hljs-number">0</span> &amp;&amp; i &amp;&amp; num[i<span class="hljs-number">-1</span>]!=<span class="hljs-string">&#x27;-&#x27;</span> )<br>res = <span class="hljs-string">&#x27;,&#x27;</span>+res;<br>&#125;<br>cout&lt;&lt;res;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-number">1.</span>to_string() 将一个数字转化为字符串<br><span class="hljs-number">2.</span>字符串的拼接 ‘’+<span class="hljs-built_in">str</span> 向左不断拼接 <span class="hljs-built_in">str</span>+‘’ 向右不断拼接<br><span class="hljs-number">3.</span>正数范围一般比负数小 设计长度的判断可以先判断正数再判断负数<br></code></pre></td></tr></table></figure><h1 id="字符串1005">字符串1005</h1><p>Given a non-negative integer <em>N</em>, your task is to compute thesum of all the digits of <em>N</em>, and output every digit of the sumin English.</p><h3 id="input-specification-1">Input Specification:</h3><p>Each input file contains one test case. Each case occupies one linewhich contains an <em>N</em> (≤10100).</p><h3 id="output-specification-1">Output Specification:</h3><p>For each test case, output in one line the digits of the sum inEnglish words. There must be one space between two consecutive words,but no extra space at the end of a line.</p><h3 id="sample-input-1">Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs in">12345<br></code></pre></td></tr></table></figure><h3 id="sample-output-1">Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">one five<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>string n ;<br>cin&gt;&gt;n;<br><span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i:n)&#123;<br>s+=i-<span class="hljs-string">&#x27;0&#x27;</span>;<br>&#125;<br>string str = <span class="hljs-built_in">to_string</span>(s);<br><span class="hljs-type">char</span> res[<span class="hljs-number">10</span>][<span class="hljs-number">10</span>]=&#123;<span class="hljs-string">&quot;zero&quot;</span>,<span class="hljs-string">&quot;one&quot;</span>,<span class="hljs-string">&quot;two&quot;</span>,<span class="hljs-string">&quot;three&quot;</span>,<span class="hljs-string">&quot;four&quot;</span>,<span class="hljs-string">&quot;five&quot;</span>,<span class="hljs-string">&quot;six&quot;</span>,<span class="hljs-string">&quot;seven&quot;</span>,<span class="hljs-string">&quot;eight&quot;</span>,<span class="hljs-string">&quot;nine&quot;</span>&#125;;<br>cout&lt;&lt;res[str[<span class="hljs-number">0</span>]-<span class="hljs-string">&#x27;0&#x27;</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=str.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>;i++)<br>cout&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>&lt;&lt;res[str[i]-<span class="hljs-string">&#x27;0&#x27;</span>];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">1.</span><span class="hljs-keyword">auto</span> 语法<br><span class="hljs-number">2.</span>处理多余空格时，先输出一个 <br><span class="hljs-number">3.</span>答案比较多时使用<span class="hljs-type">char</span>数组存放结果<br></code></pre></td></tr></table></figure><h1 id="字符串1006">字符串1006</h1><p>At the beginning of every day, the first person who signs in thecomputer room will unlock the door, and the last one who signs out willlock the door. Given the records of signing in's and out's, you aresupposed to find the ones who have unlocked and locked the door on thatday.</p><h3 id="input-specification-2">Input Specification:</h3><p>Each input file contains one test case. Each case contains therecords for one day. The case starts with a positive integer <em>M</em>,which is the total number of records, followed by <em>M</em> lines, eachin the format:</p><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ceylon">ID<span class="hljs-number">_n</span>umber Sign<span class="hljs-number">_</span><span class="hljs-keyword">in</span><span class="hljs-number">_</span>time Sign<span class="hljs-number">_</span><span class="hljs-keyword">out</span><span class="hljs-number">_</span>time<br></code></pre></td></tr></table></figure><p>where times are given in the format <code>HH:MM:SS</code>, and<code>ID_number</code> is a string with no more than 15 characters.</p><h3 id="output-specification-2">Output Specification:</h3><p>For each test case, output in one line the ID numbers of the personswho have unlocked and locked the door on that day. The two ID numbersmust be separated by one space.</p><p>Note: It is guaranteed that the records are consistent. That is, thesign in time must be earlier than the sign out time for each person, andthere are no two persons sign in or out at the same moment.</p><h3 id="sample-input-2">Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>CS301111 15:30:28 17:00:10<br>SC3021234 08:00:00 11:25:25<br>CS301133 21:45:00 21:58:40<br></code></pre></td></tr></table></figure><h3 id="sample-output-2">Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">SC3021234 CS301133<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    string id,<span class="hljs-type">in_t</span>,<span class="hljs-type">out_t</span>;<br>    string fast_id,fast_time;<br>    string last_id,last_time;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;id&gt;&gt;<span class="hljs-type">in_t</span>&gt;&gt;<span class="hljs-type">out_t</span>;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>||<span class="hljs-type">in_t</span>&lt;fast_time)&#123;<br>            fast_id = id;<br>            fast_time = <span class="hljs-type">in_t</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">1</span>||<span class="hljs-type">out_t</span>&gt;last_time)&#123;<br>            last_id = id;<br>            last_time = <span class="hljs-type">out_t</span>;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;fast_id&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;last_id&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1.</span>边读边处理<br><span class="hljs-number">2.</span>当位数相同时，数字大小等同于字典序大小，<span class="hljs-built_in">string</span>可以使用&lt;来比较<br><span class="hljs-number">3.</span>要清楚需要记录什么信息<br></code></pre></td></tr></table></figure><h1 id="字符串1035">字符串1035</h1><p>To prepare for PAT, the judge sometimes has to generate randompasswords for the users. The problem is that there are always someconfusing passwords since it is hard to distinguish <code>1</code> (one)from <code>l</code> (<code>L</code> in lowercase), or <code>0</code>(zero) from <code>O</code> (<code>o</code> in uppercase). One solutionis to replace <code>1</code> (one) by <code>@</code>, <code>0</code>(zero) by <code>%</code>, <code>l</code> by <code>L</code>, and<code>O</code> by <code>o</code>. Now it is your job to write a programto check the accounts generated by the judge, and to help the jugemodify the confusing passwords.</p><h3 id="input-specification-3">Input Specification:</h3><p>Each input file contains one test case. Each case contains a positiveinteger <em>N</em> (≤1000), followed by <em>N</em> lines of accounts.Each account consists of a user name and a password, both are strings ofno more than 10 characters with no space.</p><h3 id="output-specification-3">Output Specification:</h3><p>For each test case, first print the number <em>M</em> of accountsthat have been modified, then print in the following <em>M</em> linesthe modified accounts info, that is, the user names and thecorresponding modified passwords. The accounts must be printed in thesame order as they are read in. If no account is modified, print in oneline <code>There are N accounts and no account is modified</code> where<code>N</code> is the total number of accounts. However, if<code>N</code> is one, you must print<code>There is 1 account and no account is modified</code> instead.</p><h3 id="sample-input-1-1">Sample Input 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs in">3<br>Team000002 Rlsp0dfa<br>Team000003 perfectpwd<br>Team000001 R1spOdfa<br></code></pre></td></tr></table></figure><h3 id="sample-output-1-1">Sample Output 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs out">2<br>Team000002 RLsp%dfa<br>Team000001 R@spodfa<br></code></pre></td></tr></table></figure><h3 id="sample-input-2-1">Sample Input 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs in">1<br>team110 abcdefg332<br></code></pre></td></tr></table></figure><h3 id="sample-output-2-1">Sample Output 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">There is 1 account and no account is modified<br></code></pre></td></tr></table></figure><h3 id="sample-input-3">Sample Input 3:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs in">2<br>team110 abcdefg222<br>team220 abcdefg333<br></code></pre></td></tr></table></figure><h3 id="sample-output-3">Sample Output 3:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs out">There are 2 accounts and no account is modified<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-type">int</span> countt=<span class="hljs-number">0</span>;<br>    string name,pass;<br>    string N[<span class="hljs-number">1001</span>];<br>    string Pass[<span class="hljs-number">1001</span>];<br>    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br>        cin&gt;&gt;name&gt;&gt;pass;<br>        <span class="hljs-type">int</span> tag=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;pass.<span class="hljs-built_in">size</span>();j++)&#123;<br>            <span class="hljs-keyword">if</span>(pass[j]==<span class="hljs-string">&#x27;1&#x27;</span>)<br>                pass[j]=<span class="hljs-string">&#x27;@&#x27;</span>,tag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(pass[j]==<span class="hljs-string">&#x27;0&#x27;</span>)<br>                pass[j]=<span class="hljs-string">&#x27;%&#x27;</span>,tag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(pass[j]==<span class="hljs-string">&#x27;l&#x27;</span>)<br>                pass[j]=<span class="hljs-string">&#x27;L&#x27;</span>,tag=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(pass[j]==<span class="hljs-string">&#x27;O&#x27;</span>)<br>                pass[j]=<span class="hljs-string">&#x27;o&#x27;</span>,tag=<span class="hljs-number">1</span>;<br>        &#125; <br>        <span class="hljs-keyword">if</span>(tag==<span class="hljs-number">1</span>)&#123;<br>countt++;<br>        N[countt] = name;<br>        Pass[countt] = pass;<br>&#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">if</span>(countt==<span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>)<br>            cout&lt;&lt;<span class="hljs-string">&quot;There is 1 account and no account is modified&quot;</span>;<br>        <span class="hljs-keyword">else</span><br>            cout&lt;&lt;<span class="hljs-string">&quot;There are &quot;</span>+<span class="hljs-built_in">to_string</span>(n)+<span class="hljs-string">&quot; &quot;</span>+<span class="hljs-string">&quot;accounts and no account is modified&quot;</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    cout&lt;&lt;countt&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=countt;i++)<br>        cout&lt;&lt;N[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;Pass[i]&lt;&lt;endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1.处理字符串问题时要格外注意换行<br>2.判断条件要细心，记的加括号<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>lxd常用脚本记录</title>
    <link href="/2023/02/28/lxc/"/>
    <url>/2023/02/28/lxc/</url>
    
    <content type="html"><![CDATA[<h1 id="lxc">lxc</h1><h2 id="常用命令">常用命令</h2><p>查看已有的镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo lxc list<br></code></pre></td></tr></table></figure><p>删除快照（保证容器在运行）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lxc delete name<br></code></pre></td></tr></table></figure><p>自动化镜像bash</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">!/bin/bash</span><br>passwd=&#x27;1234&#x27;<br><br>read -p &quot;Enter your full name as the container name, such as zhangsan: &quot; name<br><br>echo &quot;Create the container $name...&quot;<br>echo $passwd | sudo -S lxc copy temp $name<br><br>echo &quot;Start the container $name...&quot;<br>echo $passwd | sudo -S lxc start $name<br><br>sudo -S lxc exec $name -- /bin/bash<br><br></code></pre></td></tr></table></figure><p>自动配置lxc</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs shell">groupmod -n $last_name temp<br><br>echo &quot;Change IP to $IP&quot;<br>mv /etc/netplan/50-cloud-init.yaml /etc/netplan/50-cloud-init.yaml.bak<br>echo &quot;network:<br>  version: 2<br>  ethernets:<br>    eth0:<br>      dhcp4: no<br>      dhcp6: no<br>      addresses:<br>        - $IP/24<br>      gateway4: 125.221.232.1<br>      nameservers:<br>        addresses:<br>          - 255.255.255.0<br>          - 218.75.247.245&quot; &gt; /etc/netplan/50-cloud-init.yaml<br><br>netplan --debug apply<br><br>echo &quot;$last_name:$password&quot; | sudo chpasswd<br><br>reboot<br></code></pre></td></tr></table></figure><p>ref：https://xungejiang.com/2022/07/14/lxd-new/</p>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数字三角形</title>
    <link href="/2022/09/21/20220921/"/>
    <url>/2022/09/21/20220921/</url>
    
    <content type="html"><![CDATA[<h2id="usaco1.5ioi1994数字三角形-number-triangles">[USACO1.5][IOI1994]数字三角形Number Triangles</h2><h2 id="题目描述">题目描述</h2><p>观察下面的数字金字塔。</p><p>写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp">        <span class="hljs-number">7</span> <br>      <span class="hljs-number">3</span>   <span class="hljs-number">8</span> <br>    <span class="hljs-number">8</span>   <span class="hljs-number">1</span>   <span class="hljs-number">0</span> <br>  <span class="hljs-number">2</span>   <span class="hljs-number">7</span>   <span class="hljs-number">4</span>   <span class="hljs-number">4</span> <br><span class="hljs-number">4</span>   <span class="hljs-number">5</span>   <span class="hljs-number">2</span>   <span class="hljs-number">6</span>   <span class="hljs-number">5</span> <br></code></pre></td></tr></table></figure><p>在上面的样例中,从 <span class="math inline">\(7 \to 3 \to 8 \to 7 \to5\)</span> 的路径产生了最大</p><h2 id="输入格式">输入格式</h2><p>第一个行一个正整数 <span class="math inline">\(r\)</span>,表示行的数目。</p><p>后面每行为这个数字金字塔特定行包含的整数。</p><h2 id="输出格式">输出格式</h2><p>单独的一行,包含那个可能得到的最大的和。</p><h2 id="样例-1">样例 #1</h2><h3 id="样例输入-1">样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-number">7</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">7</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="样例输出-1">样例输出 #1</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">30<br></code></pre></td></tr></table></figure><h2 id="提示">提示</h2><p>【数据范围】<br />对于 <span class="math inline">\(100\%\)</span> 的数据，<spanclass="math inline">\(1\le r \le 1000\)</span>，所有输入在 <spanclass="math inline">\([0,100]\)</span> 范围内。</p><p>题目翻译来自NOCOW。</p><p>USACO Training Section 1.5</p><p>IOI1994 Day1T1</p><h2 id="问题分析">问题分析</h2><p>毫无疑问的，一道典型的线性DP问题。也可以看到这是IOI1994年的第一题，~<del>就拿过去两年的IOI什么成分不用我说了吧</del>~</p><h3 id="状态设定">状态设定</h3><p>问题需要求解自上而下的最大路径和，我们令状态<spanclass="math inline">\(\ f[i,j]\ \)</span>代表</p><p>（1）以第<span class="math inline">\(i\)</span>行第<spanclass="math inline">\(j\)</span>个数为结尾。</p><p>（2）包括这个位置在内的合法位置的最大的路径和。</p><h3 id="状态的转移">状态的转移</h3><p>最优路径实际上是一个树，我们考虑从后向前推。</p><p>所有的求解路径构成一个满二叉树，~<del>不会真的有人枚举吧</del>我们考虑倒数第二层的某个节点（状态），那么为了最大化最终的答案，这个节点应该选取他左下或者右下较大的一个数作为路径，枚举这一层的节点，可以获取最后一层的最优答案。所以得出如下转移方程。</p><p><span class="math inline">\(f[i,j] =\max(f[i+1,j],f[i+1,j+1])+A[i,j]\\a=？\)</span></p><h3 id="初始状态">初始状态</h3><p><del>明显全部为零</del></p><h3 id="code">CODE</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#include &lt;bits/stdc++.h&gt;</span><br>using namespace std;<br><span class="hljs-built_in">int</span> A[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> n;<br><span class="hljs-built_in">int</span> F[<span class="hljs-number">1005</span>][<span class="hljs-number">1005</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-built_in">int</span> main()&#123;<br>cin&gt;&gt;n;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>cin&gt;&gt;A[i][j];<br>&#125;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=n;i&gt;=<span class="hljs-number">1</span>;i--)&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> j=<span class="hljs-number">1</span>;j&lt;=i;j++)&#123;<br>F[i][j] = <span class="hljs-built_in">max</span>(F[i+<span class="hljs-number">1</span>][j],F[i+<span class="hljs-number">1</span>][j+<span class="hljs-number">1</span>])+A[i][j];<br>&#125;<br>&#125;<br>cout&lt;&lt;F[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];<br></code></pre></td></tr></table></figure><h3 id="忘记的部分">忘记的部分</h3><p><del>我当时为什么会想到倒着枚举呢</del></p><p><del>是因为写了太多难题导致这么裸的题我考虑的太复杂了吗，状态i明显只有两种转移态，果然是抽象的题写的太多了吗。。。是啊，从开始学动态规划到AK紫题好像只过了10天诶，肯定不是我当时没理解瞎jb写没错</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>线性DP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo配置记录</title>
    <link href="/2022/09/21/hello-world/"/>
    <url>/2022/09/21/hello-world/</url>
    
    <content type="html"><![CDATA[<p>最终对于公式无法正常换行的问题还是没有解决</p><h2 id="brew的安装">brew的安装</h2><h3id="使用脚本安装brew期间会自动安装git">使用脚本安装brew，期间会自动安装git</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>zsh -c <span class="hljs-string">&quot;$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)&quot;</span><br></code></pre></td></tr></table></figure><h3 id="brew初始化-添加不受信任的路径">brew初始化添加不受信任的路径</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">brew -v</span><br></code></pre></td></tr></table></figure><h3 id="git-的初始化">git 的初始化</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;Zs&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;1990977934@qq.com&quot;</span><br></code></pre></td></tr></table></figure><h3 id="git命令一条龙">git命令一条龙</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br>git <span class="hljs-keyword">add</span> .<br>git commit -m <span class="hljs-string">&quot;conclusion&quot;</span><br></code></pre></td></tr></table></figure><h3 id="hexo">hexo</h3><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br>hexo clean<br>hexo s<br>hexo d<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>环境搭建</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识cuda</title>
    <link href="/2022/09/21/%E5%88%9D%E5%85%A5cuda/"/>
    <url>/2022/09/21/%E5%88%9D%E5%85%A5cuda/</url>
    
    <content type="html"><![CDATA[<h1 id="前言">前言</h1><p><del>一堆吊事文档都没时间看，埋了埋了，下次继续</del></p>]]></content>
    
    
    
    <tags>
      
      <tag>cuda</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
